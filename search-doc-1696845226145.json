[{"title":"What is Jellyfish?","type":0,"sectionRef":"#","url":"/jellyfish-docs/next","content":"","keywords":""},{"title":"Supported protocols​","type":1,"pageTitle":"What is Jellyfish?","url":"/jellyfish-docs/next#supported-protocols","content":"Jellyfish supports following protocols: WebRTC - used for creating real-time video conferencing systemsHLS - allows for implementing broadcasting solutionsRTSP - very often used for consuming streams from IP cameras "},{"title":"Cluster","type":0,"sectionRef":"#","url":"/jellyfish-docs/next/cluster","content":"","keywords":""},{"title":"Configuring a Cluster​","type":1,"pageTitle":"Cluster","url":"/jellyfish-docs/next/cluster#configuring-a-cluster","content":"Jellyfish cluster can be created in 4 simple steps: Enable distribution mode with JF_DIST_ENABLED=trueGive your node a name with JF_DIST_NODE_NAMESpecify a list of nodes to connect to with JF_DIST_NODESConfigure HTTP and metrics ports so they don't overlap with other nodes. You can do this with JF_PORT and JF_METRICS_PORT environment variables. Distribution Environment Variables List of all cluster-related environment variables is available here. Security Currently, Jellyfish distribution is not encrypted meaning that data between Jellyfishes is sent as plain text. Cookie does not provide any cryptographic security. Do run a cluster only across machines in the same network! Extra network Configuration Jellyfish leverages Erlang Distribution to form a cluster. This means that we don't need to use any database where we would store information about network topology. Instead, some extra network configuration might be needed. Jellyfish uses a service called EPMD (Erlang Port Mapper Deamon) that runs on port 4369 (TCP). If you run Jellyfish using Docker, you have to explicitly export this port. In production deployment, you also have to allow for traffic on this port in your firewall. EPMD is started automatically when running Jellyfish, so you don't need to take any extra steps to make it work. Jellyfish uses a random port for connecting to other Jellyfishes. If you run Jellyfish using Docker, this port defaults to 9000 (TCP) but you can configure the range it is selected from with JF_DIST_MIN_PORT and JF_DIST_MAX_PORT. Note that JF_DIST_MIN_PORT and JF_DIST_MAX_PORT are not available when running from source (using mix phx.server) as in development you don't have to worry about the port used for forming a cluster. As in the case of EPMD, in production deployment, you have to modify your firewall rules appropriately. See Deeper dive into Erlang Distribution for more information. "},{"title":"Examples​","type":1,"pageTitle":"Cluster","url":"/jellyfish-docs/next/cluster#examples","content":""},{"title":"Running from source​","type":1,"pageTitle":"Cluster","url":"/jellyfish-docs/next/cluster#running-from-source","content":"Run the first Jellyfish: JF_DIST_ENABLED=true JF_DIST_NODE_NAME=j1@127.0.0.1 mix phx.server  Run the second Jellyfish JF_DIST_ENABLED=true JF_DIST_NODE_NAME=j2@127.0.0.1 JF_DIST_NODES=&quot;j1@127.0.0.1&quot; JF_PORT=4002 JF_METRICS_PORT=9468 mix phx.server  info Note that when running the second Jellyfish, we had to change its HTTP and metrics ports. "},{"title":"Running with Docker (locally)​","type":1,"pageTitle":"Cluster","url":"/jellyfish-docs/next/cluster#running-with-docker-locally","content":"This simple docker compose file sets a cluster of two Jellyfishes. version: &quot;3&quot; x-jellyfish-template: &amp;jellyfish-template build: . environment: &amp;jellyfish-environment JF_SERVER_API_TOKEN: &quot;development&quot; JF_DIST_ENABLED: &quot;true&quot; JF_DIST_MODE: &quot;sname&quot; JF_DIST_NODES: &quot;j1@jellyfish1 j2@jellyfish2&quot; restart: on-failure services: jellyfish1: &lt;&lt;: *jellyfish-template environment: &lt;&lt;: *jellyfish-environment JF_HOST: &quot;localhost:5001&quot; JF_PORT: 5001 JF_METRICS_PORT: 6001 JF_DIST_NODE_NAME: j1@jellyfish1 ports: - 5001:5001 - 6001:6001 jellyfish2: &lt;&lt;: *jellyfish-template environment: &lt;&lt;: *jellyfish-environment JF_HOST: &quot;localhost:5002&quot; JF_PORT: 5002 JF_METRICS_PORT: 6002 JF_DIST_NODE_NAME: j2@jellyfish2 ports: - 5002:5002 - 6002:6002  Because we run Jellyfishes in the same Docker network: we can use JF_DIST_NODE: &quot;sname&quot;, which allows us to reference Jellyfishes using their service names sojellyfish1 and jellyfish2we don't need to export EPMD (4369) or distribution (9000) ports "},{"title":"Running with Docker (globally)​","type":1,"pageTitle":"Cluster","url":"/jellyfish-docs/next/cluster#running-with-docker-globally","content":"When forming a cluster across multiple machines: you have to take care of Extra Network Configurationyou also can't use JF_DIST_MODE=&quot;sname&quot; as you have to name Jellyfish nodes using their publicly available IP address or domain names (see JF_DIST_NODE_NAME and JF_DIST_MODE)you can't simulate this setup locally as you won't be able to expose two EMPD ports on the same machine. See Deeper dive into Erlang Distribution for more information. See our Jellyfish Videoroom deployment configuration for an example. "},{"title":"Verifying that a cluster has been created​","type":1,"pageTitle":"Cluster","url":"/jellyfish-docs/next/cluster#verifying-that-a-cluster-has-been-created","content":"When a cluster is created correctly you will see a log indicating that one of your Jellyfishes connected to the other one, e.g.: [info] [libcluster:epmd_cluster] connected to :&quot;j1@127.0.0.1&quot;  To see clustering in action, create two rooms using the same Jellyfish address and observe how they are load balanced: curl -X POST -H &quot;authorization: Bearer development&quot; http://localhost:4002/room # {&quot;data&quot;:{&quot;jellyfish_address&quot;:&quot;localhost:4001&quot;}}  curl -X POST -H &quot;authorization: Bearer development&quot; http://localhost:4002/room # {&quot;data&quot;:{&quot;jellyfish_address&quot;:&quot;localhost:4002&quot;}}  Load balancing can also be tested using Jellyfish Dashboard. See here for more information. "},{"title":"Deeper dive into Erlang Distribution​","type":1,"pageTitle":"Cluster","url":"/jellyfish-docs/next/cluster#deeper-dive-into-erlang-distribution","content":"The most tricky thing when running Jellyfish in a cluster is to understand the role of EPMD. EPMD is responsible for mapping node names to ports they use. Node names consist of two parts nodename@hostname.hostname identifies a host machine, and nodename identifies a node on this machine. When node A wants to connect to node B, it uses node's B name to ask EPMD (running on node B) for the actual port node B is accessible on. Example Let's assume that node's B name is nodeb@192.168.1.2.Node A will contact EPMD using 192.168.1.2 IP address and port 4369, and ask for the port number used by a node with the name nodeb.After that, node A can contact node B using 192.168.1.2 IP address and port returned by EPMD. A couple of notes about EPMD: it always uses port 4369 (TCP)it is started automatically when running Jellyfishthere is one EPMD per machine or one EPMD per docker container - that's why we can't simulate Global Docker setup locally You can read more about Erlang Distribution here. "},{"title":"Fly.io (experimental)","type":0,"sectionRef":"#","url":"/jellyfish-docs/next/deploying/fly_io","content":"","keywords":""},{"title":"Creating new app​","type":1,"pageTitle":"Fly.io (experimental)","url":"/jellyfish-docs/next/deploying/fly_io#creating-new-app","content":"Launch fly launch. When prompted, copy the configuration from the existing fly.toml file. Select appropriate app name and region, don't create any databases. Don't deploy the app just yet. Running fly launch may modify the Dockerfile. Make sure to remove the lines appended by flyctl. "},{"title":"Configuring the App​","type":1,"pageTitle":"Fly.io (experimental)","url":"/jellyfish-docs/next/deploying/fly_io#configuring-the-app","content":"Before deploying your app, make sure it is correctly configured. "},{"title":"Dedicated IPv4​","type":1,"pageTitle":"Fly.io (experimental)","url":"/jellyfish-docs/next/deploying/fly_io#dedicated-ipv4","content":"In order to transmit multimedia via UDP, the app has to be publicly available with an IPv4 address. By default Fly.io uses shared IP. To enable dedicated IPv4 address run fly ips allocate-v4  Note, that dedicated IP address is a paid feature on Fly.io. You can learn more about dedicated IPv4 address here. "},{"title":"fly.toml​","type":1,"pageTitle":"Fly.io (experimental)","url":"/jellyfish-docs/next/deploying/fly_io#flytoml","content":"Make sure you don't have the following lines in the fly.toml, which are automatically generated by fly launch. You don't need to run migrations, since you don't have a database. [deploy] release_command = &quot;/app/bin/migrate&quot;  Jellyfish uses JF_HOST variable instead of the default PHX_HOST. JF_HOST = &quot;&lt;YOUR APP HOSTNAME&gt;&quot;  Also, make sure you have set the correct port. The environment variable JF_PORT has to match the TCP internal_port defined under services section. The default for Jellyfish is 5002 in development and 8080 in production (when using Docker or mix release). To be able to receive and send UDP traffic, Jellyfish has to open its UDP ports on a special fly-global-services address, not 0.0.0.0. This must be set using the JF_WEBRTC_TURN_LISTEN_IP enviroment variable. You also need to specify the Jellyfish IP address for UDP, it is the IP address which you generated in the previous step. JF_WEBRTC_TURN_LISTEN_IP = &quot;fly-global-services&quot; JF_WEBRTC_TURN_IP=&quot;&lt;YOUR APP IP ADDRESS&gt;&quot;  You can also read tutorial for running Fly.io apps which use UDP. "},{"title":"Fly.io secrets​","type":1,"pageTitle":"Fly.io (experimental)","url":"/jellyfish-docs/next/deploying/fly_io#flyio-secrets","content":"There are environment variables, which you may not want to keep in the fly.toml config. Fly.io provides a way to store such values securely. For Jellyfish you need to configure just one secret - JF_SERVER_API_TOKEN. flyctl secrets set JF_SERVER_API_TOKEN=development  "},{"title":"Deploying​","type":1,"pageTitle":"Fly.io (experimental)","url":"/jellyfish-docs/next/deploying/fly_io#deploying","content":"With everything configured you can deploy the app fly deploy  Note that it may take a moment for the UDP traffic to be forwarded to the application. This means for example, that WebRTC may not be working yet. This is the tricky part of the deployment, which we weren't able to entirely figure out. Sometimes the UDP just works, others it takes ages for it to start flowing.This topic describes the exact issue we had with Fly.io. In general, it is unclear when the UDP traffic starts to be forwarded, sometimes it happens relatively quickly after deployment, sometimes you need to wait for some time. Also, the Fly.io documentation isn't clear in regard to opening UDP sockets. Some information was gathered experimentally, or based on Fly.io community questions, such as this one. "},{"title":"Cloud VPS with cloud-init","type":0,"sectionRef":"#","url":"/jellyfish-docs/next/deploying/vps","content":"","keywords":""},{"title":"1. Creating primary IP​","type":1,"pageTitle":"Cloud VPS with cloud-init","url":"/jellyfish-docs/next/deploying/vps#1-creating-primary-ip","content":"Because configuring a server with cloud-init using our script requires you to have a registered domain pointing at a particular IP address, we divided the process of creating VPS into two parts: obtaining dedicated IP addressconfiguring the server using cloud-init Let's start with the first one. In Hetzner's project site go to the section Primary IPs then click Create Primary IP button. Choose a data center location for your server and select IPv4 protocol. You can also name that IP if you'd like. "},{"title":"2. Registering Domain​","type":1,"pageTitle":"Cloud VPS with cloud-init","url":"/jellyfish-docs/next/deploying/vps#2-registering-domain","content":"We'll not suggest you to use a specific domain provider, maybe you've got one chosen so we'll describe this step without details that may be different among providers. If you'd like, you can use Hetzner as well to register a domain. After registering your domain go to the DNS Records Table of your provider and create an A record pointing to the IP you've created in the previous step. "},{"title":"3. Choosing the right VPS​","type":1,"pageTitle":"Cloud VPS with cloud-init","url":"/jellyfish-docs/next/deploying/vps#3-choosing-the-right-vps","content":"Now let's go back to the Hetzner project site. It's time to choose and configure a server for Jellyfish. Although Jellyfish doesn't have minimum requirements to work, we encourage you to choose a middle-sized VPS (at least 8 cores) as media processing is consuming quite a lot of CPU. Remember to choose a server located in the data center where you've created an IP address in the first step. For this tutorial, we decided on CPX21 from Hetzner Cloud running Ubuntu 22:  "},{"title":"4. Assigning Primary IP​","type":1,"pageTitle":"Cloud VPS with cloud-init","url":"/jellyfish-docs/next/deploying/vps#4-assigning-primary-ip","content":"Below the list of the VPS types there is a Networking section where your Primary IP from Step 1 is waiting to be used. Select it.  "},{"title":"5. Adding a cloud-init configuration​","type":1,"pageTitle":"Cloud VPS with cloud-init","url":"/jellyfish-docs/next/deploying/vps#5-adding-a-cloud-init-configuration","content":"To configure a server and install Jellyfish on it we're going to use cloud-init. It's a preinstalled tool that lets you set up a newly created server with a YAML config file. In the configuration you can create a user, choose packages to be installed, configure them, write or modify files and in our case finally run a docker container. Full documentation about keys you can use in a cloud-config file can be found in the official cloud-init documentation. "},{"title":"A cloud-config tempalte​","type":1,"pageTitle":"Cloud VPS with cloud-init","url":"/jellyfish-docs/next/deploying/vps#a-cloud-config-tempalte","content":"We prepared a template cloud-config that will configure your server and start a chosen version of Jellyfish: cloud-config.yaml #cloud-config users: - name: jellyfish groups: docker sudo: null shell: /bin/false no_create_home: true ssh_pwauth: false disable_root_opts: no-port-forwarding,no-agent-forwarding,no-X11-forwarding apt: sources: docker.list: source: &quot;deb [arch=amd64,arm64] https://download.docker.com/linux/ubuntu jammy stable&quot; keyid: 9DC858229FC7DD38854AE2D88D81803C0EBFCD88 packages: - ufw - fail2ban - gzip - containerd.io - docker-ce - docker-ce-cli - nginx - certbot write_files: - path: /opt/jellyfish/env-file defer: true owner: jellyfish:jellyfish runcmd: - export JELLYFISH_VERSION=0.2.0 - export JELLYFISH_DOMAIN=mydomain.example.com - export LETSENCRYPT_EMAIL=my@email.com - export SERVER_API_TOKEN=test_token - systemctl enable fail2ban - ufw default deny outgoing - ufw default deny incoming - ufw default deny routed - ufw allow in ssh - ufw allow out https - ufw allow out domain - ufw allow in 80/tcp - ufw allow in 443/tcp - ufw allow in 50000:500100/udp - ufw allow in 49999/tcp - ufw allow out 5002 - ufw allow out from any port 50000:50100 proto udp to any - ufw allow out 49999 proto tcp to any - ufw enable - service nginx stop - &quot;[ ! -f /etc/letsencrypt/live/$JELLYFISH_DOMAIN/cert.pem ] &amp;&amp; certbot certonly --standalone --noninteractive --agree-tos --email $LETSENCRYPT_EMAIL -d $JELLYFISH_DOMAIN&quot; - | cat &lt;&lt; EOF &gt; /etc/cron.d/cert_renew 0 4 * * * [jellyfish] certbot certonly --webroot -w /usr/share/nginx/html -d $JELLYFISH_DOMAIN --keep-until-expiring --quiet 5 4 * * * [jellyfish] service nginx reload EOF - | cat &lt;&lt; EOF &gt; /etc/nginx/sites-available/$JELLYFISH_DOMAIN server { server_name $JELLYFISH_DOMAIN; location / { proxy_pass http://localhost:5002; proxy_http_version 1.1; proxy_set_header Upgrade \\$http_upgrade; proxy_set_header Connection &quot;Upgrade&quot;; proxy_set_header Host \\$host; } listen [::]:443 ssl http2; # managed by Certbot listen 443 ssl http2; # managed by Certbot ssl_certificate /etc/letsencrypt/live/$JELLYFISH_DOMAIN/fullchain.pem; # managed by Certbot ssl_certificate_key /etc/letsencrypt/live/$JELLYFISH_DOMAIN/privkey.pem; # managed by Certbot } server { listen 80; listen [::]:80; server_name $JELLYFISH_DOMAIN; # Do not HTTPS redirect Let'sEncrypt ACME challenge location /.well-known/acme-challenge/ { auth_basic off; allow all; root /usr/share/nginx/html; try_files \\$uri =404; break; } location / { return 301 https://\\$host\\$request_uri; } } EOF - ln -sf /etc/nginx/sites-available/$JELLYFISH_DOMAIN /etc/nginx/sites-enabled/$JELLYFISH_DOMAIN - service nginx start - | cat &lt;&lt; EOF &gt; /opt/jellyfish/env-file JF_HOST=$JELLYFISH_DOMAIN JF_PORT=5002 JF_SERVER_API_TOKEN=$SERVER_API_TOKEN JF_CHECK_ORIGIN=false JF_WEBRTC_TURN_IP=$(ip route get 1.0.0.0 | sed -n 's/^.*src \\([0-9.]*\\) .*$/\\1/p') JF_WEBRTC_TURN_TCP_PORT=49999 JF_WEBRTC_TURN_PORT_RANGE=50000-50100 JF_WEBRTC_TURN_LISTEN_IP=0.0.0.0 EOF - [ su, jellyfish, -s, /bin/bash, -c, &quot;docker run -d \\ --restart unless-stopped \\ -p 50000-50100:50000-50100/udp \\ -p 5002:5002 \\ --env-file /opt/jellyfish/env-file \\ -v /opt/jellyfish/jellyfish_output:/app/jellyfish_output \\ ghcr.io/jellyfish-dev/jellyfish:$JELLYFISH_VERSION&quot;, ]  You'll need to manually take care of four lines in that template: - export JELLYFISH_VERSION=0.1.0-ed317bChange the value if you want to deploy a different version of Jellyfish. You can find the list of available versions in our package repository- export JELLYFISH_DOMAIN=mydomain.example.comEnter here a domain you've configured with A record in step 2.- export LETSENCRYPT_EMAIL=my@email.comEnter your email address to be notified when the SSL certificate will be about to expire.export SERVER_API_TOKEN=test_tokenServer API token is a token you'll need to connect to Jellyfish via API or SDK. Write here a chosen secret value you're going to remember later. Copy the file and change up those two variables. You're going to need the content of the file in the next section. "},{"title":"Other tools we'll install with cloud-init​","type":1,"pageTitle":"Cloud VPS with cloud-init","url":"/jellyfish-docs/next/deploying/vps#other-tools-well-install-with-cloud-init","content":"As you might noticed we've chosen some packages to be installed: ufw - Uncomplicated Firewall. We'll need it to allow or block traffic on specific ports https://help.ubuntu.com/community/UFW.fail2ban - Tool to block traffic recognized as unauthorized https://www.fail2ban.org/wiki/index.php/Main_Pagegzip - Compression Utility https://www.gzip.org/containerd.io, docker-ce, docker-ce-cli - Docker and Docker-related libraries. "},{"title":"Setting up Hetzner cloud VPS with cloud-config​","type":1,"pageTitle":"Cloud VPS with cloud-init","url":"/jellyfish-docs/next/deploying/vps#setting-up-hetzner-cloud-vps-with-cloud-config","content":"Now, we're going to use the content of the file you prepared in the Hetzner cloud VPS creating form. To do it scroll to the Cloud config section of the form and paste the content of your cloud-config.yaml file.  caution cloud-init will recognize the file as a configuration only if the file starts with that comment: #cloud-config ... So be careful while copying. That's it. You can click 'Create &amp; Buy' and the server will start to configure. tip Think about adding your public SSH key while creating a VPS instance. It will ease up connecting to VPS later. If you don't add any key you're going to need a root password (you'll receive it in an email after creating VPS) "},{"title":"6. Checking cloud-init status​","type":1,"pageTitle":"Cloud VPS with cloud-init","url":"/jellyfish-docs/next/deploying/vps#6-checking-cloud-init-status","content":"Configuring your server will take some time, but it's created almost immediately after creation. You can log into the server using ssh: ssh root@&lt;VPS_IP&gt;  then, in the server's terminal you can check the current status of cloud-init: cloud-init status  Possible responses are running, error and done. The first one informs you that cloud-init is still configuring your server. The second one means that something went wrong. You can find logs from the cloud-init run in /var/log/cloud-init-output.log file.done means that your jellyfish server is ready to be used. If you'd like to keep an eye on the cloud-init process you can use: cloud-init status --wait  To see the output when the process is finished (successfully or not). "},{"title":"Testing your instance with the Jellyfish dashboard​","type":1,"pageTitle":"Cloud VPS with cloud-init","url":"/jellyfish-docs/next/deploying/vps#testing-your-instance-with-the-jellyfish-dashboard","content":"To see how (or if) your Jellyfish server is working you can test it by connecting our Jellyfish Dashboard with your server. Detailed instructions on how to use Jellyfish Dashboard can be found here. "},{"title":"Examples","type":0,"sectionRef":"#","url":"/jellyfish-docs/next/examples","content":"Examples Jellyfish usage examples utilising server SDKs can be found in the following locations: Elixir","keywords":""},{"title":"API Reference","type":0,"sectionRef":"#","url":"/jellyfish-docs/next/for_developers/api_reference","content":"API Reference Jellyfish API is composed of three layers a REST API for managing Jellyfish statea WS connection for client SDK communication (socket path /socket/peer)a WS connection for server notifications (socket path /socket/server) You can find them here: OpenAPI REST descriptionProtobufs used by peer WSProtobufs used by server WS The communication via WebSockets uses Protobuf format. The very first message that has to be sent on either of the WebSocket connections (peer to Jellyfish oryour_backend_server to Jellyfish) is AuthRequest. All supported messages are listed in the Jellyfish protos repo. If you want to create your own Jellyfish SDK, the easiest way to reference defined protobuf messages will be by adding protos to your git repository as a git submodule. You can do it with this command: git submodule add https://github.com/jellyfish-dev/protos You could also consider creating a script that will pull the newest changes from the git submodule and compile.proto files to your chosen programming language. For reference, see the script used in our Elixir SDK.","keywords":""},{"title":"Design Docs","type":0,"sectionRef":"#","url":"/jellyfish-docs/next/for_developers/design_docs","content":"Design Docs Crucial parts of Jellyfish architecture are always discussed and written down in the form of design documents. Each design document describes, in a nutshell, a few possible solutions or approaches to some problem and states which solution was accepted and why. The list of Jellyfish Design Docs is available here.","keywords":""},{"title":"Architecture","type":0,"sectionRef":"#","url":"/jellyfish-docs/next/getting_started/architecture","content":"","keywords":""},{"title":"Server SDKs​","type":1,"pageTitle":"Architecture","url":"/jellyfish-docs/next/getting_started/architecture#server-sdks","content":"Server SDKs allow you to manage Jellyfish state. In particular, you can: authenticatecreate/delete roomsadd/remove peersadd/remove componentssubscribe for notifications Under the hood, Server SDKs just use Jellyfish REST and WS API, see Jellyfish API. tip As an example, you can use server SDK to introduce a time limit on meeting duration and shut down the room after it passes. "},{"title":"Client SDKs​","type":1,"pageTitle":"Architecture","url":"/jellyfish-docs/next/getting_started/architecture#client-sdks","content":"Client SDKs allow you to connect to Jellyfish to publish and consume tracks. In particular, you can: authenticatejoin specific roompublish audio and videoreceive audio and video from other peers and components At the moment, Jellyfish supports only one type of client - WebRTC. "},{"title":"Diagram​","type":1,"pageTitle":"Architecture","url":"/jellyfish-docs/next/getting_started/architecture#diagram","content":"The whole concept is presented in the following diagram.     Your Backend (BE) - serves your application frontend, and manages the database and application-specific logic. Jellyfish (JF) - Jellyfish media server. Manages media. Admin - someone who has special permission in your application - can create/delete rooms, add/remove peers, etc. User - someone who connects to Jellyfish to send and receive media. Everything starts with Admin who sends an HTTP request to BE to create a new room.BE uses jellyfish-server-sdk to communicate with JF and create the room. Under the hood, jellyfish-server-sdk uses REST API exposed by JF. After the room has been created, the Admin invites a user by sending a new HTTP request to BE. Again, BE uses jellyfish-server-sdk to add the new peer to JF. On the user side, they send a request to BE to join the room.BE replies with JF IP address it should connect to. Then, the User uses jellyfish-client-sdk to connect to JF. After the connection has been established, the User can send and receive media. "},{"title":"Authentication","type":0,"sectionRef":"#","url":"/jellyfish-docs/next/getting_started/authentication","content":"Authentication The Authentication mechanism is based on a bearer token. How does it work? Both Jellyfish and Business Logic are configured with the same secret. This secret is used for authorizing HTTP requests between them (via HTTP authorization request header). When a new client wants to join a room, Business Logic (assuming the client is authorized to join) requests adding a new peer and receives a token generated by Jellyfish. The token must then be passed to the client, that will use it to connect to the room as a new peer. The token encodes both peer and room IDs. The token exchange is handled by our Client SDKs when connecting. Under the hood, Jellyfish expects the token in the first message after opening the Web Socket connection. Token encodes peer id and room id. Run Jellyfish JF_SERVER_API_TOKEN=JF_SERVER_API_TOKEN mix phx.server Create a room and add one peer Business Logic client = Jellyfish.Client.new(&quot;http://address-of-your-server.com&quot;, &quot;JF_SERVER_API_TOKEN&quot;) {:ok, room, _jellyfish_address} = Jellyfish.Room.create(client, max_peers: 10) {:ok, peer, peer_token} = Jellyfish.Room.add_peer(client, room.id, &quot;BobId&quot;) Connect as a peer to Jellyfish Client client.connect({ token: peerToken, peerMetadata: { name: &quot;Bob&quot; }, isSimulcastOn: false }) ","keywords":""},{"title":"HLS","type":0,"sectionRef":"#","url":"/jellyfish-docs/next/getting_started/components/hls","content":"","keywords":""},{"title":"Compatibility​","type":1,"pageTitle":"HLS","url":"/jellyfish-docs/next/getting_started/components/hls#compatibility","content":"WebRTCRTSP "},{"title":"Requirements​","type":1,"pageTitle":"HLS","url":"/jellyfish-docs/next/getting_started/components/hls#requirements","content":"The Room in which the HLS component is created must have the video codec set to H264. See API for more information.Max 1 HLS component allowed per room. "},{"title":"Configuration options​","type":1,"pageTitle":"HLS","url":"/jellyfish-docs/next/getting_started/components/hls#configuration-options","content":"Optional lowLatency (boolean, default: false) - whether the component should use LL-HLS "},{"title":"Env variables​","type":1,"pageTitle":"HLS","url":"/jellyfish-docs/next/getting_started/components/hls#env-variables","content":"Currently, there are no environment variables related to this component. "},{"title":"Output​","type":1,"pageTitle":"HLS","url":"/jellyfish-docs/next/getting_started/components/hls#output","content":"After adding a WebRTC peer (and at least one track) or an RTSP component, the HLS stream will be available under http://&lt;jellyfish-address&gt;/hls/&lt;room_id&gt;/index.m3u8 (or https://, if using TLS). "},{"title":"Example Docker commands​","type":1,"pageTitle":"HLS","url":"/jellyfish-docs/next/getting_started/components/hls#example-docker-commands","content":"The HLS playlist will be created inside the Docker container. To access it from the host, you need to create a volume, e.g. by adding the option -v $(pwd)/jellyfish_output:/app/jellyfish_outputto your Docker command. Other than that, your Docker commands shouldn't be affected by adding this component. docker run -p 8080:8080/tcp \\ -e JF_SERVER_API_TOKEN=token \\ -e JF_HOST=localhost:8080 \\ -v $(pwd)/jellyfish_output:/app/jellyfish_output \\ ghcr.io/jellyfish-dev/jellyfish:0.2.0  "},{"title":"RTSP","type":0,"sectionRef":"#","url":"/jellyfish-docs/next/getting_started/components/rtsp","content":"","keywords":""},{"title":"Compatibility​","type":1,"pageTitle":"RTSP","url":"/jellyfish-docs/next/getting_started/components/rtsp#compatibility","content":"WebRTCHLS "},{"title":"Requirements​","type":1,"pageTitle":"RTSP","url":"/jellyfish-docs/next/getting_started/components/rtsp#requirements","content":"RTSP component always outputs H264 stream so if the Room in which the RTSP component is created enforces a video codec, it must be set to H264. See API for more information. "},{"title":"Configuration options​","type":1,"pageTitle":"RTSP","url":"/jellyfish-docs/next/getting_started/components/rtsp#configuration-options","content":"Required sourceUri (string) - URI of RTSP source stream, e.g. &quot;rtsp://mysite.net:554/stream&quot; Optional rtpPort (integer 1..65535, default: 20000) - Local port RTP stream will be received atreconnectDelay (integer 0.., default: 15000) - Delay (in ms) between successive reconnect attemptskeepAliveInterval (integer 0.., default: 15000) - Interval (in ms) in which keep-alive RTSP messages will be sent to the remote stream sourcepierceNat (boolean, default: true) - Whether to attempt to create client-side NAT binding by sending an empty datagram from client to source, after the completion of RTSP setup "},{"title":"Env variables​","type":1,"pageTitle":"RTSP","url":"/jellyfish-docs/next/getting_started/components/rtsp#env-variables","content":"Currently, there are no environment variables related to this component. "},{"title":"Example Docker commands​","type":1,"pageTitle":"RTSP","url":"/jellyfish-docs/next/getting_started/components/rtsp#example-docker-commands","content":"caution If the client is behind NAT, the option --network=host is necessary since Docker can change the source port of UDP packets for routing reasons, which breaks the pierceNat functionality. This means that users on macOS will most likely be unable to access any RTSP stream source outside of their network when running Jellyfish using Docker. If you're on macOS and want to receive RTSP streams from behind NAT, right now the only way is to build Jellyfish natively from source. Explicit port exposure (macOS compatible) docker run -p 20000:20000/udp \\ -p 8080:8080/tcp \\ -e JF_SERVER_API_TOKEN=token \\ -e JF_HOST=localhost:8080 \\ ghcr.io/jellyfish-dev/jellyfish:0.2.0  caution Make sure that the exposed UDP port matches the one used by the RTSP component (option rtpPort, default: 20000). If using multiple RTSP components, more ports will need to be exposed. Using host network (Linux only) docker run --network=host \\ -e JF_SERVER_API_TOKEN=token \\ -e JF_HOST=localhost:8080 \\ ghcr.io/jellyfish-dev/jellyfish:0.2.0  "},{"title":"Installation","type":0,"sectionRef":"#","url":"/jellyfish-docs/next/getting_started/installation","content":"","keywords":""},{"title":"Building from source​","type":1,"pageTitle":"Installation","url":"/jellyfish-docs/next/getting_started/installation#building-from-source","content":"Make sure to have both Elixir and Rust installed. Check the links below for instructions: ElixirRust Clone the Jellyfish repo git clone https://github.com/jellyfish-dev/jellyfish.git  Install native dependencies macOS IntelmacOS Apple SiliconUbuntu These instructions assume you have Homebrew installed. You can get it here. brew install srtp libnice clang-format ffmpeg opus pkg-config export LDFLAGS=&quot;-L/usr/local/opt/openssl@1.1/lib&quot; export CFLAGS=&quot;-I/usr/local/opt/openssl@1.1/include/&quot; export CPPFLAGS=&quot;-I/usr/local/opt/openssl@1.1/include/&quot; export PKG_CONFIG_PATH=&quot;/usr/local/opt/openssl@1.1/lib/pkgconfig&quot;  Install elixir dependencies mix deps.get  Run the server in development mix phx.server  Create a binary You can also create Jellyfish binary with: MIX_ENV=prod mix release  Then follow instructions printed in your terminal. info The difference between running with mix phx.server and generating target binary is that the latter is prepared for running in production so e.g. it includes some Erlang Virtual Machine tweaks. Jellyfish Dockerfile always uses mix release under the hood. "},{"title":"Running with Docker​","type":1,"pageTitle":"Installation","url":"/jellyfish-docs/next/getting_started/installation#running-with-docker","content":"Docker images are built for production which means that you always need to set a couple of environment variables. An example docker command running bare Jellyfish HTTP service locally: docker run -p 8080:8080/tcp -e JF_HOST=localhost:8080 JF_SERVER_API_TOKEN=token ghcr.io/jellyfish-dev/jellyfish:0.2.0  Note that in real case scenarios, docker commands depend on peers/components you are going to use. Therefore, we don't present them here but rather in each peer/component's documentation. As an example see WebRTC Peer. For the full list of Jellyfish Docker images, see this page. tip Instead of passing environmental variables manually, you can use the --env-file ./env-file flag, where the env-file is a file containing the variables that the image expects, see example file .env.sample in the Jellyfish repository. "},{"title":"Environment variables​","type":1,"pageTitle":"Installation","url":"/jellyfish-docs/next/getting_started/installation#environment-variables","content":"Environment variables are split into two groups: general ones - presented belowpeer/component-specific - each Peer and Component can expose its own environment variables. They are always listed in a Peer/Component description. See the list of Peers and Components. Below there are general, Jellyfish environment variables. If you are running Jellyfish in development, you don't need to set any of them. Required in production:​ JF_SERVER_API_TOKEN - token for authorizing HTTP requests. Defaults to development for development builds.JF_HOST - defines how Jellyfish should be seen from the outside. Defaults to JF_IP:JF_PORT. It can be in the form of ip:port, domain:port or simply domain. Useful when hosting Jellyfish behind proxy. It is returned e.g. when creating a new room. When running with Docker, JF_IP is set to 0.0.0.0making the default value of JF_HOST incorrect. Therefore, for Docker, you have to set JF_HOST manually. For running Docker locally, it can simply be localhost:8080. Optional:​ JF_IP - an ip address to run the HTTP server on. Defaults to 127.0.0.1 when running from source or using mix release, or 0.0.0.0 for Docker.JF_PORT - port to run the HTTP server on. Defaults to 5002 for development builds and 8080 for production builds (mix release or Docker).JF_SECRET_KEY_BASE - used to sign/encrypt tokens generated for Peers. Generated if not provided.JF_CHECK_ORIGIN - defines if Jellyfish will check origin of incoming requests and socket connection. Defaults to true. Can be true or false.JF_OUTPUT_BASE_PATH - a base path where Jellyfish will save its artifacts. Defaults to ./jellyfish_output/. When running via docker, the directory can be mounted as -v $(pwd)/host_directory:/app/jellyfish_output.JF_METRICS_IP - an IP address to run metrics endpoint on. Defaults to 127.0.0.1 when running from source or using mix release, or 0.0.0.0 for Docker.JF_METRICS_PORT - a port to run metrics endpoint on. Defaults to 9568.MIX_ENV - defines compilation environment. This variable takes effect only when running from the source. Docker images are always built with MIX_ENV=prod. Possible values are: dev - uses default values for environment variables (default option when running with mix phx.server)prod - requires that you provide values for environment variablestest - used in tests Distribution:​ JF_DIST_ENABLED - whether to run Jellyfish in a cluster. Defaults to false.JF_DIST_NODE_NAME - Node name used in a cluster. It consists of two parts - nodename@hostname. The first part identifies a node on a single machine and can be any string. The second part identifies the host machine and has to be an ip address or FQDN of a machine Jellyfish runs on. If you run a cluster on a single machine or in the same docker network and you don't want to use IP addresses or FQDN as hostnames, you can use short names (see JF_DIST_MODE).JF_DIST_MODE - distribution mode - can be name or sname. Defaults to name. When using name, your hostname has to be an IP address or FQDN of a machine Jellyfish runs on. When using sname, your hostname can be any string. See our docker-compose.yaml, which we use in our integration tests for an example.JF_DIST_COOKIE - used to group Jellyfishes in a cluster. Defaults to jellyfish_cookie. Use different cookies to create multiple clusters on the same machine. Important: cookie does not provide any cryptographic security. Its only purpose is to prevent a node from connecting to a cluster with which it is not intended to communicate.JF_DIST_NODES - space-separated list of other Jellyfishes to connect to. Defaults to &quot;&quot;. Example: JF_DIST_NODES=&quot;jellyfish1@127.0.0.1 jellyfish2@127.0.0.1&quot;. This list can also include ourselves so that you can pass the same value to every Jellyfish. Note: Jellyfish connection to other Jellyfish is transitive meaning that when you connect to one Jellyfish you also connect to all other Jellyfishes this one was connected to.JF_DIST_MIN_PORT- minimal port used by Jellyfish when forming a cluster (connecting to other Jellyfishes). Defaults to 9000 when running with Docker. Only available when running with Docker or mix release.JF_DIST_MAX_PORT- maximal port used by Jellyfish when forming a cluster (connecting to other Jellyfishes). Defaults to 9000 when running with Docker. Only available when running with Docker or mix release. tip You can use a single port to form a cluster, even if a cluster consists of more than two Jellyfishes. caution Besides ports specified using JF_DIST_MIN_PORT and JF_DIST_MAX_PORT, Jellyfish also uses one more service called EPMD that runs on port 4369. This port has to be explicitly exported when running with Docker. Read more in the Cluster section. "},{"title":"Metrics","type":0,"sectionRef":"#","url":"/jellyfish-docs/next/getting_started/metrics","content":"Metrics Jellyfish exports several metrics in the Prometheus format. By default, they are available on port 9568 at /metrics. See JF_METRICS_IP and JF_METRICS_PORT for configuration options. Name\tLabels\tDescriptionjellyfish_traffic_ingress_total_bytes Total traffic received jellyfish_traffic_ingress_throughput_bytes_per_second Current throughput for received traffic jellyfish_traffic_egress_total_bytes Total traffic sent jellyfish_traffic_egress_throughput_bytes_per_second Current throughput for sent traffic jellyfish_rooms Amount of rooms currently present in Jellyfish jellyfish_room_peers\troom_id\tAmount of peers currently present in a given room jellyfish_room_peer_time_total_seconds\troom_id\tTotal peer time accumulated for a given room vm_memory_total_bytes Total memory used by Erlang Virtual Machine vm_total_run_queue_lengths_total Number of Erlang processes waiting to be executed vm_total_run_queue_lengths_cpu Number of Erlang processes waiting to be executed on CPU schedulers vm_total_run_queue_lengths_io Number of Erlang processes waiting to be executed on IO schedulers","keywords":""},{"title":"Notifications","type":0,"sectionRef":"#","url":"/jellyfish-docs/next/getting_started/notifications","content":"Notifications Jellyfish sends server side notifications whenever some important event occurs, e.g.: a room has been createdsome peer has connectedcomponent has crashedetc. A full list of available notifications is always present in specific server SDK documentation. Here, we present how you can subscribe for server side notifications using Elixir Server SDK: server_address = &quot;localhost:5002&quot; server_api_token = &quot;development&quot; {:ok, notifier} = Jellyfish.Notifier.start(server_address: server_address, server_api_token: server_api_token) :ok = Jellyfish.Notifier.subscribe_server_notifications(notifier) :ok = Jellyfish.Notifier.subscribe_metrics(notifier) As a result, you should see the following logs on the server side 07:45:02.684 [info] New incoming server WebSocket connection, accepting 07:45:02.688 [info] Server WS authenticated. ","keywords":""},{"title":"WebRTC","type":0,"sectionRef":"#","url":"/jellyfish-docs/next/getting_started/peers/webrtc","content":"","keywords":""},{"title":"Compatibility​","type":1,"pageTitle":"WebRTC","url":"/jellyfish-docs/next/getting_started/peers/webrtc#compatibility","content":"HLSRTSP "},{"title":"Configuration options​","type":1,"pageTitle":"WebRTC","url":"/jellyfish-docs/next/getting_started/peers/webrtc#configuration-options","content":"Optional enableSimulcast (boolean, default: true) - Enables the peer to use simulcast "},{"title":"Env variables​","type":1,"pageTitle":"WebRTC","url":"/jellyfish-docs/next/getting_started/peers/webrtc#env-variables","content":"JF_WEBRTC_USED - has to be true if WebRTC peers will be usedJF_WEBRTC_TURN_LISTEN_IP - the IP address on which TURN servers will listen. By default set to 127.0.0.1. When running Jellyfish via Docker, this MUST be set to 0.0.0.0, even for local tests.JF_WEBRTC_TURN_IP - the IP address, under which TURN will present itself to the clients. By default set to 127.0.0.1. When running Jellyfish via Docker, this MUST be set to real (non-loopback) address, even for local tests.JF_WEBRTC_TURN_PORT_RANGE - port range, where UDP TURN will try to open ports. By default set to 50000-59999. The bigger the range is, the more users server will be able to handle. Useful when not using the --network=host option to limit the UDP ports used only to ones published from a Docker container.JF_WEBRTC_TURN_TCP_PORT - port number of TCP TURN "},{"title":"Example Docker commands​","type":1,"pageTitle":"WebRTC","url":"/jellyfish-docs/next/getting_started/peers/webrtc#example-docker-commands","content":"Explicit port exposure (macOS compatible) docker run -p 50000-50050:50000-50050/udp \\ -p 8080:8080/tcp \\ -e JF_SERVER_API_TOKEN=token \\ -e JF_HOST=localhost:8080 \\ -e JF_WEBRTC_USED=true \\ -e JF_WEBRTC_TURN_PORT_RANGE=50000-50050 \\ -e JF_WEBRTC_TURN_IP=192.168.0.1 \\ -e JF_WEBRTC_TURN_LISTEN_IP=0.0.0.0 \\ ghcr.io/jellyfish-dev/jellyfish:0.2.0  caution Make sure that the exposed UDP ports match JF_WEBRTC_TURN_PORT_RANGE. The range of the ports shouldn't be too wide as it might cause problems with container startup. Using host network (Linux only) docker run --network=host \\ -e JF_SERVER_API_TOKEN=token \\ -e JF_HOST=localhost:8080 \\ -e JF_WEBRTC_USED=true \\ -e JF_WEBRTC_TURN_IP=192.168.0.1 \\ -e JF_WEBRTC_TURN_LISTEN_IP=0.0.0.0 \\ ghcr.io/jellyfish-dev/jellyfish:0.2.0  "},{"title":"SDKs","type":0,"sectionRef":"#","url":"/jellyfish-docs/next/getting_started/sdks","content":"","keywords":""},{"title":"Server SDKs​","type":1,"pageTitle":"SDKs","url":"/jellyfish-docs/next/getting_started/sdks#server-sdks","content":"SDK\tResourcesElixir\tCode examples RTSP to HLS conversion Python\t "},{"title":"Client SDKs​","type":1,"pageTitle":"SDKs","url":"/jellyfish-docs/next/getting_started/sdks#client-sdks","content":"SDK\tResourcesReact\tReact Minimal Working Example Guide Jellyfish Videoroom Code examples TypeScript\tCode examples IOS\tCode example Android\tCode example React Native\tCode example "},{"title":"Basic Concepts","type":0,"sectionRef":"#","url":"/jellyfish-docs/next/introduction/basic_concepts","content":"","keywords":""},{"title":"Room​","type":1,"pageTitle":"Basic Concepts","url":"/jellyfish-docs/next/introduction/basic_concepts#room","content":"In Jellyfish, a room serves as a holder for peers and components, its function varying based on application. For instance, within a video conferencing system, a Jellyfish room represents a single online meeting or a channel accommodating multiple users for conversation. On the other hand, in a broadcasting system setting, one room will be a container for two components - one responsible for receiving stream from a streaming host (e.g. via RTMP) and the other one responsible for converting this stream into an HLS playlist ready to be broadcasted via CDN. "},{"title":"Component​","type":1,"pageTitle":"Basic Concepts","url":"/jellyfish-docs/next/introduction/basic_concepts#component","content":"A component is a server-side process that publishes or subscribes to tracks. Example components are: HLS component - subscribes to all other tracks and creates from them an HLS playlist ready to be broadcasted via CDNRTSP component - connects to the remote media source (e.g. an IP camera) and publishes its media to be consumed by other components or peers "},{"title":"Peer​","type":1,"pageTitle":"Basic Concepts","url":"/jellyfish-docs/next/introduction/basic_concepts#peer","content":"A peer is a client-side entity that connects to the server to publish, subscribe or publish and subscribe to tracks published by components or other peers. The peer's process is spawned after the peer connects to the server. At the moment, there is only one type of peer - WebRTC. "},{"title":"Difference between Component and Peer​","type":1,"pageTitle":"Basic Concepts","url":"/jellyfish-docs/next/introduction/basic_concepts#difference-between-component-and-peer","content":"The most important difference between a component and a peer is that component is a purely server-side thing. It starts its work right after adding it to the server. On the other hand, a peer is something that has to connect to the server. Therefore, peers are allowed to open so-called signaling channels to the server. See also Example Scenarios. "},{"title":"Example Scenarios","type":0,"sectionRef":"#","url":"/jellyfish-docs/next/introduction/example_scenarios","content":"","keywords":""},{"title":"Real-time video conferencing system​","type":1,"pageTitle":"Example Scenarios","url":"/jellyfish-docs/next/introduction/example_scenarios#real-time-video-conferencing-system","content":"In this scenario, we want to create a simple video conferencing system where people can talk to each other in the real-time. Because of interactive and real-time requirements, the natural choice is to use the WebRTC standard. The final architecture would look like this:   "},{"title":"Broadcasting system with the real-time mixin​","type":1,"pageTitle":"Example Scenarios","url":"/jellyfish-docs/next/introduction/example_scenarios#broadcasting-system-with-the-real-time-mixin","content":"In this scenario, we want to create a broadcasting solution where the conversation between multiple people is broadcasted to the broader audience. Here, we choose WebRTC as a standard used for connecting people talking to each other in real-time and HLS for creating a playlist that can be then uploaded to CDN and broadcasted to the broader audience. As you can see, the whole system will automatically adapt to the number of participants talking in real-time. In particular, Jellyfish will handle a scenario with only one streamer out of the box.   "},{"title":"Displaying IP camera streams in a web browser​","type":1,"pageTitle":"Example Scenarios","url":"/jellyfish-docs/next/introduction/example_scenarios#displaying-ip-camera-streams-in-a-web-browser","content":"In this scenario, we have a set of IP cameras and we want to display their streams in a web browser. IP cameras very often use RTSP for streaming media but browsers don't ship with support for this protocol. Therefore, to display audio and video in a web browser, we have to use either WebRTC or HLS. Because, in this scenario, the delay is not the most crucial thing, we choose HLS. The most important thing here is that the RTSP component connects to the IP camera and then the camera starts streaming. It's not the camera that initializes the connection to the server. Therefore, the RTSP component is a purely server-side thing - once you add it, it should be able to work on its own.   "},{"title":"The Whats and Hows of Jellyfish Dashboard","type":0,"sectionRef":"#","url":"/jellyfish-docs/next/tutorials/dashboard","content":"","keywords":""},{"title":"What is Jellyfish Dashboard?​","type":1,"pageTitle":"The Whats and Hows of Jellyfish Dashboard","url":"/jellyfish-docs/next/tutorials/dashboard#what-is-jellyfish-dashboard","content":"Jellyfish Dashboard is a web application that allows you to manage your Jellyfish Media Server instance. It is a React application that uses the Jellyfish React Client APIfor adding and receiving tracks and Jellyfish Server APIfor adding peers, creating rooms etc. It was created to help Jellyfish developers in testing but was later extended and adapted as a tool for tutorials and demos. Here, we present a short introduction to the dashboard and its features. "},{"title":"How to start Jellyfish Dashboard?​","type":1,"pageTitle":"The Whats and Hows of Jellyfish Dashboard","url":"/jellyfish-docs/next/tutorials/dashboard#how-to-start-jellyfish-dashboard","content":"There are a couple of ways to start the dashboard: Up-to-date versionDocker containerOfficial repository The current version of the dashboard is ready to use and availablehere. Ensure that it is compatible with your Jellyfish server! Please note that this dashboard only supports secure connections (https/wss) or connections to localhost. Any insecure requests (http/ws) will be automatically blocked by the browser. "},{"title":"How to start Jellyfish Media Server?​","type":1,"pageTitle":"The Whats and Hows of Jellyfish Dashboard","url":"/jellyfish-docs/next/tutorials/dashboard#how-to-start-jellyfish-media-server","content":"For testing, we'll run the Jellyfish Media Server locally using Docker image: docker run -p 50000-50050:50000-50050/udp \\ -p 5002:5002/tcp \\ -e JF_CHECK_ORIGIN=false \\ -e JF_HOST=&lt;your ip address&gt;:5002 \\ -e JF_PORT=&quot;5002&quot; \\ -e JF_WEBRTC_USED=true \\ -e JF_WEBRTC_TURN_PORT_RANGE=50000-50050 \\ -e JF_WEBRTC_TURN_IP=&lt;your ip address&gt; \\ -e JF_WEBRTC_TURN_LISTEN_IP=0.0.0.0 \\ -e JF_SERVER_API_TOKEN=development \\ ghcr.io/jellyfish-dev/jellyfish:0.2.0  Make sure to set JF_WEBRTC_TURN_IP and JF_HOST to your local IP address. Without it, the mobile device won't be able to connect to the Jellyfish. tip To check your local IP you can use this handy command (Linux/macOS): ifconfig | grep &quot;inet &quot; | grep -Fv 127.0.0.1 | awk '{print $2}'  "},{"title":"How to use Jellyfish Dashboard?​","type":1,"pageTitle":"The Whats and Hows of Jellyfish Dashboard","url":"/jellyfish-docs/next/tutorials/dashboard#how-to-use-jellyfish-dashboard","content":"Since we have Dashboard and Jellyfish Media Server up and running, we can dive into the features. "},{"title":"Connecting to the server​","type":1,"pageTitle":"The Whats and Hows of Jellyfish Dashboard","url":"/jellyfish-docs/next/tutorials/dashboard#connecting-to-the-server","content":"We started the dashboard and the Jellyfish Media Server separately, so we need to connect them. Open the dashboard in your browser. Open the side menu and fill in the parameters:  Server token - a token necessary to authenticate the dashboard with the Jellyfish. For now, it's simply development, but it is meant to authenticate the dashboard to the Jellyfish, so the good practice is to use a token that is hard to guess.WS/WSS - whether to use a secure or insecure connection. , it's ws, but if the Jellyfish uses secure WebSocket, use wss.HTTP/HTTPS - whether to use a secure or insecure connection. By default, it's http, but if the Jellyfish uses secure HTTP, use https.Server URL - URL of the Jellyfish server. Here, localhost:5002 would be a local build, but it can be any URL that points to the Jellyfish.Socket Path - path to the WebSocket endpoint. The default value is /socket/peer/websocket. Click Connect to server. If everything is correct, a server will appear in the list of connected servers:  "},{"title":"Creating a room​","type":1,"pageTitle":"The Whats and Hows of Jellyfish Dashboard","url":"/jellyfish-docs/next/tutorials/dashboard#creating-a-room","content":"There are plenty of settings that You can adjust in a room:  h264 or vp8 - video codec used in the room. If you want to use HLS streaming, you need to use h264.Max Peers - maximum number of peers that can join to the room. When you select the settings, click the Add room button. If everything is correct, a room will appear in the list of rooms:  "},{"title":"Adding and connecting peers to the room​","type":1,"pageTitle":"The Whats and Hows of Jellyfish Dashboard","url":"/jellyfish-docs/next/tutorials/dashboard#adding-and-connecting-peers-to-the-room","content":"Using the Create peer button, you can create a peer that will be ready to connect to the room.  The peer has its ID and Token. The ID is used to identify the peer in the Jellyfish Server, and the Token is used to authenticate the peer with the Jellyfish Server. Dashboard has an option to copy both of those values to the clipboard. You can also create a QR code with the peer's Token to make connecting to Jellyfish with a mobile device easier.  To connect the peer to the room, you can either press the Connect button in the peer's row, or scan the QR code with your mobile app, and connect there. "},{"title":"Sending tracks​","type":1,"pageTitle":"The Whats and Hows of Jellyfish Dashboard","url":"/jellyfish-docs/next/tutorials/dashboard#sending-tracks","content":"When the peer connects to the room, you will see the track menu. It allows you to send tracks to the room.  You can select the audio or video track you want to create. Created tracks will be visible in the list below. You can select any track from the list and send it to the room. Apart from your camera/microphone, you can easily share your screen with its audio or pick one from a list of mock tracks that we prepared. You can also select the resolution of the video track or if you want, send the video as a simulcast stream. There is also an option to add custom metadata (in JSON format) to the track. The peer will send metadata with the track to the room. Each recipient will be able to see it. When you select the track, click the Add track button. If everything is correct, client will send the track to the room and other peers will be able to see and hear you. "},{"title":"Receiving tracks​","type":1,"pageTitle":"The Whats and Hows of Jellyfish Dashboard","url":"/jellyfish-docs/next/tutorials/dashboard#receiving-tracks","content":"When the peer connects to the room, it will automatically receive tracks from other peers. Congrats! The basic utils of the dashboard are now covered. Next, we will dive into useful features that will help you with testing. "},{"title":"A ton of information that the dashboard provides​","type":1,"pageTitle":"The Whats and Hows of Jellyfish Dashboard","url":"/jellyfish-docs/next/tutorials/dashboard#a-ton-of-information-that-the-dashboard-provides","content":""},{"title":"Server logs in console​","type":1,"pageTitle":"The Whats and Hows of Jellyfish Dashboard","url":"/jellyfish-docs/next/tutorials/dashboard#server-logs-in-console","content":"On the side menu, you can set up the dashboard to display React Client logs in the console. Logs are great for debugging purposes and provide insight into the various communications that occur between the dashboard and the Jellyfish Server. You can also register your event handlers in your Jellyfish-based projects, both in theReact Client SDK and theTS Client SDK. These logs can show you when particular events occur and provide data that you can use in your own handlers  "},{"title":"Server/Room/Client state​","type":1,"pageTitle":"The Whats and Hows of Jellyfish Dashboard","url":"/jellyfish-docs/next/tutorials/dashboard#serverroomclient-state","content":"Each server, room, and client has its state. You can see the state of each of them in the dashboard by clicking appropriate buttons.  "},{"title":"Server events​","type":1,"pageTitle":"The Whats and Hows of Jellyfish Dashboard","url":"/jellyfish-docs/next/tutorials/dashboard#server-events","content":"Apart from the state, you can also see the events that occur on the server. You can see them after clicking the Show Server Events button.  "},{"title":"HLS and RTSP streaming​","type":1,"pageTitle":"The Whats and Hows of Jellyfish Dashboard","url":"/jellyfish-docs/next/tutorials/dashboard#hls-and-rtsp-streaming","content":"The dashboard allows adding HLS and RTSP streams in the room. You can set up the streams and see them in the room. It will look like this:  "},{"title":"Loadbalancing in Dashboard​","type":1,"pageTitle":"The Whats and Hows of Jellyfish Dashboard","url":"/jellyfish-docs/next/tutorials/dashboard#loadbalancing-in-dashboard","content":"Jellyfish Server supports load balancing. This means you can run multiple instances of the server and use them simultaneously to distribute the load evenly among them. The dashboard reflects this feature. If you run multiple Jellyfish instances (which Docker Compose does by default), connect one server to the dashboard. When a server opens a room on a different instance, the Dashboard will automatically connect to it and display the room. When Jellyfish runs in a cluster, and the Dashboard requests a new room, it's created on the Jellyfish instance with the lowest load. Information about the specific Jellyfish instance that hosts the newly created room is returned in the HTTP response body. "},{"title":"Data collected by Jellyfish​","type":1,"pageTitle":"The Whats and Hows of Jellyfish Dashboard","url":"/jellyfish-docs/next/tutorials/dashboard#data-collected-by-jellyfish","content":"For each server, Jellyfish collects WebRTC statistics about the rooms, clients and streamed tracks. You can see them in the dashboard using the Internals button.  The button opens a new tab with the panel to connect to the WebSocket of the Jellyfish of choice. You can observe the data with the dynamically generated charts showing what flows through the Jellyfish.  "},{"title":"Summary​","type":1,"pageTitle":"The Whats and Hows of Jellyfish Dashboard","url":"/jellyfish-docs/next/tutorials/dashboard#summary","content":"Congrats on finishing the tutorial! You should now be able to use the dashboard to its full potential. But this was just the beginning. Jellyfish Client API is a powerful tool that allows you to create your own web or mobile multimedia application. Check out the other tutorials to learn more about the Jellyfish Client API and how to use it in your projects. You can also take a look at our fully featured Videoroom Demo example:  It's written in React Native, but it uses the same Jellyfish Client API as the dashboard, so you can learn a lot from it. "},{"title":"Rest API","type":0,"sectionRef":"#","url":"/jellyfish-docs/next/for_developers/api_reference/rest_api","content":"Rest API getSend fileroom getShow information about all roomspostCreates a roomdelDelete the roomgetShows information about the roompostCreates the component and adds it to the roomdelDelete the component from the roompostCreate peerdelDelete peer API docs by Redocly Jellyfish Media Server (0.2.0) Download OpenAPI specification:Download License: Apache 2.0 Send file Authorizations: authorization path Parameters room_id required string Room id filename required string Name of the file query Parameters _HLS_msn integer or null (HlsMsn) &gt;= 0 Example: _HLS_msn=10 Segment sequence number _HLS_part integer or null (HlsPart) &gt;= 0 Example: _HLS_part=10 Partial segment sequence number _HLS_skip string or null (HlsSkip) Value: &quot;YES&quot; Example: _HLS_skip=YES Is delta manifest requested header Parameters range string Byte range of partial segment Responses 200 File was found 404 File not found get/hls/{room_id}/{filename} https://raw.githubusercontent.com/hls/{room_id}/{filename} Response samples 200404 Content type application/json Copy &quot;string&quot; room Show information about all rooms Authorizations: authorization Responses 200 Success 401 Unauthorized get/room https://raw.githubusercontent.com/room Response samples 200401 Content type application/json Copy Expand all Collapse all { &quot;data&quot;: [ { &quot;components&quot;: [ { &quot;id&quot;: &quot;component-1&quot;, &quot;metadata&quot;: { &quot;lowLatency&quot;: true, &quot;playable&quot;: true }, &quot;type&quot;: &quot;hls&quot; } ], &quot;config&quot;: { &quot;maxPeers&quot;: 10, &quot;videoCodec&quot;: &quot;h264&quot; }, &quot;id&quot;: &quot;room-1&quot;, &quot;peers&quot;: [ { &quot;id&quot;: &quot;peer-1&quot;, &quot;status&quot;: &quot;disconnected&quot;, &quot;type&quot;: &quot;webrtc&quot; } ] } ] } Creates a room Authorizations: authorization Request Body schema: application/json Room configuration maxPeers integer or null &gt;= 1 Maximum amount of peers allowed into the room videoCodec string or null Enum: &quot;h264&quot; &quot;vp8&quot; Enforces video codec for each peer in the room Responses 201 Room successfully created 400 Invalid request structure 401 Unauthorized post/room https://raw.githubusercontent.com/room Request samples Payload Content type application/json Copy { &quot;maxPeers&quot;: 10, &quot;videoCodec&quot;: &quot;h264&quot; } Response samples 201400401 Content type application/json Copy Expand all Collapse all { &quot;data&quot;: { &quot;jellyfish_address&quot;: &quot;jellyfish1:5003&quot;, &quot;room&quot;: { &quot;components&quot;: [ { &quot;id&quot;: &quot;component-1&quot;, &quot;metadata&quot;: { &quot;lowLatency&quot;: true, &quot;playable&quot;: true }, &quot;type&quot;: &quot;hls&quot; } ], &quot;config&quot;: { &quot;maxPeers&quot;: 10, &quot;videoCodec&quot;: &quot;h264&quot; }, &quot;id&quot;: &quot;room-1&quot;, &quot;peers&quot;: [ { &quot;id&quot;: &quot;peer-1&quot;, &quot;status&quot;: &quot;disconnected&quot;, &quot;type&quot;: &quot;webrtc&quot; } ] } } } Delete the room Authorizations: authorization path Parameters room_id required string Room id Responses 204 Successfully deleted room 401 Unauthorized 404 Room doesn't exist delete/room/{room_id} https://raw.githubusercontent.com/room/{room_id} Response samples 401404 Content type application/json Copy { &quot;errors&quot;: &quot;Token has expired&quot; } Shows information about the room Authorizations: authorization path Parameters room_id required string Room ID Responses 200 Success 401 Unauthorized 404 Room doesn't exist get/room/{room_id} https://raw.githubusercontent.com/room/{room_id} Response samples 200401404 Content type application/json Copy Expand all Collapse all { &quot;data&quot;: { &quot;components&quot;: [ { &quot;id&quot;: &quot;component-1&quot;, &quot;metadata&quot;: { &quot;lowLatency&quot;: true, &quot;playable&quot;: true }, &quot;type&quot;: &quot;hls&quot; } ], &quot;config&quot;: { &quot;maxPeers&quot;: 10, &quot;videoCodec&quot;: &quot;h264&quot; }, &quot;id&quot;: &quot;room-1&quot;, &quot;peers&quot;: [ { &quot;id&quot;: &quot;peer-1&quot;, &quot;status&quot;: &quot;disconnected&quot;, &quot;type&quot;: &quot;webrtc&quot; } ] } } Creates the component and adds it to the room Authorizations: authorization path Parameters room_id required string Room ID Request Body schema: application/json Component config options ComponentOptionsHLS (object) or ComponentOptionsRTSP (object) (ComponentOptions) Component-specific options type required string (ComponentType) Component type Responses 201 Successfully added component 400 Invalid request 401 Unauthorized 404 Room doesn't exist post/room/{room_id}/component https://raw.githubusercontent.com/room/{room_id}/component Request samples Payload Content type application/json Copy Expand all Collapse all { &quot;options&quot;: { &quot;lowLatency&quot;: false }, &quot;type&quot;: &quot;hls&quot; } Response samples 201400401404 Content type application/json Copy Expand all Collapse all { &quot;data&quot;: { &quot;id&quot;: &quot;component-1&quot;, &quot;metadata&quot;: { &quot;lowLatency&quot;: true, &quot;playable&quot;: true }, &quot;type&quot;: &quot;hls&quot; } } Delete the component from the room Authorizations: authorization path Parameters room_id required string Room ID id required string Component ID Responses 204 Successfully deleted 401 Unauthorized 404 Either component or the room doesn't exist delete/room/{room_id}/component/{id} https://raw.githubusercontent.com/room/{room_id}/component/{id} Response samples 401404 Content type application/json Copy { &quot;errors&quot;: &quot;Token has expired&quot; } Create peer Authorizations: authorization path Parameters room_id required string Room id Request Body schema: application/json Peer specification options required PeerOptionsWebRTC (object) (PeerOptions) Peer-specific options type required string (PeerType) Peer type Responses 201 Peer successfully created 400 Invalid request body structure 401 Unauthorized 404 Room doesn't exist 503 Peer limit has been reached post/room/{room_id}/peer https://raw.githubusercontent.com/room/{room_id}/peer Request samples Payload Content type application/json Copy Expand all Collapse all { &quot;options&quot;: { &quot;enableSimulcast&quot;: true }, &quot;type&quot;: &quot;webrtc&quot; } Response samples 201400401404503 Content type application/json Copy Expand all Collapse all { &quot;data&quot;: { &quot;peer&quot;: { &quot;id&quot;: &quot;peer-1&quot;, &quot;status&quot;: &quot;disconnected&quot;, &quot;type&quot;: &quot;webrtc&quot; }, &quot;token&quot;: &quot;5cdac726-57a3-4ecb-b1d5-72a3d62ec242&quot; } } Delete peer Authorizations: authorization path Parameters room_id required string Room ID id required string Peer id Responses 204 Peer successfully deleted 401 Unauthorized 404 Room ID or Peer ID references a resource that doesn't exist delete/room/{room_id}/peer/{id} https://raw.githubusercontent.com/room/{room_id}/peer/{id} Response samples 401404 Content type application/json Copy { &quot;errors&quot;: &quot;Token has expired&quot; }","keywords":""},{"title":"Cluster","type":0,"sectionRef":"#","url":"/jellyfish-docs/cluster","content":"","keywords":""},{"title":"Configuring a Cluster​","type":1,"pageTitle":"Cluster","url":"/jellyfish-docs/cluster#configuring-a-cluster","content":"Jellyfish cluster can be created in 4 simple steps: Enable distribution mode with JF_DIST_ENABLED=trueGive your node a name with JF_DIST_NODE_NAMESpecify a list of nodes to connect to with JF_DIST_NODESConfigure HTTP and metrics ports so they don't overlap with other nodes. You can do this with JF_PORT and JF_METRICS_PORT environment variables. Distribution Environment Variables List of all cluster-related environment variables is available here. Security Currently, Jellyfish distribution is not encrypted meaning that data between Jellyfishes is sent as plain text. Cookie does not provide any cryptographic security. Do run a cluster only across machines in the same network! Extra network Configuration Jellyfish leverages Erlang Distribution to form a cluster. This means that we don't need to use any database where we would store information about network topology. Instead, some extra network configuration might be needed. Jellyfish uses a service called EPMD (Erlang Port Mapper Deamon) that runs on port 4369 (TCP). If you run Jellyfish using Docker, you have to explicitly export this port. In production deployment, you also have to allow for traffic on this port in your firewall. EPMD is started automatically when running Jellyfish, so you don't need to take any extra steps to make it work. Jellyfish uses a random port for connecting to other Jellyfishes. If you run Jellyfish using Docker, this port defaults to 9000 (TCP) but you can configure the range it is selected from with JF_DIST_MIN_PORT and JF_DIST_MAX_PORT. Note that JF_DIST_MIN_PORT and JF_DIST_MAX_PORT are not available when running from source (using mix phx.server) as in development you don't have to worry about the port used for forming a cluster. As in the case of EPMD, in production deployment, you have to modify your firewall rules appropriately. See Deeper dive into Erlang Distribution for more information. "},{"title":"Examples​","type":1,"pageTitle":"Cluster","url":"/jellyfish-docs/cluster#examples","content":""},{"title":"Running from source​","type":1,"pageTitle":"Cluster","url":"/jellyfish-docs/cluster#running-from-source","content":"Run the first Jellyfish: JF_DIST_ENABLED=true JF_DIST_NODE_NAME=j1@127.0.0.1 mix phx.server  Run the second Jellyfish JF_DIST_ENABLED=true JF_DIST_NODE_NAME=j2@127.0.0.1 JF_DIST_NODES=&quot;j1@127.0.0.1&quot; JF_PORT=4002 JF_METRICS_PORT=9468 mix phx.server  info Note that when running the second Jellyfish, we had to change its HTTP and metrics ports. "},{"title":"Running with Docker (locally)​","type":1,"pageTitle":"Cluster","url":"/jellyfish-docs/cluster#running-with-docker-locally","content":"This simple docker compose file sets a cluster of two Jellyfishes. version: &quot;3&quot; x-jellyfish-template: &amp;jellyfish-template build: . environment: &amp;jellyfish-environment JF_SERVER_API_TOKEN: &quot;development&quot; JF_DIST_ENABLED: &quot;true&quot; JF_DIST_MODE: &quot;sname&quot; JF_DIST_NODES: &quot;j1@jellyfish1 j2@jellyfish2&quot; restart: on-failure services: jellyfish1: &lt;&lt;: *jellyfish-template environment: &lt;&lt;: *jellyfish-environment JF_HOST: &quot;localhost:5001&quot; JF_PORT: 5001 JF_METRICS_PORT: 6001 JF_DIST_NODE_NAME: j1@jellyfish1 ports: - 5001:5001 - 6001:6001 jellyfish2: &lt;&lt;: *jellyfish-template environment: &lt;&lt;: *jellyfish-environment JF_HOST: &quot;localhost:5002&quot; JF_PORT: 5002 JF_METRICS_PORT: 6002 JF_DIST_NODE_NAME: j2@jellyfish2 ports: - 5002:5002 - 6002:6002  Because we run Jellyfishes in the same Docker network: we can use JF_DIST_NODE: &quot;sname&quot;, which allows us to reference Jellyfishes using their service names sojellyfish1 and jellyfish2we don't need to export EPMD (4369) or distribution (9000) ports "},{"title":"Running with Docker (globally)​","type":1,"pageTitle":"Cluster","url":"/jellyfish-docs/cluster#running-with-docker-globally","content":"When forming a cluster across multiple machines: you have to take care of Extra Network Configurationyou also can't use JF_DIST_MODE=&quot;sname&quot; as you have to name Jellyfish nodes using their publicly available IP address or domain names (see JF_DIST_NODE_NAME and JF_DIST_MODE)you can't simulate this setup locally as you won't be able to expose two EMPD ports on the same machine. See Deeper dive into Erlang Distribution for more information. See our Jellyfish Videoroom deployment configuration for an example. "},{"title":"Verifying that a cluster has been created​","type":1,"pageTitle":"Cluster","url":"/jellyfish-docs/cluster#verifying-that-a-cluster-has-been-created","content":"When a cluster is created correctly you will see a log indicating that one of your Jellyfishes connected to the other one, e.g.: [info] [libcluster:epmd_cluster] connected to :&quot;j1@127.0.0.1&quot;  To see clustering in action, create two rooms using the same Jellyfish address and observe how they are load balanced: curl -X POST -H &quot;authorization: Bearer development&quot; http://localhost:4002/room # {&quot;data&quot;:{&quot;jellyfish_address&quot;:&quot;localhost:4001&quot;}}  curl -X POST -H &quot;authorization: Bearer development&quot; http://localhost:4002/room # {&quot;data&quot;:{&quot;jellyfish_address&quot;:&quot;localhost:4002&quot;}}  Load balancing can also be tested using Jellyfish Dashboard. See here for more information. "},{"title":"Deeper dive into Erlang Distribution​","type":1,"pageTitle":"Cluster","url":"/jellyfish-docs/cluster#deeper-dive-into-erlang-distribution","content":"The most tricky thing when running Jellyfish in a cluster is to understand the role of EPMD. EPMD is responsible for mapping node names to ports they use. Node names consist of two parts nodename@hostname.hostname identifies a host machine, and nodename identifies a node on this machine. When node A wants to connect to node B, it uses node's B name to ask EPMD (running on node B) for the actual port node B is accessible on. Example Let's assume that node's B name is nodeb@192.168.1.2.Node A will contact EPMD using 192.168.1.2 IP address and port 4369, and ask for the port number used by a node with the name nodeb.After that, node A can contact node B using 192.168.1.2 IP address and port returned by EPMD. A couple of notes about EPMD: it always uses port 4369 (TCP)it is started automatically when running Jellyfishthere is one EPMD per machine or one EPMD per docker container - that's why we can't simulate Global Docker setup locally You can read more about Erlang Distribution here. "},{"title":"Fly.io (experimental)","type":0,"sectionRef":"#","url":"/jellyfish-docs/deploying/fly_io","content":"","keywords":""},{"title":"Creating new app​","type":1,"pageTitle":"Fly.io (experimental)","url":"/jellyfish-docs/deploying/fly_io#creating-new-app","content":"Launch fly launch. When prompted, copy the configuration from the existing fly.toml file. Select appropriate app name and region, don't create any databases. Don't deploy the app just yet. Running fly launch may modify the Dockerfile. Make sure to remove the lines appended by flyctl. "},{"title":"Configuring the App​","type":1,"pageTitle":"Fly.io (experimental)","url":"/jellyfish-docs/deploying/fly_io#configuring-the-app","content":"Before deploying your app, make sure it is correctly configured. "},{"title":"Dedicated IPv4​","type":1,"pageTitle":"Fly.io (experimental)","url":"/jellyfish-docs/deploying/fly_io#dedicated-ipv4","content":"In order to transmit multimedia via UDP, the app has to be publicly available with an IPv4 address. By default Fly.io uses shared IP. To enable dedicated IPv4 address run fly ips allocate-v4  Note, that dedicated IP address is a paid feature on Fly.io. You can learn more about dedicated IPv4 address here. "},{"title":"fly.toml​","type":1,"pageTitle":"Fly.io (experimental)","url":"/jellyfish-docs/deploying/fly_io#flytoml","content":"Make sure you don't have the following lines in the fly.toml, which are automatically generated by fly launch. You don't need to run migrations, since you don't have a database. [deploy] release_command = &quot;/app/bin/migrate&quot;  Jellyfish uses JF_HOST variable instead of the default PHX_HOST. JF_HOST = &quot;&lt;YOUR APP HOSTNAME&gt;&quot;  Also, make sure you have set the correct port. The environment variable JF_PORT has to match the TCP internal_port defined under services section. The default for Jellyfish is 5002 in development and 8080 in production (when using Docker or mix release). To be able to receive and send UDP traffic, Jellyfish has to open its UDP ports on a special fly-global-services address, not 0.0.0.0. This must be set using the JF_WEBRTC_TURN_LISTEN_IP enviroment variable. You also need to specify the Jellyfish IP address for UDP, it is the IP address which you generated in the previous step. JF_WEBRTC_TURN_LISTEN_IP = &quot;fly-global-services&quot; JF_WEBRTC_TURN_IP=&quot;&lt;YOUR APP IP ADDRESS&gt;&quot;  You can also read tutorial for running Fly.io apps which use UDP. "},{"title":"Fly.io secrets​","type":1,"pageTitle":"Fly.io (experimental)","url":"/jellyfish-docs/deploying/fly_io#flyio-secrets","content":"There are environment variables, which you may not want to keep in the fly.toml config. Fly.io provides a way to store such values securely. For Jellyfish you need to configure just one secret - JF_SERVER_API_TOKEN. flyctl secrets set JF_SERVER_API_TOKEN=development  "},{"title":"Deploying​","type":1,"pageTitle":"Fly.io (experimental)","url":"/jellyfish-docs/deploying/fly_io#deploying","content":"With everything configured you can deploy the app fly deploy  Note that it may take a moment for the UDP traffic to be forwarded to the application. This means for example, that WebRTC may not be working yet. This is the tricky part of the deployment, which we weren't able to entirely figure out. Sometimes the UDP just works, others it takes ages for it to start flowing.This topic describes the exact issue we had with Fly.io. In general, it is unclear when the UDP traffic starts to be forwarded, sometimes it happens relatively quickly after deployment, sometimes you need to wait for some time. Also, the Fly.io documentation isn't clear in regard to opening UDP sockets. Some information was gathered experimentally, or based on Fly.io community questions, such as this one. "},{"title":"Simple React App","type":0,"sectionRef":"#","url":"/jellyfish-docs/next/tutorials/simple-react-app","content":"","keywords":""},{"title":"What you'll learn​","type":1,"pageTitle":"Simple React App","url":"/jellyfish-docs/next/tutorials/simple-react-app#what-youll-learn","content":"This tutorial will guide you through creating your first React project that uses the Jellyfish Client. By the end of the tutorial, you'll have a working web application that connects toJellyfish Media Server using WebRTC technology.  You can check out the finished project here "},{"title":"What do you need​","type":1,"pageTitle":"Simple React App","url":"/jellyfish-docs/next/tutorials/simple-react-app#what-do-you-need","content":"a little bit of experience in creating React appsIDE of your choice (for example Visual Studio Code)Node.js installed on your machine "},{"title":"Jellyfish architecture​","type":1,"pageTitle":"Simple React App","url":"/jellyfish-docs/next/tutorials/simple-react-app#jellyfish-architecture","content":"info You can learn more about Jellyfish architecture in Jellyfish docs. This section provides a brief description aimed at front-end developers Let's introduce some concepts first: Peer - A peer is a client-side entity that connects to the server to publish, subscribe or publish and subscribe to tracks published by components or other peers. You can think of it as a participant in a room. At the moment, there is only one type of peer - WebRTC.Track - An object that represents an audio or video stream. A track can be associated with a local media source, such as a camera or microphone, or a remote media source received from another user. Tracks are used to capture, transmit, and receive audio and video data in WebRTC applications.Room - In Jellyfish, a room serves as a holder for peers and components, its function varying based on application. From a front-end perspective, this will be probably one meeting or a broadcast. For a better understanding of these concepts here is an example of a room that holds a standard WebRTC conference from a perspective of the User:  In this example, peers stream multiple video and audio tracks. Peer #1 streams even two video tracks (camera and screencast track). You can differentiate between them by using track metadata. The user gets info about peers and their tracks from the server using Jellyfish Client. The user is also informed in real time about peers joining/leaving and tracks being added/removed. To keep this tutorial short we'll simplify things a little. Every peer will stream just one video track. "},{"title":"Connecting and joining the room​","type":1,"pageTitle":"Simple React App","url":"/jellyfish-docs/next/tutorials/simple-react-app#connecting-and-joining-the-room","content":"The general flow of connecting to the server and joining the room in a standard WebRTC conference setup looks like this:  The parts that you need to implement are marked in blue and things handled by Jellyfish are marked in red. Firstly, the user logs in. Then your backend authenticates the user and obtains a peer token. It allows the user to authenticate and join the room in Jellyfish Server. The backend passes the token to your front-end, and your front-end passes it to Jellyfish Client. The client establishes the connection with Jellyfish Server. Then Jellyfish Client sets up tracks (camera, microphone) to stream and joins the room on Jellyfish Server. Finally, your front-end can display the room for the user. For this tutorial we simplified this process a bit - you don't have to implement a backend or authentication. Jellyfish Dashboard will do this for you. It's also a nice tool to test and play around with Jellyfish. The flow with Jellyfish The dashboard looks like this:  You can see that the only things you need to implement are interactions with the user and Jellyfish Client. This tutorial will show you how to do it. "},{"title":"Setup​","type":1,"pageTitle":"Simple React App","url":"/jellyfish-docs/next/tutorials/simple-react-app#setup","content":""},{"title":"Create React + Vite project​","type":1,"pageTitle":"Simple React App","url":"/jellyfish-docs/next/tutorials/simple-react-app#create-react--vite-project","content":"Firstly create a brand new project. npm create vite@latest my-react-app -- --template react-ts  "},{"title":"Add dependencies​","type":1,"pageTitle":"Simple React App","url":"/jellyfish-docs/next/tutorials/simple-react-app#add-dependencies","content":"For this module to work you'll need to add our `react-client-sdk` package. This is necessary to create and connect Jellyfish Client. npm install https://github.com/jellyfish-dev/react-client-sdk#0.1.2  "},{"title":"Start the Jellyfish backend​","type":1,"pageTitle":"Simple React App","url":"/jellyfish-docs/next/tutorials/simple-react-app#start-the-jellyfish-backend","content":"For testing, we'll run the Jellyfish Media Server locally using Docker image: docker run -p 50000-50050:50000-50050/udp \\ -p 5002:5002/tcp \\ -e JF_CHECK_ORIGIN=false \\ -e JF_HOST=&lt;your ip address&gt;:5002 \\ -e JF_PORT=&quot;5002&quot; \\ -e JF_WEBRTC_USED=true \\ -e JF_WEBRTC_TURN_PORT_RANGE=50000-50050 \\ -e JF_WEBRTC_TURN_IP=&lt;your ip address&gt; \\ -e JF_WEBRTC_TURN_LISTEN_IP=0.0.0.0 \\ -e JF_SERVER_API_TOKEN=development \\ ghcr.io/jellyfish-dev/jellyfish:0.2.0  Make sure to set JF_WEBRTC_TURN_IP and JF_HOST to your local IP address. Without it, the mobile device won't be able to connect to the Jellyfish. tip To check your local IP you can use this handy command (Linux/macOS): ifconfig | grep &quot;inet &quot; | grep -Fv 127.0.0.1 | awk '{print $2}'  "},{"title":"Start the dashboard web front-end​","type":1,"pageTitle":"Simple React App","url":"/jellyfish-docs/next/tutorials/simple-react-app#start-the-dashboard-web-front-end","content":"There are a couple of ways to start the dashboard: Up-to-date versionDocker containerOfficial repository The current version of the dashboard is ready to use and availablehere. Ensure that it is compatible with your Jellyfish server! Please note that this dashboard only supports secure connections (https/wss) or connections to localhost. Any insecure requests (http/ws) will be automatically blocked by the browser. "},{"title":"(Optional) Add a bit of CSS styling​","type":1,"pageTitle":"Simple React App","url":"/jellyfish-docs/next/tutorials/simple-react-app#optional-add-a-bit-of-css-styling","content":"For this project, we prepared simple CSS classes, You are free to use it or create your own. "},{"title":"General project structure​","type":1,"pageTitle":"Simple React App","url":"/jellyfish-docs/next/tutorials/simple-react-app#general-project-structure","content":"Our app will consist of two parts: a component that will connect to the server and join the room a component that will display the video tracks from other participants "},{"title":"First step - prepare all the hooks and the context​","type":1,"pageTitle":"Simple React App","url":"/jellyfish-docs/next/tutorials/simple-react-app#first-step---prepare-all-the-hooks-and-the-context","content":"To connect to the Jellyfish backend, we need to create a Membrane Client instance. We can do it by using the create function from the@jellyfish-dev/react-client-sdk package. It needs two generic parameters: PeerMetadata - the type of metadata that will be sent to the server when connecting to the room (for example, user name) it has to be serializable TrackMetadata - the type of the metadata that will be sent to the server when sending a track (for example, track name) it has to be serializable as well App.tsx import React from &quot;react&quot;; import { create } from &quot;@jellyfish-dev/react-client-sdk&quot;; // Example metadata types for peer and track // You can define your metadata types just make sure they are serializable type PeerMetadata = { name: string; }; type TrackMetadata = { type: &quot;camera&quot; | &quot;screen&quot;; }; // Create a Jellyfish client instance // Since we will use this context outside of the component we need to export it export const { JellyfishContextProvider, // Context provider } = create&lt;PeerMetadata, TrackMetadata&gt;(); export const App = () =&gt; {};  "},{"title":"Now we need to wrap our app with the context provider​","type":1,"pageTitle":"Simple React App","url":"/jellyfish-docs/next/tutorials/simple-react-app#now-we-need-to-wrap-our-app-with-the-context-provider","content":"That's all we will need to do in this file. Simply import the JellyfishContextProvider along with the Appcomponent and wrap the App component with the JellyfishContextProvider: main.tsx import React from &quot;react&quot;; import ReactDOM from &quot;react-dom/client&quot;; import { App, JellyfishContextProvider } from &quot;./components/App&quot;; ReactDOM.createRoot(document.getElementById(&quot;root&quot;) as HTMLElement).render( &lt;React.StrictMode&gt; &lt;JellyfishContextProvider&gt; &lt;App /&gt; &lt;/JellyfishContextProvider&gt; &lt;/React.StrictMode&gt; );  "},{"title":"UI component that will connect to the server and join the room​","type":1,"pageTitle":"Simple React App","url":"/jellyfish-docs/next/tutorials/simple-react-app#ui-component-that-will-connect-to-the-server-and-join-the-room","content":"The UI of the component will be quite simple. It will consist of a simple text input field that will allow us to enter the peer token and a button that will connect to the server and join the room. We can also display the status of the connection. App.tsx import React, { useState } from &quot;react&quot;; //... export const App = () =&gt; { // Create a state to store the peer token const [token, setToken] = useState(&quot;&quot;); return ( &lt;div style={{ display: &quot;flex&quot;, flexDirection: &quot;column&quot;, gap: &quot;8px&quot; }}&gt; &lt;input value={token} onChange={(e) =&gt; setToken(() =&gt; e?.target?.value)} placeholder=&quot;token&quot; /&gt; &lt;div style={{ display: &quot;flex&quot;, flexDirection: &quot;row&quot;, gap: &quot;8px&quot; }}&gt; &lt;button disabled={} onClick={() =&gt; {}}; &gt; Connect &lt;/button&gt; &lt;button disabled={} onClick={() =&gt; {}}; &gt; Disconnect &lt;/button&gt; &lt;span&gt;Status: {}&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; ); };  "},{"title":"Once the UI is ready, we need to implement the logic​","type":1,"pageTitle":"Simple React App","url":"/jellyfish-docs/next/tutorials/simple-react-app#once-the-ui-is-ready-we-need-to-implement-the-logic","content":"App.tsx import { SignalingUrl } from &quot;@jellyfish-dev/react-client-sdk/.&quot;; //... export const { useStatus, // Hook to check the status of the connection useConnect, // Hook to connect to the server useDisconnect, // Hook to disconnect from the server JellyfishContextProvider, // Context provider }; export const App = () =&gt; { // Create a state to store the peer token const [token, setToken] = useState(&quot;&quot;); // Use the built-in hook to check the status of the connection const status = useStatus(); const connect = useConnect(); const disconnect = useDisconnect(); return ( &lt;div style={{ display: &quot;flex&quot;, flexDirection: &quot;column&quot;, gap: &quot;8px&quot; }}&gt; &lt;input className=&quot;input-field&quot; value={token} onChange={(e) =&gt; setToken(() =&gt; e?.target?.value)} placeholder=&quot;token&quot; /&gt; &lt;div style={{ display: &quot;flex&quot;, flexDirection: &quot;row&quot;, gap: &quot;8px&quot; }}&gt; &lt;button className=&quot;button&quot; disabled={token === &quot;&quot; || status === &quot;joined&quot;} // simple check to avoid errors onClick={() =&gt; { connect({ peerMetadata: { name: &quot;John Doe&quot; }, // example metadata token: token, }); }} &gt; Connect &lt;/button&gt; &lt;button className=&quot;button&quot; disabled={status !== &quot;joined&quot;} onClick={() =&gt; { disconnect(); }} &gt; Disconnect &lt;/button&gt; &lt;span className=&quot;span-status&quot;&gt;Status: {status}&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; ); };  Great! Now we can connect to the server and join the room. But we still need to add some logic to send our tracks to the server and receive tracks from others. "},{"title":"Let's send our screen to the server​","type":1,"pageTitle":"Simple React App","url":"/jellyfish-docs/next/tutorials/simple-react-app#lets-send-our-screen-to-the-server","content":"This hook uses Navigator.mediaDevices take a look how it works App.tsx import React, { useEffect, useState } from &quot;react&quot;; import { create, SCREEN_SHARING_MEDIA_CONSTRAINTS } from &quot;@jellyfish-dev/react-client-sdk&quot;; import { SignalingUrl, Peer } from &quot;@jellyfish-dev/react-client-sdk/.&quot;; //... export const { useStatus, // Hook to check the status of the connection useApi, // Hook to get the webrtcApi reference useConnect, // Hook to connect to the server useDisconnect, // Hook to disconnect from the server JellyfishContextProvider, // Context provider } = create&lt;PeerMetadata, TrackMetadata&gt;(); export const App = () =&gt; { //... // Get the webrtcApi reference const webrtcApi = useApi(); function startScreenSharing() { // Get screen sharing MediaStream navigator.mediaDevices.getDisplayMedia(SCREEN_SHARING_MEDIA_CONSTRAINTS).then((screenStream) =&gt; { // Add local MediaStream to webrtc screenStream.getTracks().forEach((track) =&gt; webrtcApi.addTrack(track, screenStream, { type: &quot;screen&quot; })); }; }; return ( //... &lt;button className=&quot;button&quot; disabled={status !== &quot;joined&quot;} onClick={() =&gt; { startScreenSharing(); }} &gt; Start screen share &lt;/button&gt; &lt;span&gt;Status: {status}&lt;/span&gt; //... ) };  You should now see your screen received for each connected client on the dashboard. You can add another participant to check this out! The streaming part of the app is ready! "},{"title":"What about the receiving part?​","type":1,"pageTitle":"Simple React App","url":"/jellyfish-docs/next/tutorials/simple-react-app#what-about-the-receiving-part","content":""},{"title":"This is where the second component comes in handy​","type":1,"pageTitle":"Simple React App","url":"/jellyfish-docs/next/tutorials/simple-react-app#this-is-where-the-second-component-comes-in-handy","content":"For each track received, we will create a new video element and display it on the screen. For clarity, we will separate this component into another file: Create in your directory file VideoPlayer.tsx VideoPlayer.tsx type Props = { stream: MediaStream | null | undefined; }; const VideoPlayer = ({ stream }: Props) =&gt; { return ( &lt;div className=&quot;video-container&quot;&gt; &lt;video autoPlay playsInline muted ref={/* place for track ref*/} /&gt; &lt;/div&gt; ); }; export default VideoPlayer;  "},{"title":"Now the logic for the component​","type":1,"pageTitle":"Simple React App","url":"/jellyfish-docs/next/tutorials/simple-react-app#now-the-logic-for-the-component","content":"VideoPlayer.tsx type Props = { stream: MediaStream | null | undefined; }; const VideoPlayer = ({ stream }: Props) =&gt; { const videoRef: RefObject&lt;HTMLVideoElement&gt; = useRef&lt;HTMLVideoElement&gt;(null); useEffect(() =&gt; { if (!videoRef.current) return; videoRef.current.srcObject = stream || null; }, [stream]); return ( &lt;div&gt; &lt;video autoPlay playsInline muted ref={videoRef} /&gt; &lt;/div&gt; ); }; export default VideoPlayer;  "},{"title":"Now we can use it in our main component​","type":1,"pageTitle":"Simple React App","url":"/jellyfish-docs/next/tutorials/simple-react-app#now-we-can-use-it-in-our-main-component","content":"App.tsx import React, { useEffect, useState } from &quot;react&quot;; import { create, SCREEN_SHARING_MEDIA_CONSTRAINTS } from &quot;@jellyfish-dev/react-client-sdk&quot;; import { SignalingUrl, Peer } from &quot;@jellyfish-dev/react-client-sdk/.&quot;; import VideoPlayer from &quot;./VideoPlayer&quot;; //... export const { useStatus, // Hook to check the status of the connection useTracks, // Hook to get the tracks from the server useApi, // Hook to get the webrtcApi reference useConnect, // Hook to connect to the server useDisconnect, // Hook to disconnect from the server JellyfishContextProvider, // Context provider } = create&lt;PeerMetadata, TrackMetadata&gt;(); export const App = () =&gt; { const tracks = useTracks(); //... &lt;div style={{ display: &quot;flex&quot;, flexWrap: &quot;wrap&quot;, justifyContent: &quot;center&quot;, // To align items in the center gap: &quot;20px&quot;, }} &gt; {Object.values(tracks).map(({ stream, trackId }) =&gt; ( &lt;VideoPlayer key={trackId} stream={stream} /&gt; // pass the stream to the component ))} &lt;/div&gt; //... )  You should see all the tracks sent from the dashboard directly on your page, to test them, add a new client, and add a track (for example a rotating frog). It will show up in your app automatically: "},{"title":"Summary​","type":1,"pageTitle":"Simple React App","url":"/jellyfish-docs/next/tutorials/simple-react-app#summary","content":"Congrats on finishing your first Jellyfish web application! In this tutorial, You've learned how to make a basic Jellyfish client application that streams your screen and receives video tracks with WebRTC technology. But this was just the beginning. Jellyfish Client supports much more than just streaming camera: It can also stream audio or your device's camera, configure your camera and audio devices, detect voice activity, control simulcast, bandwidth and encoding settings, show camera preview, display WebRTC stats and more to come. Check out our other tutorials to learn about those features. You can also take a look at our fully featured Videoroom Demo example:  "},{"title":"Examples","type":0,"sectionRef":"#","url":"/jellyfish-docs/examples","content":"Examples Jellyfish usage examples utilising server SDKs can be found in the following locations: Elixir","keywords":""},{"title":"API Reference","type":0,"sectionRef":"#","url":"/jellyfish-docs/for_developers/api_reference","content":"API Reference Jellyfish API is composed of three layers a REST API for managing Jellyfish statea WS connection for client SDK communication (socket path /socket/peer)a WS connection for server notifications (socket path /socket/server) You can find them here: OpenAPI REST descriptionProtobufs used by peer WSProtobufs used by server WS The communication via WebSockets uses Protobuf format. The very first message that has to be sent on either of the WebSocket connections (peer to Jellyfish oryour_backend_server to Jellyfish) is AuthRequest. All supported messages are listed in the Jellyfish protos repo. If you want to create your own Jellyfish SDK, the easiest way to reference defined protobuf messages will be by adding protos to your git repository as a git submodule. You can do it with this command: git submodule add https://github.com/jellyfish-dev/protos You could also consider creating a script that will pull the newest changes from the git submodule and compile.proto files to your chosen programming language. For reference, see the script used in our Elixir SDK.","keywords":""},{"title":"Cloud VPS with cloud-init","type":0,"sectionRef":"#","url":"/jellyfish-docs/deploying/vps","content":"","keywords":""},{"title":"1. Creating primary IP​","type":1,"pageTitle":"Cloud VPS with cloud-init","url":"/jellyfish-docs/deploying/vps#1-creating-primary-ip","content":"Because configuring a server with cloud-init using our script requires you to have a registered domain pointing at a particular IP address, we divided the process of creating VPS into two parts: obtaining dedicated IP addressconfiguring the server using cloud-init Let's start with the first one. In Hetzner's project site go to the section Primary IPs then click Create Primary IP button. Choose a data center location for your server and select IPv4 protocol. You can also name that IP if you'd like. "},{"title":"2. Registering Domain​","type":1,"pageTitle":"Cloud VPS with cloud-init","url":"/jellyfish-docs/deploying/vps#2-registering-domain","content":"We'll not suggest you to use a specific domain provider, maybe you've got one chosen so we'll describe this step without details that may be different among providers. If you'd like, you can use Hetzner as well to register a domain. After registering your domain go to the DNS Records Table of your provider and create an A record pointing to the IP you've created in the previous step. "},{"title":"3. Choosing the right VPS​","type":1,"pageTitle":"Cloud VPS with cloud-init","url":"/jellyfish-docs/deploying/vps#3-choosing-the-right-vps","content":"Now let's go back to the Hetzner project site. It's time to choose and configure a server for Jellyfish. Although Jellyfish doesn't have minimum requirements to work, we encourage you to choose a middle-sized VPS (at least 8 cores) as media processing is consuming quite a lot of CPU. Remember to choose a server located in the data center where you've created an IP address in the first step. For this tutorial, we decided on CPX21 from Hetzner Cloud running Ubuntu 22:  "},{"title":"4. Assigning Primary IP​","type":1,"pageTitle":"Cloud VPS with cloud-init","url":"/jellyfish-docs/deploying/vps#4-assigning-primary-ip","content":"Below the list of the VPS types there is a Networking section where your Primary IP from Step 1 is waiting to be used. Select it.  "},{"title":"5. Adding a cloud-init configuration​","type":1,"pageTitle":"Cloud VPS with cloud-init","url":"/jellyfish-docs/deploying/vps#5-adding-a-cloud-init-configuration","content":"To configure a server and install Jellyfish on it we're going to use cloud-init. It's a preinstalled tool that lets you set up a newly created server with a YAML config file. In the configuration you can create a user, choose packages to be installed, configure them, write or modify files and in our case finally run a docker container. Full documentation about keys you can use in a cloud-config file can be found in the official cloud-init documentation. "},{"title":"A cloud-config tempalte​","type":1,"pageTitle":"Cloud VPS with cloud-init","url":"/jellyfish-docs/deploying/vps#a-cloud-config-tempalte","content":"We prepared a template cloud-config that will configure your server and start a chosen version of Jellyfish: cloud-config.yaml #cloud-config users: - name: jellyfish groups: docker sudo: null shell: /bin/false no_create_home: true ssh_pwauth: false disable_root_opts: no-port-forwarding,no-agent-forwarding,no-X11-forwarding apt: sources: docker.list: source: &quot;deb [arch=amd64,arm64] https://download.docker.com/linux/ubuntu jammy stable&quot; keyid: 9DC858229FC7DD38854AE2D88D81803C0EBFCD88 packages: - ufw - fail2ban - gzip - containerd.io - docker-ce - docker-ce-cli - nginx - certbot write_files: - path: /opt/jellyfish/env-file defer: true owner: jellyfish:jellyfish runcmd: - export JELLYFISH_VERSION=0.2.0 - export JELLYFISH_DOMAIN=mydomain.example.com - export LETSENCRYPT_EMAIL=my@email.com - export SERVER_API_TOKEN=test_token - systemctl enable fail2ban - ufw default deny outgoing - ufw default deny incoming - ufw default deny routed - ufw allow in ssh - ufw allow out https - ufw allow out domain - ufw allow in 80/tcp - ufw allow in 443/tcp - ufw allow in 50000:500100/udp - ufw allow in 49999/tcp - ufw allow out 5002 - ufw allow out from any port 50000:50100 proto udp to any - ufw allow out 49999 proto tcp to any - ufw enable - service nginx stop - &quot;[ ! -f /etc/letsencrypt/live/$JELLYFISH_DOMAIN/cert.pem ] &amp;&amp; certbot certonly --standalone --noninteractive --agree-tos --email $LETSENCRYPT_EMAIL -d $JELLYFISH_DOMAIN&quot; - | cat &lt;&lt; EOF &gt; /etc/cron.d/cert_renew 0 4 * * * [jellyfish] certbot certonly --webroot -w /usr/share/nginx/html -d $JELLYFISH_DOMAIN --keep-until-expiring --quiet 5 4 * * * [jellyfish] service nginx reload EOF - | cat &lt;&lt; EOF &gt; /etc/nginx/sites-available/$JELLYFISH_DOMAIN server { server_name $JELLYFISH_DOMAIN; location / { proxy_pass http://localhost:5002; proxy_http_version 1.1; proxy_set_header Upgrade \\$http_upgrade; proxy_set_header Connection &quot;Upgrade&quot;; proxy_set_header Host \\$host; } listen [::]:443 ssl http2; # managed by Certbot listen 443 ssl http2; # managed by Certbot ssl_certificate /etc/letsencrypt/live/$JELLYFISH_DOMAIN/fullchain.pem; # managed by Certbot ssl_certificate_key /etc/letsencrypt/live/$JELLYFISH_DOMAIN/privkey.pem; # managed by Certbot } server { listen 80; listen [::]:80; server_name $JELLYFISH_DOMAIN; # Do not HTTPS redirect Let'sEncrypt ACME challenge location /.well-known/acme-challenge/ { auth_basic off; allow all; root /usr/share/nginx/html; try_files \\$uri =404; break; } location / { return 301 https://\\$host\\$request_uri; } } EOF - ln -sf /etc/nginx/sites-available/$JELLYFISH_DOMAIN /etc/nginx/sites-enabled/$JELLYFISH_DOMAIN - service nginx start - | cat &lt;&lt; EOF &gt; /opt/jellyfish/env-file JF_HOST=$JELLYFISH_DOMAIN JF_PORT=5002 JF_SERVER_API_TOKEN=$SERVER_API_TOKEN JF_CHECK_ORIGIN=false JF_WEBRTC_TURN_IP=$(ip route get 1.0.0.0 | sed -n 's/^.*src \\([0-9.]*\\) .*$/\\1/p') JF_WEBRTC_TURN_TCP_PORT=49999 JF_WEBRTC_TURN_PORT_RANGE=50000-50100 JF_WEBRTC_TURN_LISTEN_IP=0.0.0.0 EOF - [ su, jellyfish, -s, /bin/bash, -c, &quot;docker run -d \\ --restart unless-stopped \\ -p 50000-50100:50000-50100/udp \\ -p 5002:5002 \\ --env-file /opt/jellyfish/env-file \\ -v /opt/jellyfish/jellyfish_output:/app/jellyfish_output \\ ghcr.io/jellyfish-dev/jellyfish:$JELLYFISH_VERSION&quot;, ]  You'll need to manually take care of four lines in that template: - export JELLYFISH_VERSION=0.1.0-ed317bChange the value if you want to deploy a different version of Jellyfish. You can find the list of available versions in our package repository- export JELLYFISH_DOMAIN=mydomain.example.comEnter here a domain you've configured with A record in step 2.- export LETSENCRYPT_EMAIL=my@email.comEnter your email address to be notified when the SSL certificate will be about to expire.export SERVER_API_TOKEN=test_tokenServer API token is a token you'll need to connect to Jellyfish via API or SDK. Write here a chosen secret value you're going to remember later. Copy the file and change up those two variables. You're going to need the content of the file in the next section. "},{"title":"Other tools we'll install with cloud-init​","type":1,"pageTitle":"Cloud VPS with cloud-init","url":"/jellyfish-docs/deploying/vps#other-tools-well-install-with-cloud-init","content":"As you might noticed we've chosen some packages to be installed: ufw - Uncomplicated Firewall. We'll need it to allow or block traffic on specific ports https://help.ubuntu.com/community/UFW.fail2ban - Tool to block traffic recognized as unauthorized https://www.fail2ban.org/wiki/index.php/Main_Pagegzip - Compression Utility https://www.gzip.org/containerd.io, docker-ce, docker-ce-cli - Docker and Docker-related libraries. "},{"title":"Setting up Hetzner cloud VPS with cloud-config​","type":1,"pageTitle":"Cloud VPS with cloud-init","url":"/jellyfish-docs/deploying/vps#setting-up-hetzner-cloud-vps-with-cloud-config","content":"Now, we're going to use the content of the file you prepared in the Hetzner cloud VPS creating form. To do it scroll to the Cloud config section of the form and paste the content of your cloud-config.yaml file.  caution cloud-init will recognize the file as a configuration only if the file starts with that comment: #cloud-config ... So be careful while copying. That's it. You can click 'Create &amp; Buy' and the server will start to configure. tip Think about adding your public SSH key while creating a VPS instance. It will ease up connecting to VPS later. If you don't add any key you're going to need a root password (you'll receive it in an email after creating VPS) "},{"title":"6. Checking cloud-init status​","type":1,"pageTitle":"Cloud VPS with cloud-init","url":"/jellyfish-docs/deploying/vps#6-checking-cloud-init-status","content":"Configuring your server will take some time, but it's created almost immediately after creation. You can log into the server using ssh: ssh root@&lt;VPS_IP&gt;  then, in the server's terminal you can check the current status of cloud-init: cloud-init status  Possible responses are running, error and done. The first one informs you that cloud-init is still configuring your server. The second one means that something went wrong. You can find logs from the cloud-init run in /var/log/cloud-init-output.log file.done means that your jellyfish server is ready to be used. If you'd like to keep an eye on the cloud-init process you can use: cloud-init status --wait  To see the output when the process is finished (successfully or not). "},{"title":"Testing your instance with the Jellyfish dashboard​","type":1,"pageTitle":"Cloud VPS with cloud-init","url":"/jellyfish-docs/deploying/vps#testing-your-instance-with-the-jellyfish-dashboard","content":"To see how (or if) your Jellyfish server is working you can test it by connecting our Jellyfish Dashboard with your server. Detailed instructions on how to use Jellyfish Dashboard can be found here. "},{"title":"Design Docs","type":0,"sectionRef":"#","url":"/jellyfish-docs/for_developers/design_docs","content":"Design Docs Crucial parts of Jellyfish architecture are always discussed and written down in the form of design documents. Each design document describes, in a nutshell, a few possible solutions or approaches to some problem and states which solution was accepted and why. The list of Jellyfish Design Docs is available here.","keywords":""},{"title":"Architecture","type":0,"sectionRef":"#","url":"/jellyfish-docs/getting_started/architecture","content":"","keywords":""},{"title":"Server SDKs​","type":1,"pageTitle":"Architecture","url":"/jellyfish-docs/getting_started/architecture#server-sdks","content":"Server SDKs allow you to manage Jellyfish state. In particular, you can: authenticatecreate/delete roomsadd/remove peersadd/remove componentssubscribe for notifications Under the hood, Server SDKs just use Jellyfish REST and WS API, see Jellyfish API. tip As an example, you can use server SDK to introduce a time limit on meeting duration and shut down the room after it passes. "},{"title":"Client SDKs​","type":1,"pageTitle":"Architecture","url":"/jellyfish-docs/getting_started/architecture#client-sdks","content":"Client SDKs allow you to connect to Jellyfish to publish and consume tracks. In particular, you can: authenticatejoin specific roompublish audio and videoreceive audio and video from other peers and components At the moment, Jellyfish supports only one type of client - WebRTC. "},{"title":"Diagram​","type":1,"pageTitle":"Architecture","url":"/jellyfish-docs/getting_started/architecture#diagram","content":"The whole concept is presented in the following diagram.     Your Backend (BE) - serves your application frontend, and manages the database and application-specific logic. Jellyfish (JF) - Jellyfish media server. Manages media. Admin - someone who has special permission in your application - can create/delete rooms, add/remove peers, etc. User - someone who connects to Jellyfish to send and receive media. Everything starts with Admin who sends an HTTP request to BE to create a new room.BE uses jellyfish-server-sdk to communicate with JF and create the room. Under the hood, jellyfish-server-sdk uses REST API exposed by JF. After the room has been created, the Admin invites a user by sending a new HTTP request to BE. Again, BE uses jellyfish-server-sdk to add the new peer to JF. On the user side, they send a request to BE to join the room.BE replies with JF IP address it should connect to. Then, the User uses jellyfish-client-sdk to connect to JF. After the connection has been established, the User can send and receive media. "},{"title":"Authentication","type":0,"sectionRef":"#","url":"/jellyfish-docs/getting_started/authentication","content":"Authentication The Authentication mechanism is based on a bearer token. How does it work? Both Jellyfish and Business Logic are configured with the same secret. This secret is used for authorizing HTTP requests between them (via HTTP authorization request header). When a new client wants to join a room, Business Logic (assuming the client is authorized to join) requests adding a new peer and receives a token generated by Jellyfish. The token must then be passed to the client, that will use it to connect to the room as a new peer. The token encodes both peer and room IDs. The token exchange is handled by our Client SDKs when connecting. Under the hood, Jellyfish expects the token in the first message after opening the Web Socket connection. Token encodes peer id and room id. Run Jellyfish JF_SERVER_API_TOKEN=JF_SERVER_API_TOKEN mix phx.server Create a room and add one peer Business Logic client = Jellyfish.Client.new(&quot;http://address-of-your-server.com&quot;, &quot;JF_SERVER_API_TOKEN&quot;) {:ok, room, _jellyfish_address} = Jellyfish.Room.create(client, max_peers: 10) {:ok, peer, peer_token} = Jellyfish.Room.add_peer(client, room.id, &quot;BobId&quot;) Connect as a peer to Jellyfish Client client.connect({ token: peerToken, peerMetadata: { name: &quot;Bob&quot; }, isSimulcastOn: false }) ","keywords":""},{"title":"HLS","type":0,"sectionRef":"#","url":"/jellyfish-docs/getting_started/components/hls","content":"","keywords":""},{"title":"Compatibility​","type":1,"pageTitle":"HLS","url":"/jellyfish-docs/getting_started/components/hls#compatibility","content":"WebRTCRTSP "},{"title":"Requirements​","type":1,"pageTitle":"HLS","url":"/jellyfish-docs/getting_started/components/hls#requirements","content":"The Room in which the HLS component is created must have the video codec set to H264. See API for more information.Max 1 HLS component allowed per room. "},{"title":"Configuration options​","type":1,"pageTitle":"HLS","url":"/jellyfish-docs/getting_started/components/hls#configuration-options","content":"Optional lowLatency (boolean, default: false) - whether the component should use LL-HLS "},{"title":"Env variables​","type":1,"pageTitle":"HLS","url":"/jellyfish-docs/getting_started/components/hls#env-variables","content":"Currently, there are no environment variables related to this component. "},{"title":"Output​","type":1,"pageTitle":"HLS","url":"/jellyfish-docs/getting_started/components/hls#output","content":"After adding a WebRTC peer (and at least one track) or an RTSP component, the HLS stream will be available under http://&lt;jellyfish-address&gt;/hls/&lt;room_id&gt;/index.m3u8 (or https://, if using TLS). "},{"title":"Example Docker commands​","type":1,"pageTitle":"HLS","url":"/jellyfish-docs/getting_started/components/hls#example-docker-commands","content":"The HLS playlist will be created inside the Docker container. To access it from the host, you need to create a volume, e.g. by adding the option -v $(pwd)/jellyfish_output:/app/jellyfish_outputto your Docker command. Other than that, your Docker commands shouldn't be affected by adding this component. docker run -p 8080:8080/tcp \\ -e JF_SERVER_API_TOKEN=token \\ -e JF_HOST=localhost:8080 \\ -v $(pwd)/jellyfish_output:/app/jellyfish_output \\ ghcr.io/jellyfish-dev/jellyfish:0.2.0  "},{"title":"RTSP","type":0,"sectionRef":"#","url":"/jellyfish-docs/getting_started/components/rtsp","content":"","keywords":""},{"title":"Compatibility​","type":1,"pageTitle":"RTSP","url":"/jellyfish-docs/getting_started/components/rtsp#compatibility","content":"WebRTCHLS "},{"title":"Requirements​","type":1,"pageTitle":"RTSP","url":"/jellyfish-docs/getting_started/components/rtsp#requirements","content":"RTSP component always outputs H264 stream so if the Room in which the RTSP component is created enforces a video codec, it must be set to H264. See API for more information. "},{"title":"Configuration options​","type":1,"pageTitle":"RTSP","url":"/jellyfish-docs/getting_started/components/rtsp#configuration-options","content":"Required sourceUri (string) - URI of RTSP source stream, e.g. &quot;rtsp://mysite.net:554/stream&quot; Optional rtpPort (integer 1..65535, default: 20000) - Local port RTP stream will be received atreconnectDelay (integer 0.., default: 15000) - Delay (in ms) between successive reconnect attemptskeepAliveInterval (integer 0.., default: 15000) - Interval (in ms) in which keep-alive RTSP messages will be sent to the remote stream sourcepierceNat (boolean, default: true) - Whether to attempt to create client-side NAT binding by sending an empty datagram from client to source, after the completion of RTSP setup "},{"title":"Env variables​","type":1,"pageTitle":"RTSP","url":"/jellyfish-docs/getting_started/components/rtsp#env-variables","content":"Currently, there are no environment variables related to this component. "},{"title":"Example Docker commands​","type":1,"pageTitle":"RTSP","url":"/jellyfish-docs/getting_started/components/rtsp#example-docker-commands","content":"caution If the client is behind NAT, the option --network=host is necessary since Docker can change the source port of UDP packets for routing reasons, which breaks the pierceNat functionality. This means that users on macOS will most likely be unable to access any RTSP stream source outside of their network when running Jellyfish using Docker. If you're on macOS and want to receive RTSP streams from behind NAT, right now the only way is to build Jellyfish natively from source. Explicit port exposure (macOS compatible) docker run -p 20000:20000/udp \\ -p 8080:8080/tcp \\ -e JF_SERVER_API_TOKEN=token \\ -e JF_HOST=localhost:8080 \\ ghcr.io/jellyfish-dev/jellyfish:0.2.0  caution Make sure that the exposed UDP port matches the one used by the RTSP component (option rtpPort, default: 20000). If using multiple RTSP components, more ports will need to be exposed. Using host network (Linux only) docker run --network=host \\ -e JF_SERVER_API_TOKEN=token \\ -e JF_HOST=localhost:8080 \\ ghcr.io/jellyfish-dev/jellyfish:0.2.0  "},{"title":"Installation","type":0,"sectionRef":"#","url":"/jellyfish-docs/getting_started/installation","content":"","keywords":""},{"title":"Building from source​","type":1,"pageTitle":"Installation","url":"/jellyfish-docs/getting_started/installation#building-from-source","content":"Make sure to have both Elixir and Rust installed. Check the links below for instructions: ElixirRust Clone the Jellyfish repo git clone https://github.com/jellyfish-dev/jellyfish.git  Install native dependencies macOS IntelmacOS Apple SiliconUbuntu These instructions assume you have Homebrew installed. You can get it here. brew install srtp libnice clang-format ffmpeg opus pkg-config export LDFLAGS=&quot;-L/usr/local/opt/openssl@1.1/lib&quot; export CFLAGS=&quot;-I/usr/local/opt/openssl@1.1/include/&quot; export CPPFLAGS=&quot;-I/usr/local/opt/openssl@1.1/include/&quot; export PKG_CONFIG_PATH=&quot;/usr/local/opt/openssl@1.1/lib/pkgconfig&quot;  Install elixir dependencies mix deps.get  Run the server in development mix phx.server  Create a binary You can also create Jellyfish binary with: MIX_ENV=prod mix release  Then follow instructions printed in your terminal. info The difference between running with mix phx.server and generating target binary is that the latter is prepared for running in production so e.g. it includes some Erlang Virtual Machine tweaks. Jellyfish Dockerfile always uses mix release under the hood. "},{"title":"Running with Docker​","type":1,"pageTitle":"Installation","url":"/jellyfish-docs/getting_started/installation#running-with-docker","content":"Docker images are built for production which means that you always need to set a couple of environment variables. An example docker command running bare Jellyfish HTTP service locally: docker run -p 8080:8080/tcp -e JF_HOST=localhost:8080 JF_SERVER_API_TOKEN=token ghcr.io/jellyfish-dev/jellyfish:0.2.0  Note that in real case scenarios, docker commands depend on peers/components you are going to use. Therefore, we don't present them here but rather in each peer/component's documentation. As an example see WebRTC Peer. For the full list of Jellyfish Docker images, see this page. tip Instead of passing environmental variables manually, you can use the --env-file ./env-file flag, where the env-file is a file containing the variables that the image expects, see example file .env.sample in the Jellyfish repository. "},{"title":"Environment variables​","type":1,"pageTitle":"Installation","url":"/jellyfish-docs/getting_started/installation#environment-variables","content":"Environment variables are split into two groups: general ones - presented belowpeer/component-specific - each Peer and Component can expose its own environment variables. They are always listed in a Peer/Component description. See the list of Peers and Components. Below there are general, Jellyfish environment variables. If you are running Jellyfish in development, you don't need to set any of them. Required in production:​ JF_SERVER_API_TOKEN - token for authorizing HTTP requests. Defaults to development for development builds.JF_HOST - defines how Jellyfish should be seen from the outside. Defaults to JF_IP:JF_PORT. It can be in the form of ip:port, domain:port or simply domain. Useful when hosting Jellyfish behind proxy. It is returned e.g. when creating a new room. When running with Docker, JF_IP is set to 0.0.0.0making the default value of JF_HOST incorrect. Therefore, for Docker, you have to set JF_HOST manually. For running Docker locally, it can simply be localhost:8080. Optional:​ JF_IP - an ip address to run the HTTP server on. Defaults to 127.0.0.1 when running from source or using mix release, or 0.0.0.0 for Docker.JF_PORT - port to run the HTTP server on. Defaults to 5002 for development builds and 8080 for production builds (mix release or Docker).JF_SECRET_KEY_BASE - used to sign/encrypt tokens generated for Peers. Generated if not provided.JF_CHECK_ORIGIN - defines if Jellyfish will check origin of incoming requests and socket connection. Defaults to true. Can be true or false.JF_OUTPUT_BASE_PATH - a base path where Jellyfish will save its artifacts. Defaults to ./jellyfish_output/. When running via docker, the directory can be mounted as -v $(pwd)/host_directory:/app/jellyfish_output.JF_METRICS_IP - an IP address to run metrics endpoint on. Defaults to 127.0.0.1 when running from source or using mix release, or 0.0.0.0 for Docker.JF_METRICS_PORT - a port to run metrics endpoint on. Defaults to 9568.MIX_ENV - defines compilation environment. This variable takes effect only when running from the source. Docker images are always built with MIX_ENV=prod. Possible values are: dev - uses default values for environment variables (default option when running with mix phx.server)prod - requires that you provide values for environment variablestest - used in tests Distribution:​ JF_DIST_ENABLED - whether to run Jellyfish in a cluster. Defaults to false.JF_DIST_NODE_NAME - Node name used in a cluster. It consists of two parts - nodename@hostname. The first part identifies a node on a single machine and can be any string. The second part identifies the host machine and has to be an ip address or FQDN of a machine Jellyfish runs on. If you run a cluster on a single machine or in the same docker network and you don't want to use IP addresses or FQDN as hostnames, you can use short names (see JF_DIST_MODE).JF_DIST_MODE - distribution mode - can be name or sname. Defaults to name. When using name, your hostname has to be an IP address or FQDN of a machine Jellyfish runs on. When using sname, your hostname can be any string. See our docker-compose.yaml, which we use in our integration tests for an example.JF_DIST_COOKIE - used to group Jellyfishes in a cluster. Defaults to jellyfish_cookie. Use different cookies to create multiple clusters on the same machine. Important: cookie does not provide any cryptographic security. Its only purpose is to prevent a node from connecting to a cluster with which it is not intended to communicate.JF_DIST_NODES - space-separated list of other Jellyfishes to connect to. Defaults to &quot;&quot;. Example: JF_DIST_NODES=&quot;jellyfish1@127.0.0.1 jellyfish2@127.0.0.1&quot;. This list can also include ourselves so that you can pass the same value to every Jellyfish. Note: Jellyfish connection to other Jellyfish is transitive meaning that when you connect to one Jellyfish you also connect to all other Jellyfishes this one was connected to.JF_DIST_MIN_PORT- minimal port used by Jellyfish when forming a cluster (connecting to other Jellyfishes). Defaults to 9000 when running with Docker. Only available when running with Docker or mix release.JF_DIST_MAX_PORT- maximal port used by Jellyfish when forming a cluster (connecting to other Jellyfishes). Defaults to 9000 when running with Docker. Only available when running with Docker or mix release. tip You can use a single port to form a cluster, even if a cluster consists of more than two Jellyfishes. caution Besides ports specified using JF_DIST_MIN_PORT and JF_DIST_MAX_PORT, Jellyfish also uses one more service called EPMD that runs on port 4369. This port has to be explicitly exported when running with Docker. Read more in the Cluster section. "},{"title":"Metrics","type":0,"sectionRef":"#","url":"/jellyfish-docs/getting_started/metrics","content":"Metrics Jellyfish exports several metrics in the Prometheus format. By default, they are available on port 9568 at /metrics. See JF_METRICS_IP and JF_METRICS_PORT for configuration options. Name\tLabels\tDescriptionjellyfish_traffic_ingress_total_bytes Total traffic received jellyfish_traffic_ingress_throughput_bytes_per_second Current throughput for received traffic jellyfish_traffic_egress_total_bytes Total traffic sent jellyfish_traffic_egress_throughput_bytes_per_second Current throughput for sent traffic jellyfish_rooms Amount of rooms currently present in Jellyfish jellyfish_room_peers\troom_id\tAmount of peers currently present in a given room jellyfish_room_peer_time_total_seconds\troom_id\tTotal peer time accumulated for a given room vm_memory_total_bytes Total memory used by Erlang Virtual Machine vm_total_run_queue_lengths_total Number of Erlang processes waiting to be executed vm_total_run_queue_lengths_cpu Number of Erlang processes waiting to be executed on CPU schedulers vm_total_run_queue_lengths_io Number of Erlang processes waiting to be executed on IO schedulers","keywords":""},{"title":"Notifications","type":0,"sectionRef":"#","url":"/jellyfish-docs/getting_started/notifications","content":"Notifications Jellyfish sends server side notifications whenever some important event occurs, e.g.: a room has been createdsome peer has connectedcomponent has crashedetc. A full list of available notifications is always present in specific server SDK documentation. Here, we present how you can subscribe for server side notifications using Elixir Server SDK: server_address = &quot;localhost:5002&quot; server_api_token = &quot;development&quot; {:ok, notifier} = Jellyfish.Notifier.start(server_address: server_address, server_api_token: server_api_token) :ok = Jellyfish.Notifier.subscribe_server_notifications(notifier) :ok = Jellyfish.Notifier.subscribe_metrics(notifier) As a result, you should see the following logs on the server side 07:45:02.684 [info] New incoming server WebSocket connection, accepting 07:45:02.688 [info] Server WS authenticated. ","keywords":""},{"title":"Rest API","type":0,"sectionRef":"#","url":"/jellyfish-docs/for_developers/api_reference/rest_api","content":"Rest API getSend fileroom getShow information about all roomspostCreates a roomdelDelete the roomgetShows information about the roompostCreates the component and adds it to the roomdelDelete the component from the roompostCreate peerdelDelete peer API docs by Redocly Jellyfish Media Server (0.2.0) Download OpenAPI specification:Download License: Apache 2.0 Send file Authorizations: authorization path Parameters room_id required string Room id filename required string Name of the file query Parameters _HLS_msn integer or null (HlsMsn) &gt;= 0 Example: _HLS_msn=10 Segment sequence number _HLS_part integer or null (HlsPart) &gt;= 0 Example: _HLS_part=10 Partial segment sequence number _HLS_skip string or null (HlsSkip) Value: &quot;YES&quot; Example: _HLS_skip=YES Is delta manifest requested header Parameters range string Byte range of partial segment Responses 200 File was found 404 File not found get/hls/{room_id}/{filename} https://raw.githubusercontent.com/hls/{room_id}/{filename} Response samples 200404 Content type application/json Copy &quot;string&quot; room Show information about all rooms Authorizations: authorization Responses 200 Success 401 Unauthorized get/room https://raw.githubusercontent.com/room Response samples 200401 Content type application/json Copy Expand all Collapse all { &quot;data&quot;: [ { &quot;components&quot;: [ { &quot;id&quot;: &quot;component-1&quot;, &quot;metadata&quot;: { &quot;lowLatency&quot;: true, &quot;playable&quot;: true }, &quot;type&quot;: &quot;hls&quot; } ], &quot;config&quot;: { &quot;maxPeers&quot;: 10, &quot;videoCodec&quot;: &quot;h264&quot; }, &quot;id&quot;: &quot;room-1&quot;, &quot;peers&quot;: [ { &quot;id&quot;: &quot;peer-1&quot;, &quot;status&quot;: &quot;disconnected&quot;, &quot;type&quot;: &quot;webrtc&quot; } ] } ] } Creates a room Authorizations: authorization Request Body schema: application/json Room configuration maxPeers integer or null &gt;= 1 Maximum amount of peers allowed into the room videoCodec string or null Enum: &quot;h264&quot; &quot;vp8&quot; Enforces video codec for each peer in the room Responses 201 Room successfully created 400 Invalid request structure 401 Unauthorized post/room https://raw.githubusercontent.com/room Request samples Payload Content type application/json Copy { &quot;maxPeers&quot;: 10, &quot;videoCodec&quot;: &quot;h264&quot; } Response samples 201400401 Content type application/json Copy Expand all Collapse all { &quot;data&quot;: { &quot;jellyfish_address&quot;: &quot;jellyfish1:5003&quot;, &quot;room&quot;: { &quot;components&quot;: [ { &quot;id&quot;: &quot;component-1&quot;, &quot;metadata&quot;: { &quot;lowLatency&quot;: true, &quot;playable&quot;: true }, &quot;type&quot;: &quot;hls&quot; } ], &quot;config&quot;: { &quot;maxPeers&quot;: 10, &quot;videoCodec&quot;: &quot;h264&quot; }, &quot;id&quot;: &quot;room-1&quot;, &quot;peers&quot;: [ { &quot;id&quot;: &quot;peer-1&quot;, &quot;status&quot;: &quot;disconnected&quot;, &quot;type&quot;: &quot;webrtc&quot; } ] } } } Delete the room Authorizations: authorization path Parameters room_id required string Room id Responses 204 Successfully deleted room 401 Unauthorized 404 Room doesn't exist delete/room/{room_id} https://raw.githubusercontent.com/room/{room_id} Response samples 401404 Content type application/json Copy { &quot;errors&quot;: &quot;Token has expired&quot; } Shows information about the room Authorizations: authorization path Parameters room_id required string Room ID Responses 200 Success 401 Unauthorized 404 Room doesn't exist get/room/{room_id} https://raw.githubusercontent.com/room/{room_id} Response samples 200401404 Content type application/json Copy Expand all Collapse all { &quot;data&quot;: { &quot;components&quot;: [ { &quot;id&quot;: &quot;component-1&quot;, &quot;metadata&quot;: { &quot;lowLatency&quot;: true, &quot;playable&quot;: true }, &quot;type&quot;: &quot;hls&quot; } ], &quot;config&quot;: { &quot;maxPeers&quot;: 10, &quot;videoCodec&quot;: &quot;h264&quot; }, &quot;id&quot;: &quot;room-1&quot;, &quot;peers&quot;: [ { &quot;id&quot;: &quot;peer-1&quot;, &quot;status&quot;: &quot;disconnected&quot;, &quot;type&quot;: &quot;webrtc&quot; } ] } } Creates the component and adds it to the room Authorizations: authorization path Parameters room_id required string Room ID Request Body schema: application/json Component config options ComponentOptionsHLS (object) or ComponentOptionsRTSP (object) (ComponentOptions) Component-specific options type required string (ComponentType) Component type Responses 201 Successfully added component 400 Invalid request 401 Unauthorized 404 Room doesn't exist post/room/{room_id}/component https://raw.githubusercontent.com/room/{room_id}/component Request samples Payload Content type application/json Copy Expand all Collapse all { &quot;options&quot;: { &quot;lowLatency&quot;: false }, &quot;type&quot;: &quot;hls&quot; } Response samples 201400401404 Content type application/json Copy Expand all Collapse all { &quot;data&quot;: { &quot;id&quot;: &quot;component-1&quot;, &quot;metadata&quot;: { &quot;lowLatency&quot;: true, &quot;playable&quot;: true }, &quot;type&quot;: &quot;hls&quot; } } Delete the component from the room Authorizations: authorization path Parameters room_id required string Room ID id required string Component ID Responses 204 Successfully deleted 401 Unauthorized 404 Either component or the room doesn't exist delete/room/{room_id}/component/{id} https://raw.githubusercontent.com/room/{room_id}/component/{id} Response samples 401404 Content type application/json Copy { &quot;errors&quot;: &quot;Token has expired&quot; } Create peer Authorizations: authorization path Parameters room_id required string Room id Request Body schema: application/json Peer specification options required PeerOptionsWebRTC (object) (PeerOptions) Peer-specific options type required string (PeerType) Peer type Responses 201 Peer successfully created 400 Invalid request body structure 401 Unauthorized 404 Room doesn't exist 503 Peer limit has been reached post/room/{room_id}/peer https://raw.githubusercontent.com/room/{room_id}/peer Request samples Payload Content type application/json Copy Expand all Collapse all { &quot;options&quot;: { &quot;enableSimulcast&quot;: true }, &quot;type&quot;: &quot;webrtc&quot; } Response samples 201400401404503 Content type application/json Copy Expand all Collapse all { &quot;data&quot;: { &quot;peer&quot;: { &quot;id&quot;: &quot;peer-1&quot;, &quot;status&quot;: &quot;disconnected&quot;, &quot;type&quot;: &quot;webrtc&quot; }, &quot;token&quot;: &quot;5cdac726-57a3-4ecb-b1d5-72a3d62ec242&quot; } } Delete peer Authorizations: authorization path Parameters room_id required string Room ID id required string Peer id Responses 204 Peer successfully deleted 401 Unauthorized 404 Room ID or Peer ID references a resource that doesn't exist delete/room/{room_id}/peer/{id} https://raw.githubusercontent.com/room/{room_id}/peer/{id} Response samples 401404 Content type application/json Copy { &quot;errors&quot;: &quot;Token has expired&quot; }","keywords":""},{"title":"SDKs","type":0,"sectionRef":"#","url":"/jellyfish-docs/getting_started/sdks","content":"","keywords":""},{"title":"Server SDKs​","type":1,"pageTitle":"SDKs","url":"/jellyfish-docs/getting_started/sdks#server-sdks","content":"SDK\tResourcesElixir\tCode examples RTSP to HLS conversion Python\t "},{"title":"Client SDKs​","type":1,"pageTitle":"SDKs","url":"/jellyfish-docs/getting_started/sdks#client-sdks","content":"SDK\tResourcesReact\tReact Minimal Working Example Guide Jellyfish Videoroom Code examples TypeScript\tCode examples IOS\tCode example Android\tCode example React Native\tCode example "},{"title":"WebRTC","type":0,"sectionRef":"#","url":"/jellyfish-docs/getting_started/peers/webrtc","content":"","keywords":""},{"title":"Compatibility​","type":1,"pageTitle":"WebRTC","url":"/jellyfish-docs/getting_started/peers/webrtc#compatibility","content":"HLSRTSP "},{"title":"Configuration options​","type":1,"pageTitle":"WebRTC","url":"/jellyfish-docs/getting_started/peers/webrtc#configuration-options","content":"Optional enableSimulcast (boolean, default: true) - Enables the peer to use simulcast "},{"title":"Env variables​","type":1,"pageTitle":"WebRTC","url":"/jellyfish-docs/getting_started/peers/webrtc#env-variables","content":"JF_WEBRTC_USED - has to be true if WebRTC peers will be usedJF_WEBRTC_TURN_LISTEN_IP - the IP address on which TURN servers will listen. By default set to 127.0.0.1. When running Jellyfish via Docker, this MUST be set to 0.0.0.0, even for local tests.JF_WEBRTC_TURN_IP - the IP address, under which TURN will present itself to the clients. By default set to 127.0.0.1. When running Jellyfish via Docker, this MUST be set to real (non-loopback) address, even for local tests.JF_WEBRTC_TURN_PORT_RANGE - port range, where UDP TURN will try to open ports. By default set to 50000-59999. The bigger the range is, the more users server will be able to handle. Useful when not using the --network=host option to limit the UDP ports used only to ones published from a Docker container.JF_WEBRTC_TURN_TCP_PORT - port number of TCP TURN "},{"title":"Example Docker commands​","type":1,"pageTitle":"WebRTC","url":"/jellyfish-docs/getting_started/peers/webrtc#example-docker-commands","content":"Explicit port exposure (macOS compatible) docker run -p 50000-50050:50000-50050/udp \\ -p 8080:8080/tcp \\ -e JF_SERVER_API_TOKEN=token \\ -e JF_HOST=localhost:8080 \\ -e JF_WEBRTC_USED=true \\ -e JF_WEBRTC_TURN_PORT_RANGE=50000-50050 \\ -e JF_WEBRTC_TURN_IP=192.168.0.1 \\ -e JF_WEBRTC_TURN_LISTEN_IP=0.0.0.0 \\ ghcr.io/jellyfish-dev/jellyfish:0.2.0  caution Make sure that the exposed UDP ports match JF_WEBRTC_TURN_PORT_RANGE. The range of the ports shouldn't be too wide as it might cause problems with container startup. Using host network (Linux only) docker run --network=host \\ -e JF_SERVER_API_TOKEN=token \\ -e JF_HOST=localhost:8080 \\ -e JF_WEBRTC_USED=true \\ -e JF_WEBRTC_TURN_IP=192.168.0.1 \\ -e JF_WEBRTC_TURN_LISTEN_IP=0.0.0.0 \\ ghcr.io/jellyfish-dev/jellyfish:0.2.0  "},{"title":"Example Scenarios","type":0,"sectionRef":"#","url":"/jellyfish-docs/introduction/example_scenarios","content":"","keywords":""},{"title":"Real-time video conferencing system​","type":1,"pageTitle":"Example Scenarios","url":"/jellyfish-docs/introduction/example_scenarios#real-time-video-conferencing-system","content":"In this scenario, we want to create a simple video conferencing system where people can talk to each other in the real-time. Because of interactive and real-time requirements, the natural choice is to use the WebRTC standard. The final architecture would look like this:   "},{"title":"Broadcasting system with the real-time mixin​","type":1,"pageTitle":"Example Scenarios","url":"/jellyfish-docs/introduction/example_scenarios#broadcasting-system-with-the-real-time-mixin","content":"In this scenario, we want to create a broadcasting solution where the conversation between multiple people is broadcasted to the broader audience. Here, we choose WebRTC as a standard used for connecting people talking to each other in real-time and HLS for creating a playlist that can be then uploaded to CDN and broadcasted to the broader audience. As you can see, the whole system will automatically adapt to the number of participants talking in real-time. In particular, Jellyfish will handle a scenario with only one streamer out of the box.   "},{"title":"Displaying IP camera streams in a web browser​","type":1,"pageTitle":"Example Scenarios","url":"/jellyfish-docs/introduction/example_scenarios#displaying-ip-camera-streams-in-a-web-browser","content":"In this scenario, we have a set of IP cameras and we want to display their streams in a web browser. IP cameras very often use RTSP for streaming media but browsers don't ship with support for this protocol. Therefore, to display audio and video in a web browser, we have to use either WebRTC or HLS. Because, in this scenario, the delay is not the most crucial thing, we choose HLS. The most important thing here is that the RTSP component connects to the IP camera and then the camera starts streaming. It's not the camera that initializes the connection to the server. Therefore, the RTSP component is a purely server-side thing - once you add it, it should be able to work on its own.   "},{"title":"Basic Concepts","type":0,"sectionRef":"#","url":"/jellyfish-docs/introduction/basic_concepts","content":"","keywords":""},{"title":"Room​","type":1,"pageTitle":"Basic Concepts","url":"/jellyfish-docs/introduction/basic_concepts#room","content":"In Jellyfish, a room serves as a holder for peers and components, its function varying based on application. For instance, within a video conferencing system, a Jellyfish room represents a single online meeting or a channel accommodating multiple users for conversation. On the other hand, in a broadcasting system setting, one room will be a container for two components - one responsible for receiving stream from a streaming host (e.g. via RTMP) and the other one responsible for converting this stream into an HLS playlist ready to be broadcasted via CDN. "},{"title":"Component​","type":1,"pageTitle":"Basic Concepts","url":"/jellyfish-docs/introduction/basic_concepts#component","content":"A component is a server-side process that publishes or subscribes to tracks. Example components are: HLS component - subscribes to all other tracks and creates from them an HLS playlist ready to be broadcasted via CDNRTSP component - connects to the remote media source (e.g. an IP camera) and publishes its media to be consumed by other components or peers "},{"title":"Peer​","type":1,"pageTitle":"Basic Concepts","url":"/jellyfish-docs/introduction/basic_concepts#peer","content":"A peer is a client-side entity that connects to the server to publish, subscribe or publish and subscribe to tracks published by components or other peers. The peer's process is spawned after the peer connects to the server. At the moment, there is only one type of peer - WebRTC. "},{"title":"Difference between Component and Peer​","type":1,"pageTitle":"Basic Concepts","url":"/jellyfish-docs/introduction/basic_concepts#difference-between-component-and-peer","content":"The most important difference between a component and a peer is that component is a purely server-side thing. It starts its work right after adding it to the server. On the other hand, a peer is something that has to connect to the server. Therefore, peers are allowed to open so-called signaling channels to the server. See also Example Scenarios. "},{"title":"The Whats and Hows of Jellyfish Dashboard","type":0,"sectionRef":"#","url":"/jellyfish-docs/tutorials/dashboard","content":"","keywords":""},{"title":"What is Jellyfish Dashboard?​","type":1,"pageTitle":"The Whats and Hows of Jellyfish Dashboard","url":"/jellyfish-docs/tutorials/dashboard#what-is-jellyfish-dashboard","content":"Jellyfish Dashboard is a web application that allows you to manage your Jellyfish Media Server instance. It is a React application that uses the Jellyfish React Client APIfor adding and receiving tracks and Jellyfish Server APIfor adding peers, creating rooms etc. It was created to help Jellyfish developers in testing but was later extended and adapted as a tool for tutorials and demos. Here, we present a short introduction to the dashboard and its features. "},{"title":"How to start Jellyfish Dashboard?​","type":1,"pageTitle":"The Whats and Hows of Jellyfish Dashboard","url":"/jellyfish-docs/tutorials/dashboard#how-to-start-jellyfish-dashboard","content":"There are a couple of ways to start the dashboard: Up-to-date versionDocker containerOfficial repository The current version of the dashboard is ready to use and availablehere. Ensure that it is compatible with your Jellyfish server! Please note that this dashboard only supports secure connections (https/wss) or connections to localhost. Any insecure requests (http/ws) will be automatically blocked by the browser. "},{"title":"How to start Jellyfish Media Server?​","type":1,"pageTitle":"The Whats and Hows of Jellyfish Dashboard","url":"/jellyfish-docs/tutorials/dashboard#how-to-start-jellyfish-media-server","content":"For testing, we'll run the Jellyfish Media Server locally using Docker image: docker run -p 50000-50050:50000-50050/udp \\ -p 5002:5002/tcp \\ -e JF_HOST=&lt;your ip address&gt;:5002 \\ -e JF_PORT=&quot;5002&quot; \\ -e JF_WEBRTC_USED=true \\ -e JF_WEBRTC_TURN_PORT_RANGE=50000-50050 \\ -e JF_WEBRTC_TURN_IP=&lt;your ip address&gt; \\ -e JF_WEBRTC_TURN_LISTEN_IP=0.0.0.0 \\ -e JF_SERVER_API_TOKEN=development \\ ghcr.io/jellyfish-dev/jellyfish:0.2.0  Make sure to set JF_WEBRTC_TURN_IP and JF_HOST to your local IP address. Without it, the mobile device won't be able to connect to the Jellyfish. tip To check your local IP you can use this handy command (Linux/macOS): ifconfig | grep &quot;inet &quot; | grep -Fv 127.0.0.1 | awk '{print $2}'  "},{"title":"How to use Jellyfish Dashboard?​","type":1,"pageTitle":"The Whats and Hows of Jellyfish Dashboard","url":"/jellyfish-docs/tutorials/dashboard#how-to-use-jellyfish-dashboard","content":"Since we have Dashboard and Jellyfish Media Server up and running, we can dive into the features. "},{"title":"Connecting to the server​","type":1,"pageTitle":"The Whats and Hows of Jellyfish Dashboard","url":"/jellyfish-docs/tutorials/dashboard#connecting-to-the-server","content":"We started the dashboard and the Jellyfish Media Server separately, so we need to connect them. Open the dashboard in your browser. Open the side menu and fill in the parameters:  Server token - a token necessary to authenticate the dashboard with the Jellyfish. For now, it's simply development, but it is meant to authenticate the dashboard to the Jellyfish, so the good practice is to use a token that is hard to guess.WS/WSS - whether to use a secure or insecure connection. , it's ws, but if the Jellyfish uses secure WebSocket, use wss.HTTP/HTTPS - whether to use a secure or insecure connection. By default, it's http, but if the Jellyfish uses secure HTTP, use https.Server URL - URL of the Jellyfish server. Here, localhost:5002 would be a local build, but it can be any URL that points to the Jellyfish.Socket Path - path to the WebSocket endpoint. The default value is /socket/peer/websocket. Click Connect to server. If everything is correct, a server will appear in the list of connected servers:  "},{"title":"Creating a room​","type":1,"pageTitle":"The Whats and Hows of Jellyfish Dashboard","url":"/jellyfish-docs/tutorials/dashboard#creating-a-room","content":"There are plenty of settings that You can adjust in a room:  h264 or vp8 - video codec used in the room. If you want to use HLS streaming, you need to use h264.Max Peers - maximum number of peers that can join to the room. When you select the settings, click the Add room button. If everything is correct, a room will appear in the list of rooms:  "},{"title":"Adding and connecting peers to the room​","type":1,"pageTitle":"The Whats and Hows of Jellyfish Dashboard","url":"/jellyfish-docs/tutorials/dashboard#adding-and-connecting-peers-to-the-room","content":"Using the Create peer button, you can create a peer that will be ready to connect to the room.  The peer has its ID and Token. The ID is used to identify the peer in the Jellyfish Server, and the Token is used to authenticate the peer with the Jellyfish Server. Dashboard has an option to copy both of those values to the clipboard. You can also create a QR code with the peer's Token to make connecting to Jellyfish with a mobile device easier.  To connect the peer to the room, you can either press the Connect button in the peer's row, or scan the QR code with your mobile app, and connect there. "},{"title":"Sending tracks​","type":1,"pageTitle":"The Whats and Hows of Jellyfish Dashboard","url":"/jellyfish-docs/tutorials/dashboard#sending-tracks","content":"When the peer connects to the room, you will see the track menu. It allows you to send tracks to the room.  You can select the audio or video track you want to create. Created tracks will be visible in the list below. You can select any track from the list and send it to the room. Apart from your camera/microphone, you can easily share your screen with its audio or pick one from a list of mock tracks that we prepared. You can also select the resolution of the video track or if you want, send the video as a simulcast stream. There is also an option to add custom metadata (in JSON format) to the track. The peer will send metadata with the track to the room. Each recipient will be able to see it. When you select the track, click the Add track button. If everything is correct, client will send the track to the room and other peers will be able to see and hear you. "},{"title":"Receiving tracks​","type":1,"pageTitle":"The Whats and Hows of Jellyfish Dashboard","url":"/jellyfish-docs/tutorials/dashboard#receiving-tracks","content":"When the peer connects to the room, it will automatically receive tracks from other peers. Congrats! The basic utils of the dashboard are now covered. Next, we will dive into useful features that will help you with testing. "},{"title":"A ton of information that the dashboard provides​","type":1,"pageTitle":"The Whats and Hows of Jellyfish Dashboard","url":"/jellyfish-docs/tutorials/dashboard#a-ton-of-information-that-the-dashboard-provides","content":""},{"title":"Server logs in console​","type":1,"pageTitle":"The Whats and Hows of Jellyfish Dashboard","url":"/jellyfish-docs/tutorials/dashboard#server-logs-in-console","content":"On the side menu, you can set up the dashboard to display React Client logs in the console. Logs are great for debugging purposes and provide insight into the various communications that occur between the dashboard and the Jellyfish Server. You can also register your event handlers in your Jellyfish-based projects, both in theReact Client SDK and theTS Client SDK. These logs can show you when particular events occur and provide data that you can use in your own handlers  "},{"title":"Server/Room/Client state​","type":1,"pageTitle":"The Whats and Hows of Jellyfish Dashboard","url":"/jellyfish-docs/tutorials/dashboard#serverroomclient-state","content":"Each server, room, and client has its state. You can see the state of each of them in the dashboard by clicking appropriate buttons.  "},{"title":"Server events​","type":1,"pageTitle":"The Whats and Hows of Jellyfish Dashboard","url":"/jellyfish-docs/tutorials/dashboard#server-events","content":"Apart from the state, you can also see the events that occur on the server. You can see them after clicking the Show Server Events button.  "},{"title":"HLS and RTSP streaming​","type":1,"pageTitle":"The Whats and Hows of Jellyfish Dashboard","url":"/jellyfish-docs/tutorials/dashboard#hls-and-rtsp-streaming","content":"The dashboard allows adding HLS and RTSP streams in the room. You can set up the streams and see them in the room. It will look like this:  "},{"title":"Loadbalancing in Dashboard​","type":1,"pageTitle":"The Whats and Hows of Jellyfish Dashboard","url":"/jellyfish-docs/tutorials/dashboard#loadbalancing-in-dashboard","content":"Jellyfish Server supports load balancing. This means you can run multiple instances of the server and use them simultaneously to distribute the load evenly among them. The dashboard reflects this feature. If you run multiple Jellyfish instances (which Docker Compose does by default), connect one server to the dashboard. When a server opens a room on a different instance, the Dashboard will automatically connect to it and display the room. When Jellyfish runs in a cluster, and the Dashboard requests a new room, it's created on the Jellyfish instance with the lowest load. Information about the specific Jellyfish instance that hosts the newly created room is returned in the HTTP response body. "},{"title":"Data collected by Jellyfish​","type":1,"pageTitle":"The Whats and Hows of Jellyfish Dashboard","url":"/jellyfish-docs/tutorials/dashboard#data-collected-by-jellyfish","content":"For each server, Jellyfish collects WebRTC statistics about the rooms, clients and streamed tracks. You can see them in the dashboard using the Internals button.  The button opens a new tab with the panel to connect to the WebSocket of the Jellyfish of choice. You can observe the data with the dynamically generated charts showing what flows through the Jellyfish.  "},{"title":"Summary​","type":1,"pageTitle":"The Whats and Hows of Jellyfish Dashboard","url":"/jellyfish-docs/tutorials/dashboard#summary","content":"Congrats on finishing the tutorial! You should now be able to use the dashboard to its full potential. But this was just the beginning. Jellyfish Client API is a powerful tool that allows you to create your own web or mobile multimedia application. Check out the other tutorials to learn more about the Jellyfish Client API and how to use it in your projects. You can also take a look at our fully featured Videoroom Demo example:  It's written in React Native, but it uses the same Jellyfish Client API as the dashboard, so you can learn a lot from it. "},{"title":"Simple React App","type":0,"sectionRef":"#","url":"/jellyfish-docs/tutorials/simple-react-app","content":"","keywords":""},{"title":"What you'll learn​","type":1,"pageTitle":"Simple React App","url":"/jellyfish-docs/tutorials/simple-react-app#what-youll-learn","content":"This tutorial will guide you through creating your first React project that uses the Jellyfish Client. By the end of the tutorial, you'll have a working web application that connects toJellyfish Media Server using WebRTC technology.  You can check out the finished project here "},{"title":"What do you need​","type":1,"pageTitle":"Simple React App","url":"/jellyfish-docs/tutorials/simple-react-app#what-do-you-need","content":"a little bit of experience in creating React appsIDE of your choice (for example Visual Studio Code)Node.js installed on your machine "},{"title":"Jellyfish architecture​","type":1,"pageTitle":"Simple React App","url":"/jellyfish-docs/tutorials/simple-react-app#jellyfish-architecture","content":"info You can learn more about Jellyfish architecture in Jellyfish docs. This section provides a brief description aimed at front-end developers Let's introduce some concepts first: Peer - A peer is a client-side entity that connects to the server to publish, subscribe or publish and subscribe to tracks published by components or other peers. You can think of it as a participant in a room. At the moment, there is only one type of peer - WebRTC.Track - An object that represents an audio or video stream. A track can be associated with a local media source, such as a camera or microphone, or a remote media source received from another user. Tracks are used to capture, transmit, and receive audio and video data in WebRTC applications.Room - In Jellyfish, a room serves as a holder for peers and components, its function varying based on application. From a front-end perspective, this will be probably one meeting or a broadcast. For a better understanding of these concepts here is an example of a room that holds a standard WebRTC conference from a perspective of the User:  In this example, peers stream multiple video and audio tracks. Peer #1 streams even two video tracks (camera and screencast track). You can differentiate between them by using track metadata. The user gets info about peers and their tracks from the server using Jellyfish Client. The user is also informed in real time about peers joining/leaving and tracks being added/removed. To keep this tutorial short we'll simplify things a little. Every peer will stream just one video track. "},{"title":"Connecting and joining the room​","type":1,"pageTitle":"Simple React App","url":"/jellyfish-docs/tutorials/simple-react-app#connecting-and-joining-the-room","content":"The general flow of connecting to the server and joining the room in a standard WebRTC conference setup looks like this:  The parts that you need to implement are marked in blue and things handled by Jellyfish are marked in red. Firstly, the user logs in. Then your backend authenticates the user and obtains a peer token. It allows the user to authenticate and join the room in Jellyfish Server. The backend passes the token to your front-end, and your front-end passes it to Jellyfish Client. The client establishes the connection with Jellyfish Server. Then Jellyfish Client sets up tracks (camera, microphone) to stream and joins the room on Jellyfish Server. Finally, your front-end can display the room for the user. For this tutorial we simplified this process a bit - you don't have to implement a backend or authentication. Jellyfish Dashboard will do this for you. It's also a nice tool to test and play around with Jellyfish. The flow with Jellyfish The dashboard looks like this:  You can see that the only things you need to implement are interactions with the user and Jellyfish Client. This tutorial will show you how to do it. "},{"title":"Setup​","type":1,"pageTitle":"Simple React App","url":"/jellyfish-docs/tutorials/simple-react-app#setup","content":""},{"title":"Create React + Vite project​","type":1,"pageTitle":"Simple React App","url":"/jellyfish-docs/tutorials/simple-react-app#create-react--vite-project","content":"Firstly create a brand new project. npm create vite@latest my-react-app -- --template react-ts  "},{"title":"Add dependencies​","type":1,"pageTitle":"Simple React App","url":"/jellyfish-docs/tutorials/simple-react-app#add-dependencies","content":"For this module to work you'll need to add our `react-client-sdk` package. This is necessary to create and connect Jellyfish Client. npm install https://github.com/jellyfish-dev/react-client-sdk#0.1.2  "},{"title":"Start the Jellyfish backend​","type":1,"pageTitle":"Simple React App","url":"/jellyfish-docs/tutorials/simple-react-app#start-the-jellyfish-backend","content":"For testing, we'll run the Jellyfish Media Server locally using Docker image: docker run -p 50000-50050:50000-50050/udp \\ -p 5002:5002/tcp \\ -e JF_HOST=&lt;your ip address&gt;:5002 \\ -e JF_PORT=&quot;5002&quot; \\ -e JF_WEBRTC_USED=true \\ -e JF_WEBRTC_TURN_PORT_RANGE=50000-50050 \\ -e JF_WEBRTC_TURN_IP=&lt;your ip address&gt; \\ -e JF_WEBRTC_TURN_LISTEN_IP=0.0.0.0 \\ -e JF_SERVER_API_TOKEN=development \\ ghcr.io/jellyfish-dev/jellyfish:0.2.0  Make sure to set JF_WEBRTC_TURN_IP and JF_HOST to your local IP address. Without it, the mobile device won't be able to connect to the Jellyfish. tip To check your local IP you can use this handy command (Linux/macOS): ifconfig | grep &quot;inet &quot; | grep -Fv 127.0.0.1 | awk '{print $2}'  "},{"title":"Start the dashboard web front-end​","type":1,"pageTitle":"Simple React App","url":"/jellyfish-docs/tutorials/simple-react-app#start-the-dashboard-web-front-end","content":"There are a couple of ways to start the dashboard: Up-to-date versionDocker containerOfficial repository The current version of the dashboard is ready to use and availablehere. Ensure that it is compatible with your Jellyfish server! Please note that this dashboard only supports secure connections (https/wss) or connections to localhost. Any insecure requests (http/ws) will be automatically blocked by the browser. "},{"title":"(Optional) Add a bit of CSS styling​","type":1,"pageTitle":"Simple React App","url":"/jellyfish-docs/tutorials/simple-react-app#optional-add-a-bit-of-css-styling","content":"For this project, we prepared simple CSS classes, You are free to use it or create your own. "},{"title":"General project structure​","type":1,"pageTitle":"Simple React App","url":"/jellyfish-docs/tutorials/simple-react-app#general-project-structure","content":"Our app will consist of two parts: a component that will connect to the server and join the room a component that will display the video tracks from other participants "},{"title":"First step - prepare all the hooks and the context​","type":1,"pageTitle":"Simple React App","url":"/jellyfish-docs/tutorials/simple-react-app#first-step---prepare-all-the-hooks-and-the-context","content":"To connect to the Jellyfish backend, we need to create a Membrane Client instance. We can do it by using the create function from the@jellyfish-dev/react-client-sdk package. It needs two generic parameters: PeerMetadata - the type of metadata that will be sent to the server when connecting to the room (for example, user name) it has to be serializable TrackMetadata - the type of the metadata that will be sent to the server when sending a track (for example, track name) it has to be serializable as well App.tsx import React from &quot;react&quot;; import { create } from &quot;@jellyfish-dev/react-client-sdk&quot;; // Example metadata types for peer and track // You can define your metadata types just make sure they are serializable type PeerMetadata = { name: string; }; type TrackMetadata = { type: &quot;camera&quot; | &quot;screen&quot;; }; // Create a Jellyfish client instance // Since we will use this context outside of the component we need to export it export const { JellyfishContextProvider, // Context provider } = create&lt;PeerMetadata, TrackMetadata&gt;(); export const App = () =&gt; {};  "},{"title":"Now we need to wrap our app with the context provider​","type":1,"pageTitle":"Simple React App","url":"/jellyfish-docs/tutorials/simple-react-app#now-we-need-to-wrap-our-app-with-the-context-provider","content":"That's all we will need to do in this file. Simply import the JellyfishContextProvider along with the Appcomponent and wrap the App component with the JellyfishContextProvider: main.tsx import React from &quot;react&quot;; import ReactDOM from &quot;react-dom/client&quot;; import { App, JellyfishContextProvider } from &quot;./components/App&quot;; ReactDOM.createRoot(document.getElementById(&quot;root&quot;) as HTMLElement).render( &lt;React.StrictMode&gt; &lt;JellyfishContextProvider&gt; &lt;App /&gt; &lt;/JellyfishContextProvider&gt; &lt;/React.StrictMode&gt; );  "},{"title":"UI component that will connect to the server and join the room​","type":1,"pageTitle":"Simple React App","url":"/jellyfish-docs/tutorials/simple-react-app#ui-component-that-will-connect-to-the-server-and-join-the-room","content":"The UI of the component will be quite simple. It will consist of a simple text input field that will allow us to enter the peer token and a button that will connect to the server and join the room. We can also display the status of the connection. App.tsx import React, { useState } from &quot;react&quot;; //... export const App = () =&gt; { // Create a state to store the peer token const [token, setToken] = useState(&quot;&quot;); return ( &lt;div style={{ display: &quot;flex&quot;, flexDirection: &quot;column&quot;, gap: &quot;8px&quot; }}&gt; &lt;input value={token} onChange={(e) =&gt; setToken(() =&gt; e?.target?.value)} placeholder=&quot;token&quot; /&gt; &lt;div style={{ display: &quot;flex&quot;, flexDirection: &quot;row&quot;, gap: &quot;8px&quot; }}&gt; &lt;button disabled={} onClick={() =&gt; {}}; &gt; Connect &lt;/button&gt; &lt;button disabled={} onClick={() =&gt; {}}; &gt; Disconnect &lt;/button&gt; &lt;span&gt;Status: {}&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; ); };  "},{"title":"Once the UI is ready, we need to implement the logic​","type":1,"pageTitle":"Simple React App","url":"/jellyfish-docs/tutorials/simple-react-app#once-the-ui-is-ready-we-need-to-implement-the-logic","content":"App.tsx import { SignalingUrl } from &quot;@jellyfish-dev/react-client-sdk/.&quot;; //... export const { useStatus, // Hook to check the status of the connection useConnect, // Hook to connect to the server useDisconnect, // Hook to disconnect from the server JellyfishContextProvider, // Context provider }; export const App = () =&gt; { // Create a state to store the peer token const [token, setToken] = useState(&quot;&quot;); // Use the built-in hook to check the status of the connection const status = useStatus(); const connect = useConnect(); const disconnect = useDisconnect(); return ( &lt;div style={{ display: &quot;flex&quot;, flexDirection: &quot;column&quot;, gap: &quot;8px&quot; }}&gt; &lt;input className=&quot;input-field&quot; value={token} onChange={(e) =&gt; setToken(() =&gt; e?.target?.value)} placeholder=&quot;token&quot; /&gt; &lt;div style={{ display: &quot;flex&quot;, flexDirection: &quot;row&quot;, gap: &quot;8px&quot; }}&gt; &lt;button className=&quot;button&quot; disabled={token === &quot;&quot; || status === &quot;joined&quot;} // simple check to avoid errors onClick={() =&gt; { connect({ peerMetadata: { name: &quot;John Doe&quot; }, // example metadata token: token, }); }} &gt; Connect &lt;/button&gt; &lt;button className=&quot;button&quot; disabled={status !== &quot;joined&quot;} onClick={() =&gt; { disconnect(); }} &gt; Disconnect &lt;/button&gt; &lt;span className=&quot;span-status&quot;&gt;Status: {status}&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; ); };  Great! Now we can connect to the server and join the room. But we still need to add some logic to send our tracks to the server and receive tracks from others. "},{"title":"Let's send our screen to the server​","type":1,"pageTitle":"Simple React App","url":"/jellyfish-docs/tutorials/simple-react-app#lets-send-our-screen-to-the-server","content":"This hook uses Navigator.mediaDevices take a look how it works App.tsx import React, { useEffect, useState } from &quot;react&quot;; import { create, SCREEN_SHARING_MEDIA_CONSTRAINTS } from &quot;@jellyfish-dev/react-client-sdk&quot;; import { SignalingUrl, Peer } from &quot;@jellyfish-dev/react-client-sdk/.&quot;; //... export const { useStatus, // Hook to check the status of the connection useApi, // Hook to get the webrtcApi reference useConnect, // Hook to connect to the server useDisconnect, // Hook to disconnect from the server JellyfishContextProvider, // Context provider } = create&lt;PeerMetadata, TrackMetadata&gt;(); export const App = () =&gt; { //... // Get the webrtcApi reference const webrtcApi = useApi(); function startScreenSharing() { // Get screen sharing MediaStream navigator.mediaDevices.getDisplayMedia(SCREEN_SHARING_MEDIA_CONSTRAINTS).then((screenStream) =&gt; { // Add local MediaStream to webrtc screenStream.getTracks().forEach((track) =&gt; webrtcApi.addTrack(track, screenStream, { type: &quot;screen&quot; })); }; }; return ( //... &lt;button className=&quot;button&quot; disabled={status !== &quot;joined&quot;} onClick={() =&gt; { startScreenSharing(); }} &gt; Start screen share &lt;/button&gt; &lt;span&gt;Status: {status}&lt;/span&gt; //... ) };  You should now see your screen received for each connected client on the dashboard. You can add another participant to check this out! The streaming part of the app is ready! "},{"title":"What about the receiving part?​","type":1,"pageTitle":"Simple React App","url":"/jellyfish-docs/tutorials/simple-react-app#what-about-the-receiving-part","content":""},{"title":"This is where the second component comes in handy​","type":1,"pageTitle":"Simple React App","url":"/jellyfish-docs/tutorials/simple-react-app#this-is-where-the-second-component-comes-in-handy","content":"For each track received, we will create a new video element and display it on the screen. For clarity, we will separate this component into another file: Create in your directory file VideoPlayer.tsx VideoPlayer.tsx type Props = { stream: MediaStream | null | undefined; }; const VideoPlayer = ({ stream }: Props) =&gt; { return ( &lt;div className=&quot;video-container&quot;&gt; &lt;video autoPlay playsInline muted ref={/* place for track ref*/} /&gt; &lt;/div&gt; ); }; export default VideoPlayer;  "},{"title":"Now the logic for the component​","type":1,"pageTitle":"Simple React App","url":"/jellyfish-docs/tutorials/simple-react-app#now-the-logic-for-the-component","content":"VideoPlayer.tsx type Props = { stream: MediaStream | null | undefined; }; const VideoPlayer = ({ stream }: Props) =&gt; { const videoRef: RefObject&lt;HTMLVideoElement&gt; = useRef&lt;HTMLVideoElement&gt;(null); useEffect(() =&gt; { if (!videoRef.current) return; videoRef.current.srcObject = stream || null; }, [stream]); return ( &lt;div&gt; &lt;video autoPlay playsInline muted ref={videoRef} /&gt; &lt;/div&gt; ); }; export default VideoPlayer;  "},{"title":"Now we can use it in our main component​","type":1,"pageTitle":"Simple React App","url":"/jellyfish-docs/tutorials/simple-react-app#now-we-can-use-it-in-our-main-component","content":"App.tsx import React, { useEffect, useState } from &quot;react&quot;; import { create, SCREEN_SHARING_MEDIA_CONSTRAINTS } from &quot;@jellyfish-dev/react-client-sdk&quot;; import { SignalingUrl, Peer } from &quot;@jellyfish-dev/react-client-sdk/.&quot;; import VideoPlayer from &quot;./VideoPlayer&quot;; //... export const { useStatus, // Hook to check the status of the connection useTracks, // Hook to get the tracks from the server useApi, // Hook to get the webrtcApi reference useConnect, // Hook to connect to the server useDisconnect, // Hook to disconnect from the server JellyfishContextProvider, // Context provider } = create&lt;PeerMetadata, TrackMetadata&gt;(); export const App = () =&gt; { const tracks = useTracks(); //... &lt;div style={{ display: &quot;flex&quot;, flexWrap: &quot;wrap&quot;, justifyContent: &quot;center&quot;, // To align items in the center gap: &quot;20px&quot;, }} &gt; {Object.values(tracks).map(({ stream, trackId }) =&gt; ( &lt;VideoPlayer key={trackId} stream={stream} /&gt; // pass the stream to the component ))} &lt;/div&gt; //... )  You should see all the tracks sent from the dashboard directly on your page, to test them, add a new client, and add a track (for example a rotating frog). It will show up in your app automatically: "},{"title":"Summary​","type":1,"pageTitle":"Simple React App","url":"/jellyfish-docs/tutorials/simple-react-app#summary","content":"Congrats on finishing your first Jellyfish web application! In this tutorial, You've learned how to make a basic Jellyfish client application that streams your screen and receives video tracks with WebRTC technology. But this was just the beginning. Jellyfish Client supports much more than just streaming camera: It can also stream audio or your device's camera, configure your camera and audio devices, detect voice activity, control simulcast, bandwidth and encoding settings, show camera preview, display WebRTC stats and more to come. Check out our other tutorials to learn about those features. You can also take a look at our fully featured Videoroom Demo example:  "}]