[{"title":"API Reference","type":0,"sectionRef":"#","url":"/jellyfish-docs/api_reference","content":"API Reference Jellyfish API is composed of three layers a REST API for managing Jellyfish statea WS connection for client SDK communication (socket path /socket/peer) a WS connection for server notifications (socket path /socket/server) You can find them here: OpenAPI REST descriptionProtobufs used by peer WSProtobufs used by server WS The communication via WebSockets is done with use of Protobuf format. The very first message that has to be sent on either of WebSocket connections (peer to Jellyfish oryour_backend_server to Jellyfish) is AuthRequest. All supported messages are listed in the Jellyfish protos repo. If you want to create your own Jellyfish SDK, the easiest way to reference to defined protobuf messages will be by adding protos to your git repository as a git submodule. You can do it with this command: git submodule add https://github.com/jellyfish-dev/protos You could also consider creating a script that will pull newest changes from the git submodule and compile.proto files to your chosen programming language. For reference, see the script used in our Elixir SDK.","keywords":""},{"title":"Fly.io (experimental)","type":0,"sectionRef":"#","url":"/jellyfish-docs/deploying/fly_io","content":"","keywords":""},{"title":"Creating new app​","type":1,"pageTitle":"Fly.io (experimental)","url":"/jellyfish-docs/deploying/fly_io#creating-new-app","content":"Launch fly launch. When prompted, copy the configuration from the existing fly.toml file. Select appropriate app name and region, don't create any databases. Don't deploy the app just yet. Running fly launch may modify the Dockerfile. Make sure to remove the lines appended by flyctl. "},{"title":"Configuring the App​","type":1,"pageTitle":"Fly.io (experimental)","url":"/jellyfish-docs/deploying/fly_io#configuring-the-app","content":"Before deploying your app, make sure it is correctly configured. "},{"title":"Dedicated IPv4​","type":1,"pageTitle":"Fly.io (experimental)","url":"/jellyfish-docs/deploying/fly_io#dedicated-ipv4","content":"In order to transmit multimedia via UDP, the app has to be publicly available with an IPv4 address. By default Fly.io uses shared IP. To enable dedicated IPv4 address run fly ips allocate-v4  Note, that dedicated IP address is a paid feature on Fly.io. You can learn more about dedicated IPv4 address here. "},{"title":"fly.toml​","type":1,"pageTitle":"Fly.io (experimental)","url":"/jellyfish-docs/deploying/fly_io#flytoml","content":"Make sure you don't have the following lines in the fly.toml, which are automatically generated by fly launch. You don't need to run migrations, since you don't have a database. [deploy] release_command = &quot;/app/bin/migrate&quot;  Jellyfish uses VIRTUAL_HOST variable instead of the default PHX_HOST. VIRTUAL_HOST = &quot;&lt;YOUR APP HOSTNAME&gt;&quot;  Also, make sure you have set the correct port. The enviroment variable PORT has to match the tcp internal_port defined under services section. The default for Jellyfish is 4000. To be able to receive and send UDP traffic, Jellyfish has to open its UDP ports on a special fly-global-services address, not 0.0.0.0. This must be set using the INTEGRATED_TURN_LISTEN_IP enviroment variable. You also need to specify the Jellyfish IP address for UDP, it is the IP address which you generated in the previous step. INTEGRATED_TURN_LISTEN_IP = &quot;fly-global-services&quot; INTEGRATED_TURN_IP=&quot;&lt;YOUR APP IP ADDRESS&gt;&quot;  You can also read tutorial for running Fly.io apps which use UDP. "},{"title":"Fly.io secrets​","type":1,"pageTitle":"Fly.io (experimental)","url":"/jellyfish-docs/deploying/fly_io#flyio-secrets","content":"There are enviroment variables, which you may not want to keep in the fly.toml config. Fly.io provides a way to store such values securely. For Jellyfish you need to configure SECRET_KEY_BASE and TOKEN secrets. flyctl secrets set SECRET_KEY_BASE=super-secret-key flyctl secrets set TOKEN=development  "},{"title":"Deploying​","type":1,"pageTitle":"Fly.io (experimental)","url":"/jellyfish-docs/deploying/fly_io#deploying","content":"With everything configured you can deploy the app fly deploy  Note that it may take a moment for the UDP traffic to be forwarded to the application. This means for example, that WebRTC may not be working yet. This is the tricky part of the deployment, which we weren't able to entirely figure out. Sometimes the UDP just works, others it takes ages for it to start flowing.This topic describes the exact issue we had with Fly.io. In general, it is unclear when the UDP traffic starts to be forwarded, sometimes it happens relatively quickly after deployment, sometimes you need to wait for some time. Also, the Fly.io documentation isn't clear in regard to opening UDP sockets. Some information was gathered experimentally, or based on Fly.io community questions, such as this one. "},{"title":"Design Docs","type":0,"sectionRef":"#","url":"/jellyfish-docs/design_docs","content":"Design Docs Crucial parts of Jellyfish architecture are always discussed and written down in the form of design documents. Each design document describes, in a nutshell, a few possible solutions or approaches to some problem and states which solution was accepted and why. The list of Jellyfish Design Docs is available here.","keywords":""},{"title":"Examples","type":0,"sectionRef":"#","url":"/jellyfish-docs/examples","content":"Examples Jellyfish usage examples utilising server SDKs can be found in the following locations: Elixir","keywords":""},{"title":"Architecture","type":0,"sectionRef":"#","url":"/jellyfish-docs/getting_started/architecture","content":"","keywords":""},{"title":"Server SDKs​","type":1,"pageTitle":"Architecture","url":"/jellyfish-docs/getting_started/architecture#server-sdks","content":"Server SDKs allow you to manage Jellyfish state. In particular, you can: authenticatecreate/delete roomsadd/remove peersadd/remove components Support for server-side notifications is also planned for the near future. Under the hood, Server SDKs just use Jellyfish REST API. tip As an example, you can use server SDK to introduce a time limit on meeting duration and shut down the room after it passes. "},{"title":"Client SDKs​","type":1,"pageTitle":"Architecture","url":"/jellyfish-docs/getting_started/architecture#client-sdks","content":"Client SDKs allow you to connect to Jellyfish to publish and consume tracks. In particular, you can: authenticatejoin specific roompublish audio and videoreceive audio and video from other peers and components At the moment, Jellyfish supports only one type of client - WebRTC. "},{"title":"Diagram​","type":1,"pageTitle":"Architecture","url":"/jellyfish-docs/getting_started/architecture#diagram","content":"The whole concept is presented in the following diagram.     Your Backend (BE) - serves your application frontend, and manages the database and application-specific logic. Jellyfish (JF) - Jellyfish media server. Manages media. Admin - someone who has special permission in your application - can create/delete rooms, add/remove peers, etc. User - someone who connects to Jellyfish to send and receive media. Everything starts with Admin who sends an HTTP request to BE to create a new room.BE uses jellyfish-server-sdk to communicate with JF and create the room. Under the hood, jellyfish-server-sdk uses REST API exposed by JF. After the room has been created, the Admin invites a user by sending a new HTTP request to BE. Again, BE uses jellyfish-server-sdk to add the new peer to JF. On the user side, they send a request to BE to join the room.BE replies with JF IP address it should connect to. Then, the User uses jellyfish-client-sdk to connect to JF. After the connection has been established, the User can send and receive media. "},{"title":"Authentication","type":0,"sectionRef":"#","url":"/jellyfish-docs/getting_started/authentication","content":"Authentication The Authentication mechanism is based on a bearer token. How does it work? Both Jellyfish and Business Logic are configured with the same secret. This secret is used for authorizing HTTP requests between them (via HTTP authorization request header). When a new client wants to join a room, Business Logic (assuming the client is authorized to join) requests adding a new peer and receives a token generated by Jellyfish. The token must then be passed to the client, that will use it to connect to the room as a new peer. The token encodes both peer and room IDs. The token exchange is handled by our Client SDKs when connecting. Under the hood, Jellyfish expects the token in the first message after opening the Web Socket connection. Token encodes peer id and room id. Run Jellyfish SERVER_API_TOKEN=SERVER_API_TOKEN mix phx.server Create a room and add one peer Business Logic client = Jellyfish.Client.new(&quot;http://address-of-your-server.com&quot;, &quot;SERVER_API_TOKEN&quot;) {:ok, room, _jellyfish_address} = Jellyfish.Room.create(client, max_peers: 10) {:ok, peer, peer_token} = Jellyfish.Room.add_peer(client, room.id, &quot;BobId&quot;) Connect as a peer to Jellyfish Client client.connect({ token: peerToken, peerMetadata: { name: &quot;Bob&quot; }, isSimulcastOn: false }) ","keywords":""},{"title":"HLS","type":0,"sectionRef":"#","url":"/jellyfish-docs/getting_started/components/hls","content":"","keywords":""},{"title":"Compatibility​","type":1,"pageTitle":"HLS","url":"/jellyfish-docs/getting_started/components/hls#compatibility","content":"WebRTCRTSP "},{"title":"Requirements​","type":1,"pageTitle":"HLS","url":"/jellyfish-docs/getting_started/components/hls#requirements","content":"The Room in which the HLS component is created must have the video codec set to H264. See API for more information.Max 1 HLS component allowed per room. "},{"title":"Configuration options​","type":1,"pageTitle":"HLS","url":"/jellyfish-docs/getting_started/components/hls#configuration-options","content":"Currently, there are no configuration options related to this component. "},{"title":"Output​","type":1,"pageTitle":"HLS","url":"/jellyfish-docs/getting_started/components/hls#output","content":"After adding a peer or an rtsp component, the hls stream will be available under http://&lt;jellyfish-address&gt;/hls/&lt;room_id&gt;/index.m3u8. "},{"title":"Env variables​","type":1,"pageTitle":"HLS","url":"/jellyfish-docs/getting_started/components/hls#env-variables","content":"Currently, there are no environment variables related to this component. "},{"title":"Example Docker commands​","type":1,"pageTitle":"HLS","url":"/jellyfish-docs/getting_started/components/hls#example-docker-commands","content":"The HLS playlist will be created inside the Docker container. To access it from the host, you need to create a volume, e.g. by adding the option -v $(pwd)/jellyfish_output:/app/jellyfish_outputto your Docker command. Other than that, your Docker commands shouldn't be affected by adding this component. docker run -p 4000:4000/tcp \\ -e SERVER_API_TOKEN=token \\ -e VIRTUAL_HOST=localhost \\ -e SECRET_KEY_BASE=secret \\ -v $(pwd)/jellyfish_output:/app/jellyfish_output ghcr.io/jellyfish-dev/jellyfish:latest  "},{"title":"RTSP","type":0,"sectionRef":"#","url":"/jellyfish-docs/getting_started/components/rtsp","content":"","keywords":""},{"title":"Compatibility​","type":1,"pageTitle":"RTSP","url":"/jellyfish-docs/getting_started/components/rtsp#compatibility","content":"WebRTCHLS "},{"title":"Requirements​","type":1,"pageTitle":"RTSP","url":"/jellyfish-docs/getting_started/components/rtsp#requirements","content":"If the Room in which the RTSP component is created enforces a video codec, it must be set to H264. See API for more information. "},{"title":"Configuration options​","type":1,"pageTitle":"RTSP","url":"/jellyfish-docs/getting_started/components/rtsp#configuration-options","content":"See API for more information. "},{"title":"Required​","type":1,"pageTitle":"RTSP","url":"/jellyfish-docs/getting_started/components/rtsp#required","content":"sourceUri (string) - URI of RTSP source stream, e.g. &quot;rtsp://mysite.net:554/stream&quot; "},{"title":"Optional​","type":1,"pageTitle":"RTSP","url":"/jellyfish-docs/getting_started/components/rtsp#optional","content":"rtpPort (integer 1..65535, default: 20000) - Local port RTP stream will be received atreconnectDelay (integer 0.., default: 15000) - Delay (in ms) between successive reconnect attemptskeepAliveInterval (integer 0.., default: 15000) - Interval (in ms) in which keep-alive RTSP messages will be sent to the remote stream sourcepierceNat (boolean, default: true) - Whether to attempt to create client-side NAT binding by sending an empty datagram from client to source, after the completion of RTSP setup "},{"title":"Env variables​","type":1,"pageTitle":"RTSP","url":"/jellyfish-docs/getting_started/components/rtsp#env-variables","content":"Currently, there are no environment variables related to this component. "},{"title":"Example Docker commands​","type":1,"pageTitle":"RTSP","url":"/jellyfish-docs/getting_started/components/rtsp#example-docker-commands","content":"caution If the client is behind NAT, the option --network=host is necessary since Docker can change the source port of UDP packets for routing reasons, which breaks the pierceNat functionality. This means that users on macOS will most likely be unable to access any RTSP stream source outside of their network when running Jellyfish using Docker. If you're on macOS and want to receive RTSP streams from behind NAT, right now the only way is to build Jellyfish natively from source. Explicit port exposure (macOS compatible) docker run -p 20000:20000/udp \\ -p 4000:4000/tcp \\ -e SERVER_API_TOKEN=token \\ -e VIRTUAL_HOST=localhost \\ -e SECRET_KEY_BASE=secret \\ ghcr.io/jellyfish-dev/jellyfish:latest  caution Make sure that the exposed UDP port matches the one used by the RTSP component (option rtpPort, default: 20000). If using multiple RTSP components, more ports will need to be exposed. Using host network (Linux only) docker run --network=host \\ -e SERVER_API_TOKEN=token \\ -e VIRTUAL_HOST=localhost \\ -e SECRET_KEY_BASE=secret \\ ghcr.io/jellyfish-dev/jellyfish:latest  "},{"title":"Installation","type":0,"sectionRef":"#","url":"/jellyfish-docs/getting_started/installation","content":"","keywords":""},{"title":"Building from source​","type":1,"pageTitle":"Installation","url":"/jellyfish-docs/getting_started/installation#building-from-source","content":"Make sure to have both Elixir and Rust installed. Check the links below for instructions: ElixirRust Clone the Jellyfish repo git clone https://github.com/jellyfish-dev/jellyfish.git  Install native dependencies macOS IntelmacOS Apple SiliconUbuntu These instructions assume you have Homebrew installed. You can get it here. brew install srtp libnice clang-format ffmpeg opus pkg-config export LDFLAGS=&quot;-L/usr/local/opt/openssl@1.1/lib&quot; export CFLAGS=&quot;-I/usr/local/opt/openssl@1.1/include/&quot; export CPPFLAGS=&quot;-I/usr/local/opt/openssl@1.1/include/&quot; export PKG_CONFIG_PATH=&quot;/usr/local/opt/openssl@1.1/lib/pkgconfig&quot;  Install elixir dependencies mix deps.get  Run the server in development mix phx.server  "},{"title":"Running with Docker​","type":1,"pageTitle":"Installation","url":"/jellyfish-docs/getting_started/installation#running-with-docker","content":"Docker images are built for production which means that you always need to set a couple of environment variables. Environment variables are split into two groups: general ones - see General env variables belowpeer/component-specific - each Peer and Component can expose its own environment variables. They are always listed in a Peer/Component description. See the list of Peers and Components. As docker commands depend on peers/components you are going to use, we don't present them here but rather in each peer/component's documentation, e.g. WebRTC Peer For the full list of Jellyfish Docker images, see this page. tip Instead of passing environmental variables manually, you can use the --env-file ./env-file flag, where the env-file is a file containing the variables that the image expects, see example file .env.sample in the Jellyfish repository. "},{"title":"General env variables​","type":1,"pageTitle":"Installation","url":"/jellyfish-docs/getting_started/installation#general-env-variables","content":"Below there are general, Jellyfish environment variables. If you are running Jellyfish in development, you don't need to set any of them. Required in production:​ SERVER_API_TOKEN - token for authorizing HTTP requests. Defaults to development for development builds.SECRET_KEY_BASE - used to sign/encrypt tokens generated for Peers.VIRTUAL_HOST - host passed to the endpoint config. Defaults to localhost for development builds.PORT - port to run the HTTP server on. Defaults to 5002 for development builds. Optional:​ CHECK_ORIGIN - defines if jellyfish will check origin of incoming requests and socket connection. Defaults to &quot;true&quot;, set to anything else to disable.JELLYFISH_ADDRESS - defines what address is returned when creating a room. Defaults to VIRTUAL_HOST:PORT.OUTPUT_BASE_PATH - a base path where Jellyfish will save its artifacts. Defaults to ./jellyfish_output/. When running via docker, the directory can be mounted as -v $(pwd)/host_directory:/app/jellyfish_output.MIX_ENV - defines compilation environment. This variable takes effect only when running from the source. Docker images are always built with MIX_ENV=prod. Possible values are: dev - uses default values for environment variables (default option when running with mix phx.server)prod - requires that you provide values for environment variablestest - used in tests "},{"title":"Rest API","type":0,"sectionRef":"#","url":"/jellyfish-docs/api_reference/rest_api","content":"Rest API getSend fileroom getShow information about all roomspostCreates a roomdelDelete the roomgetShows information about the room component postCreates the component and adds it to the roomdelDelete the component from the room peer postCreate peerdelDelete peer API docs by Redocly Jellyfish Media Server (0.2.0) Download OpenAPI specification:Download License: Apache 2.0 Send file Authorizations: authorization path Parameters room_id required string Room id filename required string Name of the file query Parameters _HLS_msn integer or null (HlsMsn) &gt;= 0 Example: _HLS_msn=10 Segment sequence number _HLS_part integer or null (HlsPart) &gt;= 0 Example: _HLS_part=10 Partial segment sequence number _HLS_skip string or null (HlsSkip) Value: &quot;YES&quot; Example: _HLS_skip=YES Is delta manifest requested header Parameters range string Byte range of partial segment Responses 200 File was found 404 File not found get/hls/{room_id}/{filename} https://raw.githubusercontent.com/hls/{room_id}/{filename} Response samples 200404 Content type application/json Copy &quot;string&quot; room Show information about all rooms Authorizations: authorization Responses 200 Success 401 Unauthorized get/room https://raw.githubusercontent.com/room Response samples 200401 Content type application/json Copy Expand all Collapse all { &quot;data&quot;: [ { &quot;components&quot;: [ { &quot;id&quot;: &quot;component-1&quot;, &quot;metadata&quot;: { &quot;playable&quot;: true }, &quot;type&quot;: &quot;hls&quot; } ], &quot;config&quot;: { &quot;maxPeers&quot;: 10, &quot;videoCodec&quot;: &quot;h264&quot; }, &quot;id&quot;: &quot;room-1&quot;, &quot;peers&quot;: [ { &quot;id&quot;: &quot;peer-1&quot;, &quot;status&quot;: &quot;disconnected&quot;, &quot;type&quot;: &quot;webrtc&quot; } ] } ] } Creates a room Authorizations: authorization Request Body schema: application/json Room configuration maxPeers integer or null &gt;= 1 Maximum amount of peers allowed into the room videoCodec string or null Enum: &quot;h264&quot; &quot;vp8&quot; Enforces video codec for each peer in the room Responses 201 Room successfully created 400 Invalid request structure 401 Unauthorized post/room https://raw.githubusercontent.com/room Request samples Payload Content type application/json Copy { &quot;maxPeers&quot;: 10, &quot;videoCodec&quot;: &quot;h264&quot; } Response samples 201400401 Content type application/json Copy Expand all Collapse all { &quot;data&quot;: { &quot;jellyfish_address&quot;: &quot;jellyfish1:5003&quot;, &quot;room&quot;: { &quot;components&quot;: [ { &quot;id&quot;: &quot;component-1&quot;, &quot;metadata&quot;: { &quot;playable&quot;: true }, &quot;type&quot;: &quot;hls&quot; } ], &quot;config&quot;: { &quot;maxPeers&quot;: 10, &quot;videoCodec&quot;: &quot;h264&quot; }, &quot;id&quot;: &quot;room-1&quot;, &quot;peers&quot;: [ { &quot;id&quot;: &quot;peer-1&quot;, &quot;status&quot;: &quot;disconnected&quot;, &quot;type&quot;: &quot;webrtc&quot; } ] } } } Delete the room Authorizations: authorization path Parameters room_id required string Room id Responses 204 Successfully deleted room 401 Unauthorized 404 Room doesn't exist delete/room/{room_id} https://raw.githubusercontent.com/room/{room_id} Response samples 401404 Content type application/json Copy { &quot;errors&quot;: &quot;Token has expired&quot; } Shows information about the room Authorizations: authorization path Parameters room_id required string Room ID Responses 200 Success 401 Unauthorized 404 Room doesn't exist get/room/{room_id} https://raw.githubusercontent.com/room/{room_id} Response samples 200401404 Content type application/json Copy Expand all Collapse all { &quot;data&quot;: { &quot;components&quot;: [ { &quot;id&quot;: &quot;component-1&quot;, &quot;metadata&quot;: { &quot;playable&quot;: true }, &quot;type&quot;: &quot;hls&quot; } ], &quot;config&quot;: { &quot;maxPeers&quot;: 10, &quot;videoCodec&quot;: &quot;h264&quot; }, &quot;id&quot;: &quot;room-1&quot;, &quot;peers&quot;: [ { &quot;id&quot;: &quot;peer-1&quot;, &quot;status&quot;: &quot;disconnected&quot;, &quot;type&quot;: &quot;webrtc&quot; } ] } } component Creates the component and adds it to the room Authorizations: authorization path Parameters room_id required string Room ID Request Body schema: application/json Component config options required ComponentOptionsHLS (object) or ComponentOptionsRTSP (object) (ComponentOptions) Component-specific options type required string (ComponentType) Component type Responses 201 Successfully added component 400 Invalid request 401 Unauthorized 404 Room doesn't exist post/room/{room_id}/component https://raw.githubusercontent.com/room/{room_id}/component Request samples Payload Content type application/json Copy Expand all Collapse all { &quot;options&quot;: { }, &quot;type&quot;: &quot;hls&quot; } Response samples 201400401404 Content type application/json Copy Expand all Collapse all { &quot;data&quot;: { &quot;id&quot;: &quot;component-1&quot;, &quot;metadata&quot;: { &quot;playable&quot;: true }, &quot;type&quot;: &quot;hls&quot; } } Delete the component from the room Authorizations: authorization path Parameters room_id required string Room ID id required string Component ID Responses 204 Successfully deleted 401 Unauthorized 404 Either component or the room doesn't exist delete/room/{room_id}/component/{id} https://raw.githubusercontent.com/room/{room_id}/component/{id} Response samples 401404 Content type application/json Copy { &quot;errors&quot;: &quot;Token has expired&quot; } peer Create peer Authorizations: authorization path Parameters room_id required string Room id Request Body schema: application/json Peer specification options required PeerOptionsWebRTC (object) (PeerOptions) Peer-specific options type required string (PeerType) Peer type Responses 201 Peer successfully created 400 Invalid request body structure 401 Unauthorized 404 Room doesn't exist 503 Peer limit has been reached post/room/{room_id}/peer https://raw.githubusercontent.com/room/{room_id}/peer Request samples Payload Content type application/json Copy Expand all Collapse all { &quot;options&quot;: { &quot;enableSimulcast&quot;: true }, &quot;type&quot;: &quot;webrtc&quot; } Response samples 201400401404503 Content type application/json Copy Expand all Collapse all { &quot;data&quot;: { &quot;peer&quot;: { &quot;id&quot;: &quot;peer-1&quot;, &quot;status&quot;: &quot;disconnected&quot;, &quot;type&quot;: &quot;webrtc&quot; }, &quot;token&quot;: &quot;5cdac726-57a3-4ecb-b1d5-72a3d62ec242&quot; } } Delete peer Authorizations: authorization path Parameters room_id required string Room ID id required string Peer id Responses 204 Peer successfully deleted 401 Unauthorized 404 Room ID or Peer ID references a resource that doesn't exist delete/room/{room_id}/peer/{id} https://raw.githubusercontent.com/room/{room_id}/peer/{id} Response samples 401404 Content type application/json Copy { &quot;errors&quot;: &quot;Token has expired&quot; }","keywords":""},{"title":"WebRTC","type":0,"sectionRef":"#","url":"/jellyfish-docs/getting_started/peers/webrtc","content":"","keywords":""},{"title":"Compatibility​","type":1,"pageTitle":"WebRTC","url":"/jellyfish-docs/getting_started/peers/webrtc#compatibility","content":"HLSRTSP "},{"title":"Configuration options​","type":1,"pageTitle":"WebRTC","url":"/jellyfish-docs/getting_started/peers/webrtc#configuration-options","content":"See API for more information. "},{"title":"Optional​","type":1,"pageTitle":"WebRTC","url":"/jellyfish-docs/getting_started/peers/webrtc#optional","content":"enableSimulcast (boolean, default: true) - Enables the peer to use simulcast "},{"title":"Env variables:​","type":1,"pageTitle":"WebRTC","url":"/jellyfish-docs/getting_started/peers/webrtc#env-variables","content":"WEBRTC_USED - has to be true if WebRTC peers will be usedINTEGRATED_TURN_LISTEN_IP - the IP address on which TURN servers will listen. By default set to 127.0.0.1. When running Jellyfish via Docker, this MUST be set to 0.0.0.0, even for local tests.INTEGRATED_TURN_IP - the IP address, under which TURN will present itself to the clients. By default set to 127.0.0.1. When running Jellyfish via Docker, this MUST be set to real (non-loopback) address, even for local tests.INTEGRATED_TURN_PORT_RANGE - port range, where UDP TURN will try to open ports. By default set to 50000-59999. The bigger the range is, the more users server will be able to handle. Useful when not using the --network=host option to limit the UDP ports used only to ones published from a Docker container.INTEGRATED_TCP_TURN_PORT - port number of TCP TURNINTEGRATED_TLS_TURN_PORT - port number of TLS TURN, used when INTEGRATED_TURN_PKEY and INTEGRATED_TURN_CERT are providedINTEGRATED_TURN_CERT - SSL certificate for TLS TURNINTEGRATED_TURN_PKEY - SSL private key for TLS TURN "},{"title":"Example Docker commands​","type":1,"pageTitle":"WebRTC","url":"/jellyfish-docs/getting_started/peers/webrtc#example-docker-commands","content":"Explicit port exposure (macOS compatible) docker run -p 50000-50050:50000-50050/udp \\ -p 4000:4000/tcp \\ -e WEBRTC_USED=true \\ -e INTEGRATED_TURN_PORT_RANGE=50000-50050 \\ -e INTEGRATED_TURN_IP=192.168.0.1 \\ -e SERVER_API_TOKEN=token \\ -e VIRTUAL_HOST=localhost \\ -e SECRET_KEY_BASE=secret \\ ghcr.io/jellyfish-dev/jellyfish:latest  caution Make sure that the exposed UDP ports match INTEGRATED_TURN_PORT_RANGE. The range of the ports shouldn't be too wide as it might cause problems with container startup. Using host network (Linux only) docker run --network=host \\ -e WEBRTC_USED=true \\ -e INTEGRATED_TURN_IP=192.168.0.1 \\ -e SERVER_API_TOKEN=token \\ -e VIRTUAL_HOST=localhost \\ -e SECRET_KEY_BASE=secret \\ ghcr.io/jellyfish-dev/jellyfish:latest  "},{"title":"Basic Concepts","type":0,"sectionRef":"#","url":"/jellyfish-docs/introduction/basic_concepts","content":"","keywords":""},{"title":"Room​","type":1,"pageTitle":"Basic Concepts","url":"/jellyfish-docs/introduction/basic_concepts#room","content":"In Jellyfish, a room serves as a holder for peers and components, its function varying based on application. For instance, within a video conferencing system, a Jellyfish room represents a single online meeting or a channel accommodating multiple users for conversation. On the other hand, in a broadcasting system setting, one room will be a container for two components - one responsible for receiving stream from a streaming host (e.g. via RTMP) and the other one responsible for converting this stream into an HLS playlist ready to be broadcasted via CDN. "},{"title":"Component​","type":1,"pageTitle":"Basic Concepts","url":"/jellyfish-docs/introduction/basic_concepts#component","content":"A component is a server-side process that publishes or subscribes to tracks. Example components are: HLS component - subscribes to all other tracks and creates from them an HLS playlist ready to be broadcasted via CDNRTSP component - connects to the remote media source (e.g. an IP camera) and publishes its media to be consumed by other components or peers "},{"title":"Peer​","type":1,"pageTitle":"Basic Concepts","url":"/jellyfish-docs/introduction/basic_concepts#peer","content":"A peer is a client-side entity that connects to the server to publish, subscribe or publish and subscribe to tracks published by components or other peers. The peer's process is spawned after the peer connects to the server. At the moment, there is only one type of peer - WebRTC. "},{"title":"Difference between Component and Peer​","type":1,"pageTitle":"Basic Concepts","url":"/jellyfish-docs/introduction/basic_concepts#difference-between-component-and-peer","content":"The most important difference between a component and a peer is that component is a purely server-side thing. It starts its work right after adding it to the server. On the other hand, a peer is something that has to connect to the server. Therefore, peers are allowed to open so-called signaling channels to the server. See also Example Scenarios. "},{"title":"Example Scenarios","type":0,"sectionRef":"#","url":"/jellyfish-docs/introduction/example_scenarios","content":"","keywords":""},{"title":"Real-time video conferencing system​","type":1,"pageTitle":"Example Scenarios","url":"/jellyfish-docs/introduction/example_scenarios#real-time-video-conferencing-system","content":"In this scenario, we want to create a simple video conferencing system where people can talk to each other in the real-time. Because of interactive and real-time requirements, the natural choice is to use the WebRTC standard. The final architecture would look like this:   "},{"title":"Broadcasting system with the real-time mixin​","type":1,"pageTitle":"Example Scenarios","url":"/jellyfish-docs/introduction/example_scenarios#broadcasting-system-with-the-real-time-mixin","content":"In this scenario, we want to create a broadcasting solution where the conversation between multiple people is broadcasted to the broader audience. Here, we choose WebRTC as a standard used for connecting people talking to each other in real-time and HLS for creating a playlist that can be then uploaded to CDN and broadcasted to the broader audience. As you can see, the whole system will automatically adapt to the number of participants talking in real-time. In particular, Jellyfish will handle a scenario with only one streamer out of the box.   "},{"title":"Displaying IP camera streams in a web browser​","type":1,"pageTitle":"Example Scenarios","url":"/jellyfish-docs/introduction/example_scenarios#displaying-ip-camera-streams-in-a-web-browser","content":"In this scenario, we have a set of IP cameras and we want to display their streams in a web browser. IP cameras very often use RTSP for streaming media but browsers don't ship with support for this protocol. Therefore, to display audio and video in a web browser, we have to use either WebRTC or HLS. Because, in this scenario, the delay is not the most crucial thing, we choose HLS. The most important thing here is that the RTSP component connects to the IP camera and then the camera starts streaming. It's not the camera that initializes the connection to the server. Therefore, the RTSP component is a purely server-side thing - once you add it, it should be able to work on its own.   "},{"title":"SDKs","type":0,"sectionRef":"#","url":"/jellyfish-docs/getting_started/sdks","content":"","keywords":""},{"title":"Server SDKs​","type":1,"pageTitle":"SDKs","url":"/jellyfish-docs/getting_started/sdks#server-sdks","content":"Elixir "},{"title":"Client SDKs​","type":1,"pageTitle":"SDKs","url":"/jellyfish-docs/getting_started/sdks#client-sdks","content":"ReactTypeScriptIOSAndroidReact Native "},{"title":"Metrics","type":0,"sectionRef":"#","url":"/jellyfish-docs/metrics","content":"Metrics Jellyfish exports several metrics in the Prometheus format. They are available on port 9568 at /metrics. Name\tLabels\tDescriptionjellyfish_traffic_ingress_total_bytes Total traffic received jellyfish_traffic_ingress_throughput_bytes_per_second Current throughput for received traffic jellyfish_traffic_egress_total_bytes Total traffic sent jellyfish_traffic_egress_throughput_bytes_per_second Current throughput for sent traffic jellyfish_rooms Amount of rooms currently present in Jellyfish jellyfish_room_peers\troom_id\tAmount of peers currently present in a given room jellyfish_room_peer_time_total_seconds\troom_id\tTotal peer time accumulated for a given room The default metrics from Phoenix and Erlang VM are exported as well. For description of these metrics, refer here (Phoenix)and here (VM).","keywords":""}]