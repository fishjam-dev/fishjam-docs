"use strict";(self.webpackChunkfishjam_docs=self.webpackChunkfishjam_docs||[]).push([[329],{73988:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>a,toc:()=>d});var i=s(74848),t=s(28453);const r={},o="Cluster",a={id:"cluster",title:"Cluster",description:"Fishjam comes with a built-in clustering mechanism.",source:"@site/docs/cluster.md",sourceDirName:".",slug:"/cluster",permalink:"/fishjam-docs/next/cluster",draft:!1,unlisted:!1,editUrl:"https://github.com/fishjam-dev/fishjam-docs/docs/cluster.md",tags:[],version:"current",frontMatter:{},sidebar:"mainSidebar",previous:{title:"Server SDK Examples",permalink:"/fishjam-docs/next/tutorials/server_sdk_examples"},next:{title:"Cloud VPS with cloud-init",permalink:"/fishjam-docs/next/deploying/vps"}},l={},d=[{value:"Strategies",id:"strategies",level:2},{value:"NODES_LIST",id:"nodes_list",level:2},{value:"Running from source",id:"running-from-source",level:3},{value:"Running with Docker (locally)",id:"running-with-docker-locally",level:3},{value:"Running with Docker (globally)",id:"running-with-docker-globally",level:3},{value:"DNS",id:"dns",level:2},{value:"Running with Docker",id:"running-with-docker",level:3},{value:"Verifying that a cluster has been created",id:"verifying-that-a-cluster-has-been-created",level:2},{value:"Deeper dive into Erlang Distribution",id:"deeper-dive-into-erlang-distribution",level:2}];function c(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"cluster",children:"Cluster"}),"\n",(0,i.jsxs)(n.p,{children:["Fishjam comes with a built-in clustering mechanism.\nBy a cluster, we mean a set of connected Fishjam instances.\nWhenever a new request for creating a room is sent to one of Fishjams in a cluster, this Fishjam\ncommunicates with all other nodes and creates a room on the node with the lowest load.\nIn response, a Fishjam address (specified with ",(0,i.jsx)(n.code,{children:"FJ_HOST"})," environment variable) where the room was created is returned."]}),"\n",(0,i.jsx)(n.admonition,{type:"info",children:(0,i.jsx)(n.p,{children:"Even when running a cluster of Fishjams, a room still has to fit into one Fishjam.\nCurrently, Fishjam doesn't offer an option to split a room across multiple machines."})}),"\n",(0,i.jsx)(n.admonition,{title:"Security",type:"warning",children:(0,i.jsx)(n.p,{children:"Fishjam distribution is not encrypted meaning that data between Fishjams is sent as plain text.\nCookie does not provide any cryptographic security.\nDo run a cluster only across machines in the same network!"})}),"\n",(0,i.jsx)(n.admonition,{title:"Distribution Environment Variables",type:"tip",children:(0,i.jsxs)(n.p,{children:["List of all cluster-related environment variables is available ",(0,i.jsx)(n.a,{href:"./getting_started/installation#distribution",children:"here"}),"."]})}),"\n",(0,i.jsx)("a",{id:"extra-network-configuration"}),"\n",(0,i.jsxs)(n.admonition,{title:"Extra network Configuration",type:"caution",children:[(0,i.jsx)(n.p,{children:"Fishjam leverages Erlang Distribution to form a cluster.\nThis means that we don't need to use any database where we would store\ninformation about network topology.\nInstead, some extra network configuration might be needed."}),(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Fishjam in distributed mode uses a service called EPMD (Erlang Port Mapper Deamon)\nthat runs on port ",(0,i.jsx)(n.code,{children:"4369"})," (TCP).\nIf you run Fishjam using Docker, you have to explicitly export this port.\nIn production deployment, you also have to allow for traffic on this port in your firewall.\nEPMD is started automatically when running Fishjam, so you don't need to take\nany extra steps to make it work."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Fishjam uses a random port for connecting to other Fishjams.\nIf you run Fishjam using Docker, this port defaults to ",(0,i.jsx)(n.code,{children:"9000"})," (TCP) but you can configure\nthe range it is selected from with ",(0,i.jsx)(n.code,{children:"FJ_DIST_MIN_PORT"})," and ",(0,i.jsx)(n.code,{children:"FJ_DIST_MAX_PORT"}),".\nNote that ",(0,i.jsx)(n.code,{children:"FJ_DIST_MIN_PORT"})," and ",(0,i.jsx)(n.code,{children:"FJ_DIST_MAX_PORT"})," are not available when running from source\n(using ",(0,i.jsx)(n.code,{children:"mix phx.server"}),") as in development you don't have to worry about the port used for\nforming a cluster.\nAs in the case of EPMD, in production deployment, you have to modify your firewall rules appropriately."]}),"\n"]}),"\n"]}),(0,i.jsxs)(n.p,{children:["See ",(0,i.jsx)(n.a,{href:"#deeper-dive-into-erlang-distribution",children:"Deeper dive into Erlang Distribution"})," for more information."]})]}),"\n",(0,i.jsx)(n.h2,{id:"strategies",children:"Strategies"}),"\n",(0,i.jsxs)(n.p,{children:["Currently, Fishjam supports two clustering strategies: ",(0,i.jsx)(n.code,{children:"NODES_LIST"})," and ",(0,i.jsx)(n.code,{children:"DNS"}),", but other strategies\nmight be added in the future."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"NODES_LIST"})," - form a cluster basing on a list of Fishjam addresses"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"DNS"})," - regularly query DNS to discover other Fishjams"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Regardless of the strategy, Erlang Distribution is transitive.\nWhen node A connects to node B, it also connects to all other nodes that node B is connected to."}),"\n",(0,i.jsx)(n.h2,{id:"nodes_list",children:"NODES_LIST"}),"\n",(0,i.jsxs)(n.p,{children:["To form a cluster using ",(0,i.jsx)(n.code,{children:"NODES_LIST"})," strategy:"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["Enable distribution mode with ",(0,i.jsx)(n.code,{children:"FJ_DIST_ENABLED=true"})]}),"\n",(0,i.jsxs)(n.li,{children:["Give your node a name with ",(0,i.jsx)(n.code,{children:"FJ_DIST_NODE_NAME"})]}),"\n",(0,i.jsxs)(n.li,{children:["Specify a list of nodes to connect to with ",(0,i.jsx)(n.code,{children:"FJ_DIST_NODES"})]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"running-from-source",children:"Running from source"}),"\n",(0,i.jsx)(n.p,{children:"Run the first Fishjam:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sh",children:"FJ_DIST_ENABLED=true FJ_DIST_NODE_NAME=f1@localhost mix phx.server\n"})}),"\n",(0,i.jsx)(n.p,{children:"Run the second Fishjam"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sh",children:'FJ_DIST_ENABLED=true FJ_DIST_NODE_NAME=f2@localhost FJ_DIST_NODES="f1@localhost" FJ_PORT=4002 FJ_METRICS_PORT=9468 mix phx.server\n'})}),"\n",(0,i.jsx)(n.admonition,{type:"info",children:(0,i.jsx)(n.p,{children:"Note that when running the second Fishjam, we had to change its HTTP and metrics ports."})}),"\n",(0,i.jsx)(n.h3,{id:"running-with-docker-locally",children:"Running with Docker (locally)"}),"\n",(0,i.jsx)(n.p,{children:"This simple docker compose file sets a cluster of two Fishjams."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yml",children:'version: "3"\n\nx-fishjam-template: &fishjam-template\n  build: .\n  environment: &fishjam-environment\n    FJ_SERVER_API_TOKEN: "development"\n    FJ_DIST_ENABLED: "true"\n    FJ_DIST_NODES: "f1@fishjam1 f2@fishjam2"\n  restart: on-failure\n\nservices:\n  fishjam1:\n    <<: *fishjam-template\n    environment:\n      <<: *fishjam-environment\n      FJ_HOST: "localhost:5001"\n      FJ_PORT: 5001\n      FJ_METRICS_PORT: 6001\n      FJ_DIST_NODE_NAME: f1@fishjam1\n    ports:\n      - 5001:5001\n      - 6001:6001\n\n  fishjam2:\n    <<: *fishjam-template\n    environment:\n      <<: *fishjam-environment\n      FJ_HOST: "localhost:5002"\n      FJ_PORT: 5002\n      FJ_METRICS_PORT: 6002\n      FJ_DIST_NODE_NAME: f2@fishjam2\n    ports:\n      - 5002:5002\n      - 6002:6002\n'})}),"\n",(0,i.jsx)(n.p,{children:"Because we run Fishjams in the same Docker network:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["we can use ",(0,i.jsx)(n.code,{children:'FJ_DIST_NODE: "sname"'}),", which allows\nus to reference Fishjams using their service names so\n",(0,i.jsx)(n.code,{children:"fishjam1"})," and ",(0,i.jsx)(n.code,{children:"fishjam2"})]}),"\n",(0,i.jsxs)(n.li,{children:["we don't need to export EPMD (",(0,i.jsx)(n.code,{children:"4369"}),") or distribution (",(0,i.jsx)(n.code,{children:"9000"}),")\nports"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"running-with-docker-globally",children:"Running with Docker (globally)"}),"\n",(0,i.jsx)(n.p,{children:"When forming a cluster across multiple machines:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["you have to take care of ",(0,i.jsx)(n.a,{href:"#extra-network-configuration",children:"Extra Network Configuration"})]}),"\n",(0,i.jsxs)(n.li,{children:["you also can't use ",(0,i.jsx)(n.code,{children:'FJ_DIST_MODE="sname"'})," as you have to name Fishjam nodes using their publicly available IP address\nor domain names (see ",(0,i.jsx)(n.code,{children:"FJ_DIST_NODE_NAME"})," and ",(0,i.jsx)(n.code,{children:"FJ_DIST_MODE"}),")"]}),"\n",(0,i.jsxs)(n.li,{children:["you can't simulate this setup locally as you won't be able to expose two EMPD ports on the same machine.\nSee ",(0,i.jsx)(n.a,{href:"#deeper-dive-into-erlang-distribution",children:"Deeper dive into Erlang Distribution"})," for more information."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["See our ",(0,i.jsx)(n.a,{href:"https://github.com/fishjam-dev/fishjam_videoroom/blob/main/docker-compose-deploy.yaml",children:"Fishjam Videoroom deployment configuration"})," for an example."]}),"\n",(0,i.jsx)(n.h2,{id:"dns",children:"DNS"}),"\n",(0,i.jsxs)(n.p,{children:["To form a cluster using ",(0,i.jsx)(n.code,{children:"DNS"})," strategy:"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["Enable distribution mode with ",(0,i.jsx)(n.code,{children:"FJ_DIST_ENABLED=true"})]}),"\n",(0,i.jsxs)(n.li,{children:["Chose ",(0,i.jsx)(n.code,{children:"DNS"})," strategy with ",(0,i.jsx)(n.code,{children:"FJ_DIST_STRATEGY_NAME"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["Set ",(0,i.jsx)(n.code,{children:"FJ_DIST_MODE"})," to ",(0,i.jsx)(n.code,{children:"name"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["Give your node a name with ",(0,i.jsx)(n.code,{children:"FJ_DIST_NODE_NAME"}),".",(0,i.jsx)("br",{}),"\n",(0,i.jsx)(n.strong,{children:"Important"})," It has to be in the form of ",(0,i.jsx)(n.code,{children:"<nodename>@<hostname>"}),"\nwhere all Fishjams MUST have the same ",(0,i.jsx)(n.code,{children:"<nodename>"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["Specify a query under which Fishjams are register in DNS with ",(0,i.jsx)(n.code,{children:"FJ_DIST_QUERY"}),". ",(0,i.jsx)("br",{}),"\n",(0,i.jsx)(n.strong,{children:"Important"})," Fishjam does not register itself in DNS.\nIt is user responsibility to enusre that your Fishjam is registered in DNS under ",(0,i.jsx)(n.code,{children:"FJ_DIST_QUERY"}),"."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"running-with-docker",children:"Running with Docker"}),"\n",(0,i.jsx)(n.p,{children:"This simple docker compose file sets a cluster of two Fishjams using internal Docker DNS."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yml",children:'version: "3"\nx-fishjam-template: &fishjam-template\n  build: .\n  environment: &fishjam-environment\n    FJ_SERVER_API_TOKEN: "development"\n    FJ_DIST_ENABLED: "true"\n    FJ_DIST_STRATEGY_NAME: "DNS"\n    FJ_DIST_MODE: "name"\n  restart: on-failure\nservices:\n  app1:\n    <<: *fishjam-template\n    environment:\n      <<: *fishjam-environment\n      FJ_HOST: "localhost:4001"\n      FJ_PORT: 4001\n      FJ_DIST_QUERY: app.dns-network\n    ports:\n      - 4001:4001\n    networks:\n      default:\n        aliases:\n          - app.dns-network\n\n  app2:\n    <<: *fishjam-template\n    environment:\n      <<: *fishjam-environment\n      FJ_HOST: "localhost:4002"\n      FJ_PORT: 4002\n      FJ_DIST_QUERY: app.dns-network\n    ports:\n      - 4002:4002\n    networks:\n      default:\n        aliases:\n          - app.dns-network\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Because we run Fishjams in the same Docker network we don't need to export EPMD (",(0,i.jsx)(n.code,{children:"4369"}),") or distribution (",(0,i.jsx)(n.code,{children:"9000"}),")\nports.\nWe also didn't have to explicitly set ",(0,i.jsx)(n.code,{children:"FJ_DIST_NODE_NAME"}),".\nThe default value (",(0,i.jsx)(n.code,{children:"fishjam@(hostname)"}),") is automatically resolved to ",(0,i.jsx)(n.code,{children:"fishjam@<ip_address>"}),"\nand is routable from other nodes in the docker network."]}),"\n",(0,i.jsx)(n.h2,{id:"verifying-that-a-cluster-has-been-created",children:"Verifying that a cluster has been created"}),"\n",(0,i.jsx)(n.p,{children:"When a cluster is created correctly you will see a log indicating that one of your Fishjams connected to the other one, e.g.:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'[info] [libcluster:epmd_cluster] connected to :"f1@127.0.0.1"\n'})}),"\n",(0,i.jsx)(n.p,{children:"To see clustering in action, create two rooms using the same Fishjam address and observe how they are load balanced:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'curl -X POST -H "authorization: Bearer development" http://localhost:4002/room\n# {"data":{"fishjam_address":"localhost:4001"}}\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'curl -X POST -H "authorization: Bearer development" http://localhost:4002/room\n# {"data":{"fishjam_address":"localhost:4002"}}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Load balancing can also be tested using ",(0,i.jsx)(n.a,{href:"https://github.com/fishjam-dev/fishjam-dashboard",children:"Fishjam Dashboard"}),".\nSee ",(0,i.jsx)(n.a,{href:"./tutorials/dashboard#loadbalancing-in-dashboard",children:"here"})," for more information."]}),"\n",(0,i.jsx)(n.h2,{id:"deeper-dive-into-erlang-distribution",children:"Deeper dive into Erlang Distribution"}),"\n",(0,i.jsxs)(n.p,{children:["The most tricky thing when running Fishjam in a cluster is to understand the role of EPMD.\nEPMD is responsible for mapping node names to ports they use.\nNode names consist of two parts ",(0,i.jsx)(n.code,{children:"nodename@hostname"}),".\n",(0,i.jsx)(n.code,{children:"hostname"})," identifies a host machine, and ",(0,i.jsx)(n.code,{children:"nodename"})," identifies a node on this machine.\nWhen node A wants to connect to node B, it uses node's B name to ask EPMD (running on node B)\nfor the actual port node B is accessible on."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Example"})}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["Let's assume that node's B name is ",(0,i.jsx)(n.code,{children:"nodeb@192.168.1.2"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["Node A will contact EPMD using ",(0,i.jsx)(n.code,{children:"192.168.1.2"})," IP address and port ",(0,i.jsx)(n.code,{children:"4369"}),", and ask for the\nport number used by a node with the name ",(0,i.jsx)(n.code,{children:"nodeb"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["After that, node A can contact node B using ",(0,i.jsx)(n.code,{children:"192.168.1.2"})," IP address and port returned by EPMD."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"A couple of notes about EPMD:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["it always uses port ",(0,i.jsx)(n.code,{children:"4369"})," (TCP)"]}),"\n",(0,i.jsx)(n.li,{children:"it is started automatically when running Fishjam"}),"\n",(0,i.jsx)(n.li,{children:"there is one EPMD per machine or one EPMD per docker container -\nthat's why we can't simulate Global Docker setup locally"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["You can read more about Erlang Distribution ",(0,i.jsx)(n.a,{href:"https://www.erlang.org/doc/reference_manual/distributed.html",children:"here"}),"."]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},28453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>a});var i=s(96540);const t={},r=i.createContext(t);function o(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);