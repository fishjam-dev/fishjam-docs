[{"title":"What is Jellyfish?","type":0,"sectionRef":"#","url":"/jellyfish-docs/0.2.0","content":"","keywords":""},{"title":"Supported protocols​","type":1,"pageTitle":"What is Jellyfish?","url":"/jellyfish-docs/0.2.0#supported-protocols","content":"Jellyfish supports following protocols: WebRTC - used for creating real-time video conferencing systemsHLS - allows for implementing broadcasting solutionsRTSP - very often used for consuming streams from IP cameras "},{"title":"Cluster","type":0,"sectionRef":"#","url":"/jellyfish-docs/0.2.0/cluster","content":"","keywords":""},{"title":"Configuring a Cluster​","type":1,"pageTitle":"Cluster","url":"/jellyfish-docs/0.2.0/cluster#configuring-a-cluster","content":"Jellyfish cluster can be created in 4 simple steps: Enable distribution mode with JF_DIST_ENABLED=trueGive your node a name with JF_DIST_NODE_NAMESpecify a list of nodes to connect to with JF_DIST_NODESConfigure HTTP and metrics ports so they don't overlap with other nodes. You can do this with JF_PORT and JF_METRICS_PORT environment variables. Distribution Environment Variables List of all cluster-related environment variables is available here. Security Currently, Jellyfish distribution is not encrypted meaning that data between Jellyfishes is sent as plain text. Cookie does not provide any cryptographic security. Do run a cluster only across machines in the same network! Extra network Configuration Jellyfish leverages Erlang Distribution to form a cluster. This means that we don't need to use any database where we would store information about network topology. Instead, some extra network configuration might be needed. Jellyfish uses a service called EPMD (Erlang Port Mapper Deamon) that runs on port 4369 (TCP). If you run Jellyfish using Docker, you have to explicitly export this port. In production deployment, you also have to allow for traffic on this port in your firewall. EPMD is started automatically when running Jellyfish, so you don't need to take any extra steps to make it work. Jellyfish uses a random port for connecting to other Jellyfishes. If you run Jellyfish using Docker, this port defaults to 9000 (TCP) but you can configure the range it is selected from with JF_DIST_MIN_PORT and JF_DIST_MAX_PORT. Note that JF_DIST_MIN_PORT and JF_DIST_MAX_PORT are not available when running from source (using mix phx.server) as in development you don't have to worry about the port used for forming a cluster. As in the case of EPMD, in production deployment, you have to modify your firewall rules appropriately. See Deeper dive into Erlang Distribution for more information. "},{"title":"Examples​","type":1,"pageTitle":"Cluster","url":"/jellyfish-docs/0.2.0/cluster#examples","content":""},{"title":"Running from source​","type":1,"pageTitle":"Cluster","url":"/jellyfish-docs/0.2.0/cluster#running-from-source","content":"Run the first Jellyfish: JF_DIST_ENABLED=true JF_DIST_NODE_NAME=j1@127.0.0.1 mix phx.server  Run the second Jellyfish JF_DIST_ENABLED=true JF_DIST_NODE_NAME=j2@127.0.0.1 JF_DIST_NODES=&quot;j1@127.0.0.1&quot; JF_PORT=4002 JF_METRICS_PORT=9468 mix phx.server  info Note that when running the second Jellyfish, we had to change its HTTP and metrics ports. "},{"title":"Running with Docker (locally)​","type":1,"pageTitle":"Cluster","url":"/jellyfish-docs/0.2.0/cluster#running-with-docker-locally","content":"This simple docker compose file sets a cluster of two Jellyfishes. version: &quot;3&quot; x-jellyfish-template: &amp;jellyfish-template build: . environment: &amp;jellyfish-environment JF_SERVER_API_TOKEN: &quot;development&quot; JF_DIST_ENABLED: &quot;true&quot; JF_DIST_MODE: &quot;sname&quot; JF_DIST_NODES: &quot;j1@jellyfish1 j2@jellyfish2&quot; restart: on-failure services: jellyfish1: &lt;&lt;: *jellyfish-template environment: &lt;&lt;: *jellyfish-environment JF_HOST: &quot;localhost:5001&quot; JF_PORT: 5001 JF_METRICS_PORT: 6001 JF_DIST_NODE_NAME: j1@jellyfish1 ports: - 5001:5001 - 6001:6001 jellyfish2: &lt;&lt;: *jellyfish-template environment: &lt;&lt;: *jellyfish-environment JF_HOST: &quot;localhost:5002&quot; JF_PORT: 5002 JF_METRICS_PORT: 6002 JF_DIST_NODE_NAME: j2@jellyfish2 ports: - 5002:5002 - 6002:6002  Because we run Jellyfishes in the same Docker network: we can use JF_DIST_NODE: &quot;sname&quot;, which allows us to reference Jellyfishes using their service names sojellyfish1 and jellyfish2we don't need to export EPMD (4369) or distribution (9000) ports "},{"title":"Running with Docker (globally)​","type":1,"pageTitle":"Cluster","url":"/jellyfish-docs/0.2.0/cluster#running-with-docker-globally","content":"When forming a cluster across multiple machines: you have to take care of Extra Network Configurationyou also can't use JF_DIST_MODE=&quot;sname&quot; as you have to name Jellyfish nodes using their publicly available IP address or domain names (see JF_DIST_NODE_NAME and JF_DIST_MODE)you can't simulate this setup locally as you won't be able to expose two EMPD ports on the same machine. See Deeper dive into Erlang Distribution for more information. See our Jellyfish Videoroom deployment configuration for an example. "},{"title":"Verifying that a cluster has been created​","type":1,"pageTitle":"Cluster","url":"/jellyfish-docs/0.2.0/cluster#verifying-that-a-cluster-has-been-created","content":"When a cluster is created correctly you will see a log indicating that one of your Jellyfishes connected to the other one, e.g.: [info] [libcluster:epmd_cluster] connected to :&quot;j1@127.0.0.1&quot;  To see clustering in action, create two rooms using the same Jellyfish address and observe how they are load balanced: curl -X POST -H &quot;authorization: Bearer development&quot; http://localhost:4002/room # {&quot;data&quot;:{&quot;jellyfish_address&quot;:&quot;localhost:4001&quot;}}  curl -X POST -H &quot;authorization: Bearer development&quot; http://localhost:4002/room # {&quot;data&quot;:{&quot;jellyfish_address&quot;:&quot;localhost:4002&quot;}}  Load balancing can also be tested using Jellyfish Dashboard. See here for more information. "},{"title":"Deeper dive into Erlang Distribution​","type":1,"pageTitle":"Cluster","url":"/jellyfish-docs/0.2.0/cluster#deeper-dive-into-erlang-distribution","content":"The most tricky thing when running Jellyfish in a cluster is to understand the role of EPMD. EPMD is responsible for mapping node names to ports they use. Node names consist of two parts nodename@hostname.hostname identifies a host machine, and nodename identifies a node on this machine. When node A wants to connect to node B, it uses node's B name to ask EPMD (running on node B) for the actual port node B is accessible on. Example Let's assume that node's B name is nodeb@192.168.1.2.Node A will contact EPMD using 192.168.1.2 IP address and port 4369, and ask for the port number used by a node with the name nodeb.After that, node A can contact node B using 192.168.1.2 IP address and port returned by EPMD. A couple of notes about EPMD: it always uses port 4369 (TCP)it is started automatically when running Jellyfishthere is one EPMD per machine or one EPMD per docker container - that's why we can't simulate Global Docker setup locally You can read more about Erlang Distribution here. "},{"title":"Fly.io (experimental)","type":0,"sectionRef":"#","url":"/jellyfish-docs/0.2.0/deploying/fly_io","content":"","keywords":""},{"title":"Creating new app​","type":1,"pageTitle":"Fly.io (experimental)","url":"/jellyfish-docs/0.2.0/deploying/fly_io#creating-new-app","content":"Launch fly launch. When prompted, copy the configuration from the existing fly.toml file. Select appropriate app name and region, don't create any databases. Don't deploy the app just yet. Running fly launch may modify the Dockerfile. Make sure to remove the lines appended by flyctl. "},{"title":"Configuring the App​","type":1,"pageTitle":"Fly.io (experimental)","url":"/jellyfish-docs/0.2.0/deploying/fly_io#configuring-the-app","content":"Before deploying your app, make sure it is correctly configured. "},{"title":"Dedicated IPv4​","type":1,"pageTitle":"Fly.io (experimental)","url":"/jellyfish-docs/0.2.0/deploying/fly_io#dedicated-ipv4","content":"In order to transmit multimedia via UDP, the app has to be publicly available with an IPv4 address. By default Fly.io uses shared IP. To enable dedicated IPv4 address run fly ips allocate-v4  Note, that dedicated IP address is a paid feature on Fly.io. You can learn more about dedicated IPv4 address here. "},{"title":"fly.toml​","type":1,"pageTitle":"Fly.io (experimental)","url":"/jellyfish-docs/0.2.0/deploying/fly_io#flytoml","content":"Make sure you don't have the following lines in the fly.toml, which are automatically generated by fly launch. You don't need to run migrations, since you don't have a database. [deploy] release_command = &quot;/app/bin/migrate&quot;  Jellyfish uses JF_HOST variable instead of the default PHX_HOST. JF_HOST = &quot;&lt;YOUR APP HOSTNAME&gt;&quot;  Also, make sure you have set the correct port. The environment variable JF_PORT has to match the TCP internal_port defined under services section. The default for Jellyfish is 5002 in development and 8080 in production (when using Docker or mix release). To be able to receive and send UDP traffic, Jellyfish has to open its UDP ports on a special fly-global-services address, not 0.0.0.0. This must be set using the JF_WEBRTC_TURN_LISTEN_IP enviroment variable. You also need to specify the Jellyfish IP address for UDP, it is the IP address which you generated in the previous step. JF_WEBRTC_TURN_LISTEN_IP = &quot;fly-global-services&quot; JF_WEBRTC_TURN_IP=&quot;&lt;YOUR APP IP ADDRESS&gt;&quot;  You can also read tutorial for running Fly.io apps which use UDP. "},{"title":"Fly.io secrets​","type":1,"pageTitle":"Fly.io (experimental)","url":"/jellyfish-docs/0.2.0/deploying/fly_io#flyio-secrets","content":"There are environment variables, which you may not want to keep in the fly.toml config. Fly.io provides a way to store such values securely. For Jellyfish you need to configure just one secret - JF_SERVER_API_TOKEN. flyctl secrets set JF_SERVER_API_TOKEN=development  "},{"title":"Deploying​","type":1,"pageTitle":"Fly.io (experimental)","url":"/jellyfish-docs/0.2.0/deploying/fly_io#deploying","content":"With everything configured you can deploy the app fly deploy  Note that it may take a moment for the UDP traffic to be forwarded to the application. This means for example, that WebRTC may not be working yet. This is the tricky part of the deployment, which we weren't able to entirely figure out. Sometimes the UDP just works, others it takes ages for it to start flowing.This topic describes the exact issue we had with Fly.io. In general, it is unclear when the UDP traffic starts to be forwarded, sometimes it happens relatively quickly after deployment, sometimes you need to wait for some time. Also, the Fly.io documentation isn't clear in regard to opening UDP sockets. Some information was gathered experimentally, or based on Fly.io community questions, such as this one. "},{"title":"Cloud VPS with cloud-init","type":0,"sectionRef":"#","url":"/jellyfish-docs/0.2.0/deploying/vps","content":"","keywords":""},{"title":"1. Creating primary IP​","type":1,"pageTitle":"Cloud VPS with cloud-init","url":"/jellyfish-docs/0.2.0/deploying/vps#1-creating-primary-ip","content":"Because configuring a server with cloud-init using our script requires you to have a registered domain pointing at a particular IP address, we divided the process of creating VPS into two parts: obtaining dedicated IP addressconfiguring the server using cloud-init Let's start with the first one. In Hetzner's project site go to the section Primary IPs then click Create Primary IP button. Choose a data center location for your server and select IPv4 protocol. You can also name that IP if you'd like. "},{"title":"2. Registering Domain​","type":1,"pageTitle":"Cloud VPS with cloud-init","url":"/jellyfish-docs/0.2.0/deploying/vps#2-registering-domain","content":"We'll not suggest you to use a specific domain provider, maybe you've got one chosen so we'll describe this step without details that may be different among providers. If you'd like, you can use Hetzner as well to register a domain. After registering your domain go to the DNS Records Table of your provider and create an A record pointing to the IP you've created in the previous step. "},{"title":"3. Choosing the right VPS​","type":1,"pageTitle":"Cloud VPS with cloud-init","url":"/jellyfish-docs/0.2.0/deploying/vps#3-choosing-the-right-vps","content":"Now let's go back to the Hetzner project site. It's time to choose and configure a server for Jellyfish. Although Jellyfish doesn't have minimum requirements to work, we encourage you to choose a middle-sized VPS (at least 8 cores) as media processing is consuming quite a lot of CPU. Remember to choose a server located in the data center where you've created an IP address in the first step. For this tutorial, we decided on CPX21 from Hetzner Cloud running Ubuntu 22:  "},{"title":"4. Assigning Primary IP​","type":1,"pageTitle":"Cloud VPS with cloud-init","url":"/jellyfish-docs/0.2.0/deploying/vps#4-assigning-primary-ip","content":"Below the list of the VPS types there is a Networking section where your Primary IP from Step 1 is waiting to be used. Select it.  "},{"title":"5. Adding a cloud-init configuration​","type":1,"pageTitle":"Cloud VPS with cloud-init","url":"/jellyfish-docs/0.2.0/deploying/vps#5-adding-a-cloud-init-configuration","content":"To configure a server and install Jellyfish on it we're going to use cloud-init. It's a preinstalled tool that lets you set up a newly created server with a YAML config file. In the configuration you can create a user, choose packages to be installed, configure them, write or modify files and in our case finally run a docker container. Full documentation about keys you can use in a cloud-config file can be found in the official cloud-init documentation. "},{"title":"A cloud-config tempalte​","type":1,"pageTitle":"Cloud VPS with cloud-init","url":"/jellyfish-docs/0.2.0/deploying/vps#a-cloud-config-tempalte","content":"We prepared a template cloud-config that will configure your server and start a chosen version of Jellyfish: cloud-config.yaml #cloud-config users: - name: jellyfish groups: docker sudo: null shell: /bin/false no_create_home: true ssh_pwauth: false disable_root_opts: no-port-forwarding,no-agent-forwarding,no-X11-forwarding apt: sources: docker.list: source: &quot;deb [arch=amd64,arm64] https://download.docker.com/linux/ubuntu jammy stable&quot; keyid: 9DC858229FC7DD38854AE2D88D81803C0EBFCD88 packages: - ufw - fail2ban - gzip - containerd.io - docker-ce - docker-ce-cli - nginx - certbot write_files: - path: /opt/jellyfish/env-file defer: true owner: jellyfish:jellyfish runcmd: - export JELLYFISH_VERSION=0.2.0 - export JELLYFISH_DOMAIN=mydomain.example.com - export LETSENCRYPT_EMAIL=my@email.com - export SERVER_API_TOKEN=test_token - systemctl enable fail2ban - ufw default deny outgoing - ufw default deny incoming - ufw default deny routed - ufw allow in ssh - ufw allow out https - ufw allow out domain - ufw allow in 80/tcp - ufw allow in 443/tcp - ufw allow in 50000:500100/udp - ufw allow in 49999/tcp - ufw allow out 5002 - ufw allow out from any port 50000:50100 proto udp to any - ufw allow out 49999 proto tcp to any - ufw enable - service nginx stop - &quot;[ ! -f /etc/letsencrypt/live/$JELLYFISH_DOMAIN/cert.pem ] &amp;&amp; certbot certonly --standalone --noninteractive --agree-tos --email $LETSENCRYPT_EMAIL -d $JELLYFISH_DOMAIN&quot; - | cat &lt;&lt; EOF &gt; /etc/cron.d/cert_renew 0 4 * * * [jellyfish] certbot certonly --webroot -w /usr/share/nginx/html -d $JELLYFISH_DOMAIN --keep-until-expiring --quiet 5 4 * * * [jellyfish] service nginx reload EOF - | cat &lt;&lt; EOF &gt; /etc/nginx/sites-available/$JELLYFISH_DOMAIN server { server_name $JELLYFISH_DOMAIN; location / { proxy_pass http://localhost:5002; proxy_http_version 1.1; proxy_set_header Upgrade \\$http_upgrade; proxy_set_header Connection &quot;Upgrade&quot;; proxy_set_header Host \\$host; } listen [::]:443 ssl http2; # managed by Certbot listen 443 ssl http2; # managed by Certbot ssl_certificate /etc/letsencrypt/live/$JELLYFISH_DOMAIN/fullchain.pem; # managed by Certbot ssl_certificate_key /etc/letsencrypt/live/$JELLYFISH_DOMAIN/privkey.pem; # managed by Certbot } server { listen 80; listen [::]:80; server_name $JELLYFISH_DOMAIN; # Do not HTTPS redirect Let'sEncrypt ACME challenge location /.well-known/acme-challenge/ { auth_basic off; allow all; root /usr/share/nginx/html; try_files \\$uri =404; break; } location / { return 301 https://\\$host\\$request_uri; } } EOF - ln -sf /etc/nginx/sites-available/$JELLYFISH_DOMAIN /etc/nginx/sites-enabled/$JELLYFISH_DOMAIN - service nginx start - | cat &lt;&lt; EOF &gt; /opt/jellyfish/env-file JF_HOST=$JELLYFISH_DOMAIN JF_PORT=5002 JF_SERVER_API_TOKEN=$SERVER_API_TOKEN JF_CHECK_ORIGIN=false JF_WEBRTC_TURN_IP=$(ip route get 1.0.0.0 | sed -n 's/^.*src \\([0-9.]*\\) .*$/\\1/p') JF_WEBRTC_TURN_TCP_PORT=49999 JF_WEBRTC_TURN_PORT_RANGE=50000-50100 JF_WEBRTC_TURN_LISTEN_IP=0.0.0.0 EOF - [ su, jellyfish, -s, /bin/bash, -c, &quot;docker run -d \\ --restart unless-stopped \\ -p 50000-50100:50000-50100/udp \\ -p 5002:5002 \\ --env-file /opt/jellyfish/env-file \\ -v /opt/jellyfish/jellyfish_output:/app/jellyfish_output \\ ghcr.io/jellyfish-dev/jellyfish:$JELLYFISH_VERSION&quot;, ]  You'll need to manually take care of four lines in that template: - export JELLYFISH_VERSION=0.1.0-ed317bChange the value if you want to deploy a different version of Jellyfish. You can find the list of available versions in our package repository- export JELLYFISH_DOMAIN=mydomain.example.comEnter here a domain you've configured with A record in step 2.- export LETSENCRYPT_EMAIL=my@email.comEnter your email address to be notified when the SSL certificate will be about to expire.export SERVER_API_TOKEN=test_tokenServer API token is a token you'll need to connect to Jellyfish via API or SDK. Write here a chosen secret value you're going to remember later. Copy the file and change up those two variables. You're going to need the content of the file in the next section. "},{"title":"Other tools we'll install with cloud-init​","type":1,"pageTitle":"Cloud VPS with cloud-init","url":"/jellyfish-docs/0.2.0/deploying/vps#other-tools-well-install-with-cloud-init","content":"As you might noticed we've chosen some packages to be installed: ufw - Uncomplicated Firewall. We'll need it to allow or block traffic on specific ports https://help.ubuntu.com/community/UFW.fail2ban - Tool to block traffic recognized as unauthorized https://www.fail2ban.org/wiki/index.php/Main_Pagegzip - Compression Utility https://www.gzip.org/containerd.io, docker-ce, docker-ce-cli - Docker and Docker-related libraries. "},{"title":"Setting up Hetzner cloud VPS with cloud-config​","type":1,"pageTitle":"Cloud VPS with cloud-init","url":"/jellyfish-docs/0.2.0/deploying/vps#setting-up-hetzner-cloud-vps-with-cloud-config","content":"Now, we're going to use the content of the file you prepared in the Hetzner cloud VPS creating form. To do it scroll to the Cloud config section of the form and paste the content of your cloud-config.yaml file.  caution cloud-init will recognize the file as a configuration only if the file starts with that comment: #cloud-config ... So be careful while copying. That's it. You can click 'Create &amp; Buy' and the server will start to configure. tip Think about adding your public SSH key while creating a VPS instance. It will ease up connecting to VPS later. If you don't add any key you're going to need a root password (you'll receive it in an email after creating VPS) "},{"title":"6. Checking cloud-init status​","type":1,"pageTitle":"Cloud VPS with cloud-init","url":"/jellyfish-docs/0.2.0/deploying/vps#6-checking-cloud-init-status","content":"Configuring your server will take some time, but it's created almost immediately after creation. You can log into the server using ssh: ssh root@&lt;VPS_IP&gt;  then, in the server's terminal you can check the current status of cloud-init: cloud-init status  Possible responses are running, error and done. The first one informs you that cloud-init is still configuring your server. The second one means that something went wrong. You can find logs from the cloud-init run in /var/log/cloud-init-output.log file.done means that your jellyfish server is ready to be used. If you'd like to keep an eye on the cloud-init process you can use: cloud-init status --wait  To see the output when the process is finished (successfully or not). "},{"title":"Testing your instance with the Jellyfish dashboard​","type":1,"pageTitle":"Cloud VPS with cloud-init","url":"/jellyfish-docs/0.2.0/deploying/vps#testing-your-instance-with-the-jellyfish-dashboard","content":"To see how (or if) your Jellyfish server is working you can test it by connecting our Jellyfish Dashboard with your server. Detailed instructions on how to use Jellyfish Dashboard can be found here. "},{"title":"API Reference","type":0,"sectionRef":"#","url":"/jellyfish-docs/0.2.0/for_developers/api_reference","content":"API Reference Jellyfish API is composed of three layers a REST API for managing Jellyfish statea WS connection for client SDK communication (socket path /socket/peer)a WS connection for server notifications (socket path /socket/server) You can find them here: OpenAPI REST descriptionProtobufs used by peer WSProtobufs used by server WS The communication via WebSockets uses Protobuf format. The very first message that has to be sent on either of the WebSocket connections (peer to Jellyfish oryour_backend_server to Jellyfish) is AuthRequest. All supported messages are listed in the Jellyfish protos repo. If you want to create your own Jellyfish SDK, the easiest way to reference defined protobuf messages will be by adding protos to your git repository as a git submodule. You can do it with this command: git submodule add https://github.com/jellyfish-dev/protos You could also consider creating a script that will pull the newest changes from the git submodule and compile.proto files to your chosen programming language. For reference, see the script used in our Elixir SDK.","keywords":""},{"title":"Examples","type":0,"sectionRef":"#","url":"/jellyfish-docs/0.2.0/examples","content":"Examples Jellyfish usage examples utilising server SDKs can be found in the following locations: Elixir","keywords":""},{"title":"Design Docs","type":0,"sectionRef":"#","url":"/jellyfish-docs/0.2.0/for_developers/design_docs","content":"Design Docs Crucial parts of Jellyfish architecture are always discussed and written down in the form of design documents. Each design document describes, in a nutshell, a few possible solutions or approaches to some problem and states which solution was accepted and why. The list of Jellyfish Design Docs is available here.","keywords":""},{"title":"Architecture","type":0,"sectionRef":"#","url":"/jellyfish-docs/0.2.0/getting_started/architecture","content":"","keywords":""},{"title":"Server SDKs​","type":1,"pageTitle":"Architecture","url":"/jellyfish-docs/0.2.0/getting_started/architecture#server-sdks","content":"Server SDKs allow you to manage Jellyfish state. In particular, you can: authenticatecreate/delete roomsadd/remove peersadd/remove componentssubscribe for notifications Under the hood, Server SDKs just use Jellyfish REST and WS API, see Jellyfish API. tip As an example, you can use server SDK to introduce a time limit on meeting duration and shut down the room after it passes. "},{"title":"Client SDKs​","type":1,"pageTitle":"Architecture","url":"/jellyfish-docs/0.2.0/getting_started/architecture#client-sdks","content":"Client SDKs allow you to connect to Jellyfish to publish and consume tracks. In particular, you can: authenticatejoin specific roompublish audio and videoreceive audio and video from other peers and components At the moment, Jellyfish supports only one type of client - WebRTC. "},{"title":"Diagram​","type":1,"pageTitle":"Architecture","url":"/jellyfish-docs/0.2.0/getting_started/architecture#diagram","content":"The whole concept is presented in the following diagram.     Your Backend (BE) - serves your application frontend, and manages the database and application-specific logic. Jellyfish (JF) - Jellyfish media server. Manages media. Admin - someone who has special permission in your application - can create/delete rooms, add/remove peers, etc. User - someone who connects to Jellyfish to send and receive media. Everything starts with Admin who sends an HTTP request to BE to create a new room.BE uses jellyfish-server-sdk to communicate with JF and create the room. Under the hood, jellyfish-server-sdk uses REST API exposed by JF. After the room has been created, the Admin invites a user by sending a new HTTP request to BE. Again, BE uses jellyfish-server-sdk to add the new peer to JF. On the user side, they send a request to BE to join the room.BE replies with JF IP address it should connect to. Then, the User uses jellyfish-client-sdk to connect to JF. After the connection has been established, the User can send and receive media. "},{"title":"Authentication","type":0,"sectionRef":"#","url":"/jellyfish-docs/0.2.0/getting_started/authentication","content":"Authentication The Authentication mechanism is based on a bearer token. How does it work? Both Jellyfish and Business Logic are configured with the same secret. This secret is used for authorizing HTTP requests between them (via HTTP authorization request header). When a new client wants to join a room, Business Logic (assuming the client is authorized to join) requests adding a new peer and receives a token generated by Jellyfish. The token must then be passed to the client, that will use it to connect to the room as a new peer. The token encodes both peer and room IDs. The token exchange is handled by our Client SDKs when connecting. Under the hood, Jellyfish expects the token in the first message after opening the Web Socket connection. Token encodes peer id and room id. Run Jellyfish JF_SERVER_API_TOKEN=JF_SERVER_API_TOKEN mix phx.server Create a room and add one peer Business Logic client = Jellyfish.Client.new(&quot;http://address-of-your-server.com&quot;, &quot;JF_SERVER_API_TOKEN&quot;) {:ok, room, _jellyfish_address} = Jellyfish.Room.create(client, max_peers: 10) {:ok, peer, peer_token} = Jellyfish.Room.add_peer(client, room.id, &quot;BobId&quot;) Connect as a peer to Jellyfish Client client.connect({ token: peerToken, peerMetadata: { name: &quot;Bob&quot; }, isSimulcastOn: false }) ","keywords":""},{"title":"HLS","type":0,"sectionRef":"#","url":"/jellyfish-docs/0.2.0/getting_started/components/hls","content":"","keywords":""},{"title":"Compatibility​","type":1,"pageTitle":"HLS","url":"/jellyfish-docs/0.2.0/getting_started/components/hls#compatibility","content":"WebRTCRTSP "},{"title":"Requirements​","type":1,"pageTitle":"HLS","url":"/jellyfish-docs/0.2.0/getting_started/components/hls#requirements","content":"The Room in which the HLS component is created must have the video codec set to H264. See API for more information.Max 1 HLS component allowed per room. "},{"title":"Configuration options​","type":1,"pageTitle":"HLS","url":"/jellyfish-docs/0.2.0/getting_started/components/hls#configuration-options","content":"Optional lowLatency (boolean, default: false) - whether the component should use LL-HLS "},{"title":"Env variables​","type":1,"pageTitle":"HLS","url":"/jellyfish-docs/0.2.0/getting_started/components/hls#env-variables","content":"Currently, there are no environment variables related to this component. "},{"title":"Output​","type":1,"pageTitle":"HLS","url":"/jellyfish-docs/0.2.0/getting_started/components/hls#output","content":"After adding a WebRTC peer (and at least one track) or an RTSP component, the HLS stream will be available under http://&lt;jellyfish-address&gt;/hls/&lt;room_id&gt;/index.m3u8 (or https://, if using TLS). "},{"title":"Example Docker commands​","type":1,"pageTitle":"HLS","url":"/jellyfish-docs/0.2.0/getting_started/components/hls#example-docker-commands","content":"The HLS playlist will be created inside the Docker container. To access it from the host, you need to create a volume, e.g. by adding the option -v $(pwd)/jellyfish_output:/app/jellyfish_outputto your Docker command. Other than that, your Docker commands shouldn't be affected by adding this component. docker run -p 8080:8080/tcp \\ -e JF_SERVER_API_TOKEN=token \\ -e JF_HOST=localhost:8080 \\ -v $(pwd)/jellyfish_output:/app/jellyfish_output \\ ghcr.io/jellyfish-dev/jellyfish:0.2.0  "},{"title":"RTSP","type":0,"sectionRef":"#","url":"/jellyfish-docs/0.2.0/getting_started/components/rtsp","content":"","keywords":""},{"title":"Compatibility​","type":1,"pageTitle":"RTSP","url":"/jellyfish-docs/0.2.0/getting_started/components/rtsp#compatibility","content":"WebRTCHLS "},{"title":"Requirements​","type":1,"pageTitle":"RTSP","url":"/jellyfish-docs/0.2.0/getting_started/components/rtsp#requirements","content":"RTSP component always outputs H264 stream so if the Room in which the RTSP component is created enforces a video codec, it must be set to H264. See API for more information. "},{"title":"Configuration options​","type":1,"pageTitle":"RTSP","url":"/jellyfish-docs/0.2.0/getting_started/components/rtsp#configuration-options","content":"Required sourceUri (string) - URI of RTSP source stream, e.g. &quot;rtsp://mysite.net:554/stream&quot; Optional rtpPort (integer 1..65535, default: 20000) - Local port RTP stream will be received atreconnectDelay (integer 0.., default: 15000) - Delay (in ms) between successive reconnect attemptskeepAliveInterval (integer 0.., default: 15000) - Interval (in ms) in which keep-alive RTSP messages will be sent to the remote stream sourcepierceNat (boolean, default: true) - Whether to attempt to create client-side NAT binding by sending an empty datagram from client to source, after the completion of RTSP setup "},{"title":"Env variables​","type":1,"pageTitle":"RTSP","url":"/jellyfish-docs/0.2.0/getting_started/components/rtsp#env-variables","content":"Currently, there are no environment variables related to this component. "},{"title":"Example Docker commands​","type":1,"pageTitle":"RTSP","url":"/jellyfish-docs/0.2.0/getting_started/components/rtsp#example-docker-commands","content":"caution If the client is behind NAT, the option --network=host is necessary since Docker can change the source port of UDP packets for routing reasons, which breaks the pierceNat functionality. This means that users on macOS will most likely be unable to access any RTSP stream source outside of their network when running Jellyfish using Docker. If you're on macOS and want to receive RTSP streams from behind NAT, right now the only way is to build Jellyfish natively from source. Explicit port exposure (macOS compatible) docker run -p 20000:20000/udp \\ -p 8080:8080/tcp \\ -e JF_SERVER_API_TOKEN=token \\ -e JF_HOST=localhost:8080 \\ ghcr.io/jellyfish-dev/jellyfish:0.2.0  caution Make sure that the exposed UDP port matches the one used by the RTSP component (option rtpPort, default: 20000). If using multiple RTSP components, more ports will need to be exposed. Using host network (Linux only) docker run --network=host \\ -e JF_SERVER_API_TOKEN=token \\ -e JF_HOST=localhost:8080 \\ ghcr.io/jellyfish-dev/jellyfish:0.2.0  "},{"title":"Installation","type":0,"sectionRef":"#","url":"/jellyfish-docs/0.2.0/getting_started/installation","content":"","keywords":""},{"title":"Building from source​","type":1,"pageTitle":"Installation","url":"/jellyfish-docs/0.2.0/getting_started/installation#building-from-source","content":"Make sure to have both Elixir and Rust installed. Check the links below for instructions: ElixirRust Clone the Jellyfish repo git clone https://github.com/jellyfish-dev/jellyfish.git  Install native dependencies macOS IntelmacOS Apple SiliconUbuntu These instructions assume you have Homebrew installed. You can get it here. brew install srtp libnice clang-format ffmpeg opus pkg-config export LDFLAGS=&quot;-L/usr/local/opt/openssl@1.1/lib&quot; export CFLAGS=&quot;-I/usr/local/opt/openssl@1.1/include/&quot; export CPPFLAGS=&quot;-I/usr/local/opt/openssl@1.1/include/&quot; export PKG_CONFIG_PATH=&quot;/usr/local/opt/openssl@1.1/lib/pkgconfig&quot;  Install elixir dependencies mix deps.get  Run the server in development mix phx.server  Create a binary You can also create Jellyfish binary with: MIX_ENV=prod mix release  Then follow instructions printed in your terminal. info The difference between running with mix phx.server and generating target binary is that the latter is prepared for running in production so e.g. it includes some Erlang Virtual Machine tweaks. Jellyfish Dockerfile always uses mix release under the hood. "},{"title":"Running with Docker​","type":1,"pageTitle":"Installation","url":"/jellyfish-docs/0.2.0/getting_started/installation#running-with-docker","content":"Docker images are built for production which means that you always need to set a couple of environment variables. An example docker command running bare Jellyfish HTTP service locally: docker run -p 8080:8080/tcp -e JF_HOST=localhost:8080 JF_SERVER_API_TOKEN=token ghcr.io/jellyfish-dev/jellyfish:0.2.0  Note that in real case scenarios, docker commands depend on peers/components you are going to use. Therefore, we don't present them here but rather in each peer/component's documentation. As an example see WebRTC Peer. For the full list of Jellyfish Docker images, see this page. tip Instead of passing environmental variables manually, you can use the --env-file ./env-file flag, where the env-file is a file containing the variables that the image expects, see example file .env.sample in the Jellyfish repository. "},{"title":"Environment variables​","type":1,"pageTitle":"Installation","url":"/jellyfish-docs/0.2.0/getting_started/installation#environment-variables","content":"Environment variables are split into two groups: general ones - presented belowpeer/component-specific - each Peer and Component can expose its own environment variables. They are always listed in a Peer/Component description. See the list of Peers and Components. Below there are general, Jellyfish environment variables. If you are running Jellyfish in development, you don't need to set any of them. Required in production:​ JF_SERVER_API_TOKEN - token for authorizing HTTP requests. Defaults to development for development builds.JF_HOST - defines how Jellyfish should be seen from the outside. Defaults to JF_IP:JF_PORT. It can be in the form of ip:port, domain:port or simply domain. Useful when hosting Jellyfish behind proxy. It is returned e.g. when creating a new room. When running with Docker, JF_IP is set to 0.0.0.0making the default value of JF_HOST incorrect. Therefore, for Docker, you have to set JF_HOST manually. For running Docker locally, it can simply be localhost:8080. Optional:​ JF_IP - an ip address to run the HTTP server on. Defaults to 127.0.0.1 when running from source or using mix release, or 0.0.0.0 for Docker.JF_PORT - port to run the HTTP server on. Defaults to 5002 for development builds and 8080 for production builds (mix release or Docker).JF_SECRET_KEY_BASE - used to sign/encrypt tokens generated for Peers. Generated if not provided.JF_CHECK_ORIGIN - defines if Jellyfish will check origin of incoming requests and socket connection. Defaults to true. Can be true or false.JF_OUTPUT_BASE_PATH - a base path where Jellyfish will save its artifacts. Defaults to ./jellyfish_output/. When running via docker, the directory can be mounted as -v $(pwd)/host_directory:/app/jellyfish_output.JF_METRICS_IP - an IP address to run metrics endpoint on. Defaults to 127.0.0.1 when running from source or using mix release, or 0.0.0.0 for Docker.JF_METRICS_PORT - a port to run metrics endpoint on. Defaults to 9568.MIX_ENV - defines compilation environment. This variable takes effect only when running from the source. Docker images are always built with MIX_ENV=prod. Possible values are: dev - uses default values for environment variables (default option when running with mix phx.server)prod - requires that you provide values for environment variablestest - used in tests Distribution:​ JF_DIST_ENABLED - whether to run Jellyfish in a cluster. Defaults to false.JF_DIST_NODE_NAME - Node name used in a cluster. It consists of two parts - nodename@hostname. The first part identifies a node on a single machine and can be any string. The second part identifies the host machine and has to be an ip address or FQDN of a machine Jellyfish runs on. If you run a cluster on a single machine or in the same docker network and you don't want to use IP addresses or FQDN as hostnames, you can use short names (see JF_DIST_MODE).JF_DIST_MODE - distribution mode - can be name or sname. Defaults to name. When using name, your hostname has to be an IP address or FQDN of a machine Jellyfish runs on. When using sname, your hostname can be any string. See our docker-compose.yaml, which we use in our integration tests for an example.JF_DIST_COOKIE - used to group Jellyfishes in a cluster. Defaults to jellyfish_cookie. Use different cookies to create multiple clusters on the same machine. Important: cookie does not provide any cryptographic security. Its only purpose is to prevent a node from connecting to a cluster with which it is not intended to communicate.JF_DIST_NODES - space-separated list of other Jellyfishes to connect to. Defaults to &quot;&quot;. Example: JF_DIST_NODES=&quot;jellyfish1@127.0.0.1 jellyfish2@127.0.0.1&quot;. This list can also include ourselves so that you can pass the same value to every Jellyfish. Note: Jellyfish connection to other Jellyfish is transitive meaning that when you connect to one Jellyfish you also connect to all other Jellyfishes this one was connected to.JF_DIST_MIN_PORT- minimal port used by Jellyfish when forming a cluster (connecting to other Jellyfishes). Defaults to 9000 when running with Docker. Only available when running with Docker or mix release.JF_DIST_MAX_PORT- maximal port used by Jellyfish when forming a cluster (connecting to other Jellyfishes). Defaults to 9000 when running with Docker. Only available when running with Docker or mix release. tip You can use a single port to form a cluster, even if a cluster consists of more than two Jellyfishes. caution Besides ports specified using JF_DIST_MIN_PORT and JF_DIST_MAX_PORT, Jellyfish also uses one more service called EPMD that runs on port 4369. This port has to be explicitly exported when running with Docker. Read more in the Cluster section. "},{"title":"Metrics","type":0,"sectionRef":"#","url":"/jellyfish-docs/0.2.0/getting_started/metrics","content":"Metrics Jellyfish exports several metrics in the Prometheus format. By default, they are available on port 9568 at /metrics. See JF_METRICS_IP and JF_METRICS_PORT for configuration options. Name\tLabels\tDescriptionjellyfish_traffic_ingress_total_bytes Total traffic received jellyfish_traffic_ingress_throughput_bytes_per_second Current throughput for received traffic jellyfish_traffic_egress_total_bytes Total traffic sent jellyfish_traffic_egress_throughput_bytes_per_second Current throughput for sent traffic jellyfish_rooms Amount of rooms currently present in Jellyfish jellyfish_room_peers\troom_id\tAmount of peers currently present in a given room jellyfish_room_peer_time_total_seconds\troom_id\tTotal peer time accumulated for a given room vm_memory_total_bytes Total memory used by Erlang Virtual Machine vm_total_run_queue_lengths_total Number of Erlang processes waiting to be executed vm_total_run_queue_lengths_cpu Number of Erlang processes waiting to be executed on CPU schedulers vm_total_run_queue_lengths_io Number of Erlang processes waiting to be executed on IO schedulers","keywords":""},{"title":"Notifications","type":0,"sectionRef":"#","url":"/jellyfish-docs/0.2.0/getting_started/notifications","content":"Notifications Jellyfish sends server side notifications whenever some important event occurs, e.g.: a room has been createdsome peer has connectedcomponent has crashedetc. A full list of available notifications is always present in specific server SDK documentation. Here, we present how you can subscribe for server side notifications using Elixir Server SDK: server_address = &quot;localhost:5002&quot; server_api_token = &quot;development&quot; {:ok, notifier} = Jellyfish.Notifier.start(server_address: server_address, server_api_token: server_api_token) :ok = Jellyfish.Notifier.subscribe_server_notifications(notifier) :ok = Jellyfish.Notifier.subscribe_metrics(notifier) As a result, you should see the following logs on the server side 07:45:02.684 [info] New incoming server WebSocket connection, accepting 07:45:02.688 [info] Server WS authenticated. ","keywords":""},{"title":"WebRTC","type":0,"sectionRef":"#","url":"/jellyfish-docs/0.2.0/getting_started/peers/webrtc","content":"","keywords":""},{"title":"Compatibility​","type":1,"pageTitle":"WebRTC","url":"/jellyfish-docs/0.2.0/getting_started/peers/webrtc#compatibility","content":"HLSRTSP "},{"title":"Configuration options​","type":1,"pageTitle":"WebRTC","url":"/jellyfish-docs/0.2.0/getting_started/peers/webrtc#configuration-options","content":"Optional enableSimulcast (boolean, default: true) - Enables the peer to use simulcast "},{"title":"Env variables​","type":1,"pageTitle":"WebRTC","url":"/jellyfish-docs/0.2.0/getting_started/peers/webrtc#env-variables","content":"JF_WEBRTC_USED - has to be true if WebRTC peers will be usedJF_WEBRTC_TURN_LISTEN_IP - the IP address on which TURN servers will listen. By default set to 127.0.0.1. When running Jellyfish via Docker, this MUST be set to 0.0.0.0, even for local tests.JF_WEBRTC_TURN_IP - the IP address, under which TURN will present itself to the clients. By default set to 127.0.0.1. When running Jellyfish via Docker, this MUST be set to real (non-loopback) address, even for local tests.JF_WEBRTC_TURN_PORT_RANGE - port range, where UDP TURN will try to open ports. By default set to 50000-59999. The bigger the range is, the more users server will be able to handle. Useful when not using the --network=host option to limit the UDP ports used only to ones published from a Docker container.JF_WEBRTC_TURN_TCP_PORT - port number of TCP TURN "},{"title":"Example Docker commands​","type":1,"pageTitle":"WebRTC","url":"/jellyfish-docs/0.2.0/getting_started/peers/webrtc#example-docker-commands","content":"Explicit port exposure (macOS compatible) docker run -p 50000-50050:50000-50050/udp \\ -p 8080:8080/tcp \\ -e JF_SERVER_API_TOKEN=token \\ -e JF_HOST=localhost:8080 \\ -e JF_WEBRTC_USED=true \\ -e JF_WEBRTC_TURN_PORT_RANGE=50000-50050 \\ -e JF_WEBRTC_TURN_IP=192.168.0.1 \\ -e JF_WEBRTC_TURN_LISTEN_IP=0.0.0.0 \\ ghcr.io/jellyfish-dev/jellyfish:0.2.0  caution Make sure that the exposed UDP ports match JF_WEBRTC_TURN_PORT_RANGE. The range of the ports shouldn't be too wide as it might cause problems with container startup. Using host network (Linux only) docker run --network=host \\ -e JF_SERVER_API_TOKEN=token \\ -e JF_HOST=localhost:8080 \\ -e JF_WEBRTC_USED=true \\ -e JF_WEBRTC_TURN_IP=192.168.0.1 \\ -e JF_WEBRTC_TURN_LISTEN_IP=0.0.0.0 \\ ghcr.io/jellyfish-dev/jellyfish:0.2.0  "},{"title":"SDKs","type":0,"sectionRef":"#","url":"/jellyfish-docs/0.2.0/getting_started/sdks","content":"","keywords":""},{"title":"Server SDKs​","type":1,"pageTitle":"SDKs","url":"/jellyfish-docs/0.2.0/getting_started/sdks#server-sdks","content":"SDK\tResourcesElixir\tCode examples RTSP to HLS conversion Python\t "},{"title":"Client SDKs​","type":1,"pageTitle":"SDKs","url":"/jellyfish-docs/0.2.0/getting_started/sdks#client-sdks","content":"SDK\tResourcesReact\tReact Minimal Working Example Guide Jellyfish Videoroom Code examples TypeScript\tCode examples IOS\tCode example Android\tCode example React Native\tCode example "},{"title":"Basic Concepts","type":0,"sectionRef":"#","url":"/jellyfish-docs/0.2.0/introduction/basic_concepts","content":"","keywords":""},{"title":"Room​","type":1,"pageTitle":"Basic Concepts","url":"/jellyfish-docs/0.2.0/introduction/basic_concepts#room","content":"In Jellyfish, a room serves as a holder for peers and components, its function varying based on application. For instance, within a video conferencing system, a Jellyfish room represents a single online meeting or a channel accommodating multiple users for conversation. On the other hand, in a broadcasting system setting, one room will be a container for two components - one responsible for receiving stream from a streaming host (e.g. via RTMP) and the other one responsible for converting this stream into an HLS playlist ready to be broadcasted via CDN. "},{"title":"Component​","type":1,"pageTitle":"Basic Concepts","url":"/jellyfish-docs/0.2.0/introduction/basic_concepts#component","content":"A component is a server-side process that publishes or subscribes to tracks. Example components are: HLS component - subscribes to all other tracks and creates from them an HLS playlist ready to be broadcasted via CDNRTSP component - connects to the remote media source (e.g. an IP camera) and publishes its media to be consumed by other components or peers "},{"title":"Peer​","type":1,"pageTitle":"Basic Concepts","url":"/jellyfish-docs/0.2.0/introduction/basic_concepts#peer","content":"A peer is a client-side entity that connects to the server to publish, subscribe or publish and subscribe to tracks published by components or other peers. The peer's process is spawned after the peer connects to the server. At the moment, there is only one type of peer - WebRTC. "},{"title":"Difference between Component and Peer​","type":1,"pageTitle":"Basic Concepts","url":"/jellyfish-docs/0.2.0/introduction/basic_concepts#difference-between-component-and-peer","content":"The most important difference between a component and a peer is that component is a purely server-side thing. It starts its work right after adding it to the server. On the other hand, a peer is something that has to connect to the server. Therefore, peers are allowed to open so-called signaling channels to the server. See also Example Scenarios. "},{"title":"Example Scenarios","type":0,"sectionRef":"#","url":"/jellyfish-docs/0.2.0/introduction/example_scenarios","content":"","keywords":""},{"title":"Real-time video conferencing system​","type":1,"pageTitle":"Example Scenarios","url":"/jellyfish-docs/0.2.0/introduction/example_scenarios#real-time-video-conferencing-system","content":"In this scenario, we want to create a simple video conferencing system where people can talk to each other in the real-time. Because of interactive and real-time requirements, the natural choice is to use the WebRTC standard. The final architecture would look like this:   "},{"title":"Broadcasting system with the real-time mixin​","type":1,"pageTitle":"Example Scenarios","url":"/jellyfish-docs/0.2.0/introduction/example_scenarios#broadcasting-system-with-the-real-time-mixin","content":"In this scenario, we want to create a broadcasting solution where the conversation between multiple people is broadcasted to the broader audience. Here, we choose WebRTC as a standard used for connecting people talking to each other in real-time and HLS for creating a playlist that can be then uploaded to CDN and broadcasted to the broader audience. As you can see, the whole system will automatically adapt to the number of participants talking in real-time. In particular, Jellyfish will handle a scenario with only one streamer out of the box.   "},{"title":"Displaying IP camera streams in a web browser​","type":1,"pageTitle":"Example Scenarios","url":"/jellyfish-docs/0.2.0/introduction/example_scenarios#displaying-ip-camera-streams-in-a-web-browser","content":"In this scenario, we have a set of IP cameras and we want to display their streams in a web browser. IP cameras very often use RTSP for streaming media but browsers don't ship with support for this protocol. Therefore, to display audio and video in a web browser, we have to use either WebRTC or HLS. Because, in this scenario, the delay is not the most crucial thing, we choose HLS. The most important thing here is that the RTSP component connects to the IP camera and then the camera starts streaming. It's not the camera that initializes the connection to the server. Therefore, the RTSP component is a purely server-side thing - once you add it, it should be able to work on its own.   "},{"title":"The Whats and Hows of Jellyfish Dashboard","type":0,"sectionRef":"#","url":"/jellyfish-docs/0.2.0/tutorials/dashboard","content":"","keywords":""},{"title":"What is Jellyfish Dashboard?​","type":1,"pageTitle":"The Whats and Hows of Jellyfish Dashboard","url":"/jellyfish-docs/0.2.0/tutorials/dashboard#what-is-jellyfish-dashboard","content":"Jellyfish Dashboard is a web application that allows you to manage your Jellyfish Media Server instance. It is a React application that uses the Jellyfish React Client APIfor adding and receiving tracks and Jellyfish Server APIfor adding peers, creating rooms etc. It was created to help Jellyfish developers in testing but was later extended and adapted as a tool for tutorials and demos. Here, we present a short introduction to the dashboard and its features. "},{"title":"How to start Jellyfish Dashboard?​","type":1,"pageTitle":"The Whats and Hows of Jellyfish Dashboard","url":"/jellyfish-docs/0.2.0/tutorials/dashboard#how-to-start-jellyfish-dashboard","content":"There are a couple of ways to start the dashboard: Up-to-date versionDocker containerOfficial repository The current version of the dashboard is ready to use and availablehere. Ensure that it is compatible with your Jellyfish server! Please note that this dashboard only supports secure connections (https/wss) or connections to localhost. Any insecure requests (http/ws) will be automatically blocked by the browser. "},{"title":"How to start Jellyfish Media Server?​","type":1,"pageTitle":"The Whats and Hows of Jellyfish Dashboard","url":"/jellyfish-docs/0.2.0/tutorials/dashboard#how-to-start-jellyfish-media-server","content":"For testing, we'll run the Jellyfish Media Server locally using Docker image: docker run -p 50000-50050:50000-50050/udp \\ -p 5002:5002/tcp \\ -e JF_CHECK_ORIGIN=false \\ -e JF_HOST=&lt;your ip address&gt;:5002 \\ -e JF_PORT=&quot;5002&quot; \\ -e JF_WEBRTC_USED=true \\ -e JF_WEBRTC_TURN_PORT_RANGE=50000-50050 \\ -e JF_WEBRTC_TURN_IP=&lt;your ip address&gt; \\ -e JF_WEBRTC_TURN_LISTEN_IP=0.0.0.0 \\ -e JF_SERVER_API_TOKEN=development \\ ghcr.io/jellyfish-dev/jellyfish:0.2.0  Make sure to set JF_WEBRTC_TURN_IP and JF_HOST to your local IP address. Without it, the mobile device won't be able to connect to the Jellyfish. tip To check your local IP you can use this handy command (Linux/macOS): ifconfig | grep &quot;inet &quot; | grep -Fv 127.0.0.1 | awk '{print $2}'  "},{"title":"How to use Jellyfish Dashboard?​","type":1,"pageTitle":"The Whats and Hows of Jellyfish Dashboard","url":"/jellyfish-docs/0.2.0/tutorials/dashboard#how-to-use-jellyfish-dashboard","content":"Since we have Dashboard and Jellyfish Media Server up and running, we can dive into the features. "},{"title":"Connecting to the server​","type":1,"pageTitle":"The Whats and Hows of Jellyfish Dashboard","url":"/jellyfish-docs/0.2.0/tutorials/dashboard#connecting-to-the-server","content":"We started the dashboard and the Jellyfish Media Server separately, so we need to connect them. Open the dashboard in your browser. Open the side menu and fill in the parameters:  Server token - a token necessary to authenticate the dashboard with the Jellyfish. For now, it's simply development, but it is meant to authenticate the dashboard to the Jellyfish, so the good practice is to use a token that is hard to guess.WS/WSS - whether to use a secure or insecure connection. , it's ws, but if the Jellyfish uses secure WebSocket, use wss.HTTP/HTTPS - whether to use a secure or insecure connection. By default, it's http, but if the Jellyfish uses secure HTTP, use https.Server URL - URL of the Jellyfish server. Here, localhost:5002 would be a local build, but it can be any URL that points to the Jellyfish.Socket Path - path to the WebSocket endpoint. The default value is /socket/peer/websocket. Click Connect to server. If everything is correct, a server will appear in the list of connected servers:  "},{"title":"Creating a room​","type":1,"pageTitle":"The Whats and Hows of Jellyfish Dashboard","url":"/jellyfish-docs/0.2.0/tutorials/dashboard#creating-a-room","content":"There are plenty of settings that You can adjust in a room:  h264 or vp8 - video codec used in the room. If you want to use HLS streaming, you need to use h264.Max Peers - maximum number of peers that can join to the room. When you select the settings, click the Add room button. If everything is correct, a room will appear in the list of rooms:  "},{"title":"Adding and connecting peers to the room​","type":1,"pageTitle":"The Whats and Hows of Jellyfish Dashboard","url":"/jellyfish-docs/0.2.0/tutorials/dashboard#adding-and-connecting-peers-to-the-room","content":"Using the Create peer button, you can create a peer that will be ready to connect to the room.  The peer has its ID and Token. The ID is used to identify the peer in the Jellyfish Server, and the Token is used to authenticate the peer with the Jellyfish Server. Dashboard has an option to copy both of those values to the clipboard. You can also create a QR code with the peer's Token to make connecting to Jellyfish with a mobile device easier.  To connect the peer to the room, you can either press the Connect button in the peer's row, or scan the QR code with your mobile app, and connect there. "},{"title":"Sending tracks​","type":1,"pageTitle":"The Whats and Hows of Jellyfish Dashboard","url":"/jellyfish-docs/0.2.0/tutorials/dashboard#sending-tracks","content":"When the peer connects to the room, you will see the track menu. It allows you to send tracks to the room.  You can select the audio or video track you want to create. Created tracks will be visible in the list below. You can select any track from the list and send it to the room. Apart from your camera/microphone, you can easily share your screen with its audio or pick one from a list of mock tracks that we prepared. You can also select the resolution of the video track or if you want, send the video as a simulcast stream. There is also an option to add custom metadata (in JSON format) to the track. The peer will send metadata with the track to the room. Each recipient will be able to see it. When you select the track, click the Add track button. If everything is correct, client will send the track to the room and other peers will be able to see and hear you. "},{"title":"Receiving tracks​","type":1,"pageTitle":"The Whats and Hows of Jellyfish Dashboard","url":"/jellyfish-docs/0.2.0/tutorials/dashboard#receiving-tracks","content":"When the peer connects to the room, it will automatically receive tracks from other peers. Congrats! The basic utils of the dashboard are now covered. Next, we will dive into useful features that will help you with testing. "},{"title":"A ton of information that the dashboard provides​","type":1,"pageTitle":"The Whats and Hows of Jellyfish Dashboard","url":"/jellyfish-docs/0.2.0/tutorials/dashboard#a-ton-of-information-that-the-dashboard-provides","content":""},{"title":"Server logs in console​","type":1,"pageTitle":"The Whats and Hows of Jellyfish Dashboard","url":"/jellyfish-docs/0.2.0/tutorials/dashboard#server-logs-in-console","content":"On the side menu, you can set up the dashboard to display React Client logs in the console. Logs are great for debugging purposes and provide insight into the various communications that occur between the dashboard and the Jellyfish Server. You can also register your event handlers in your Jellyfish-based projects, both in theReact Client SDK and theTS Client SDK. These logs can show you when particular events occur and provide data that you can use in your own handlers  "},{"title":"Server/Room/Client state​","type":1,"pageTitle":"The Whats and Hows of Jellyfish Dashboard","url":"/jellyfish-docs/0.2.0/tutorials/dashboard#serverroomclient-state","content":"Each server, room, and client has its state. You can see the state of each of them in the dashboard by clicking appropriate buttons.  "},{"title":"Server events​","type":1,"pageTitle":"The Whats and Hows of Jellyfish Dashboard","url":"/jellyfish-docs/0.2.0/tutorials/dashboard#server-events","content":"Apart from the state, you can also see the events that occur on the server. You can see them after clicking the Show Server Events button.  "},{"title":"HLS and RTSP streaming​","type":1,"pageTitle":"The Whats and Hows of Jellyfish Dashboard","url":"/jellyfish-docs/0.2.0/tutorials/dashboard#hls-and-rtsp-streaming","content":"The dashboard allows adding HLS and RTSP streams in the room. You can set up the streams and see them in the room. It will look like this:  "},{"title":"Loadbalancing in Dashboard​","type":1,"pageTitle":"The Whats and Hows of Jellyfish Dashboard","url":"/jellyfish-docs/0.2.0/tutorials/dashboard#loadbalancing-in-dashboard","content":"Jellyfish Server supports load balancing. This means you can run multiple instances of the server and use them simultaneously to distribute the load evenly among them. The dashboard reflects this feature. If you run multiple Jellyfish instances (which Docker Compose does by default), connect one server to the dashboard. When a server opens a room on a different instance, the Dashboard will automatically connect to it and display the room. When Jellyfish runs in a cluster, and the Dashboard requests a new room, it's created on the Jellyfish instance with the lowest load. Information about the specific Jellyfish instance that hosts the newly created room is returned in the HTTP response body. "},{"title":"Data collected by Jellyfish​","type":1,"pageTitle":"The Whats and Hows of Jellyfish Dashboard","url":"/jellyfish-docs/0.2.0/tutorials/dashboard#data-collected-by-jellyfish","content":"For each server, Jellyfish collects WebRTC statistics about the rooms, clients and streamed tracks. You can see them in the dashboard using the Internals button.  The button opens a new tab with the panel to connect to the WebSocket of the Jellyfish of choice. You can observe the data with the dynamically generated charts showing what flows through the Jellyfish.  "},{"title":"Summary​","type":1,"pageTitle":"The Whats and Hows of Jellyfish Dashboard","url":"/jellyfish-docs/0.2.0/tutorials/dashboard#summary","content":"Congrats on finishing the tutorial! You should now be able to use the dashboard to its full potential. But this was just the beginning. Jellyfish Client API is a powerful tool that allows you to create your own web or mobile multimedia application. Check out the other tutorials to learn more about the Jellyfish Client API and how to use it in your projects. You can also take a look at our fully featured Videoroom Demo example:  It's written in React Native, but it uses the same Jellyfish Client API as the dashboard, so you can learn a lot from it. "},{"title":"Rest API","type":0,"sectionRef":"#","url":"/jellyfish-docs/0.2.0/for_developers/api_reference/rest_api","content":"Rest API hls getSend file recording getShows information about the roomdelDelete the recordinggetSend file room getShow information about all roomspostCreates a roomdelDelete the roomgetShows information about the roompostCreates the component and adds it to the roomdelDelete the component from the roompostCreate peerdelDelete peer API docs by Redocly Jellyfish Media Server (0.2.0) Download OpenAPI specification:Download License: Apache 2.0 hls Send file Authorizations: authorization path Parameters room_id required string Room id filename required string Name of the file query Parameters _HLS_msn integer or null (HlsMsn) &gt;= 0 Example: _HLS_msn=10 Segment sequence number _HLS_part integer or null (HlsPart) &gt;= 0 Example: _HLS_part=10 Partial segment sequence number _HLS_skip string or null (HlsSkip) Value: &quot;YES&quot; Example: _HLS_skip=YES Is delta manifest requested header Parameters range string Byte range of partial segment Responses 200 File was found 404 File not found get/hls/{room_id}/{filename} https://raw.githubusercontent.com/hls/{room_id}/{filename} Response samples 200404 Content type application/json Copy &quot;string&quot; recording Shows information about the room Authorizations: authorization Responses 200 Success 404 Unable to obtain recordings get/recording https://raw.githubusercontent.com/recording Response samples 200404 Content type application/json Copy Expand all Collapse all { &quot;data&quot;: [ &quot;string&quot; ] } Delete the recording Authorizations: authorization path Parameters recording_id required string Recording id Responses 204 Successfully deleted recording 404 Recording doesn't exist delete/recording/{recording_id} https://raw.githubusercontent.com/recording/{recording_id} Response samples 404 Content type application/json Copy { &quot;errors&quot;: &quot;Token has expired&quot; } Send file Authorizations: authorization path Parameters recording_id required string Recording id filename required string Name of the file Responses 200 File was found 404 File not found get/recording/{recording_id}/{filename} https://raw.githubusercontent.com/recording/{recording_id}/{filename} Response samples 200404 Content type application/json Copy &quot;string&quot; room Show information about all rooms Authorizations: authorization Responses 200 Success 401 Unauthorized get/room https://raw.githubusercontent.com/room Response samples 200401 Content type application/json Copy Expand all Collapse all { &quot;data&quot;: [ { &quot;components&quot;: [ { &quot;id&quot;: &quot;component-1&quot;, &quot;metadata&quot;: { &quot;lowLatency&quot;: true, &quot;persistent&quot;: true, &quot;playable&quot;: true, &quot;targetWindowDuration&quot;: 0 }, &quot;type&quot;: &quot;hls&quot; } ], &quot;config&quot;: { &quot;maxPeers&quot;: 10, &quot;videoCodec&quot;: &quot;h264&quot;, &quot;webhookUrl&quot;: &quot;https://backend.address.com/jellyfish-notifications-endpoint&quot; }, &quot;id&quot;: &quot;room-1&quot;, &quot;peers&quot;: [ { &quot;id&quot;: &quot;peer-1&quot;, &quot;status&quot;: &quot;disconnected&quot;, &quot;type&quot;: &quot;webrtc&quot; } ] } ] } Creates a room Authorizations: authorization Request Body schema: application/json Room configuration maxPeers integer or null &gt;= 1 Maximum amount of peers allowed into the room videoCodec string or null Enum: &quot;h264&quot; &quot;vp8&quot; Enforces video codec for each peer in the room webhookUrl string or null URL where Jellyfish notifications will be sent Responses 201 Room successfully created 400 Invalid request structure 401 Unauthorized post/room https://raw.githubusercontent.com/room Request samples Payload Content type application/json Copy { &quot;maxPeers&quot;: 10, &quot;videoCodec&quot;: &quot;h264&quot;, &quot;webhookUrl&quot;: &quot;https://backend.address.com/jellyfish-notifications-endpoint&quot; } Response samples 201400401 Content type application/json Copy Expand all Collapse all { &quot;data&quot;: { &quot;jellyfish_address&quot;: &quot;jellyfish1:5003&quot;, &quot;room&quot;: { &quot;components&quot;: [ { &quot;id&quot;: &quot;component-1&quot;, &quot;metadata&quot;: { &quot;lowLatency&quot;: true, &quot;persistent&quot;: true, &quot;playable&quot;: true, &quot;targetWindowDuration&quot;: 0 }, &quot;type&quot;: &quot;hls&quot; } ], &quot;config&quot;: { &quot;maxPeers&quot;: 10, &quot;videoCodec&quot;: &quot;h264&quot;, &quot;webhookUrl&quot;: &quot;https://backend.address.com/jellyfish-notifications-endpoint&quot; }, &quot;id&quot;: &quot;room-1&quot;, &quot;peers&quot;: [ { &quot;id&quot;: &quot;peer-1&quot;, &quot;status&quot;: &quot;disconnected&quot;, &quot;type&quot;: &quot;webrtc&quot; } ] } } } Delete the room Authorizations: authorization path Parameters room_id required string Room id Responses 204 Successfully deleted room 401 Unauthorized 404 Room doesn't exist delete/room/{room_id} https://raw.githubusercontent.com/room/{room_id} Response samples 401404 Content type application/json Copy { &quot;errors&quot;: &quot;Token has expired&quot; } Shows information about the room Authorizations: authorization path Parameters room_id required string Room ID Responses 200 Success 401 Unauthorized 404 Room doesn't exist get/room/{room_id} https://raw.githubusercontent.com/room/{room_id} Response samples 200401404 Content type application/json Copy Expand all Collapse all { &quot;data&quot;: { &quot;components&quot;: [ { &quot;id&quot;: &quot;component-1&quot;, &quot;metadata&quot;: { &quot;lowLatency&quot;: true, &quot;persistent&quot;: true, &quot;playable&quot;: true, &quot;targetWindowDuration&quot;: 0 }, &quot;type&quot;: &quot;hls&quot; } ], &quot;config&quot;: { &quot;maxPeers&quot;: 10, &quot;videoCodec&quot;: &quot;h264&quot;, &quot;webhookUrl&quot;: &quot;https://backend.address.com/jellyfish-notifications-endpoint&quot; }, &quot;id&quot;: &quot;room-1&quot;, &quot;peers&quot;: [ { &quot;id&quot;: &quot;peer-1&quot;, &quot;status&quot;: &quot;disconnected&quot;, &quot;type&quot;: &quot;webrtc&quot; } ] } } Creates the component and adds it to the room Authorizations: authorization path Parameters room_id required string Room ID Request Body schema: application/json Component config options ComponentOptionsHLS (object) or ComponentOptionsRTSP (object) (ComponentOptions) Component-specific options type required string (ComponentType) Component type Responses 201 Successfully added component 400 Invalid request 401 Unauthorized 404 Room doesn't exist post/room/{room_id}/component https://raw.githubusercontent.com/room/{room_id}/component Request samples Payload Content type application/json Copy Expand all Collapse all { &quot;options&quot;: { &quot;lowLatency&quot;: false, &quot;persistent&quot;: false, &quot;targetWindowDuration&quot;: 0 }, &quot;type&quot;: &quot;hls&quot; } Response samples 201400401404 Content type application/json Copy Expand all Collapse all { &quot;data&quot;: { &quot;id&quot;: &quot;component-1&quot;, &quot;metadata&quot;: { &quot;lowLatency&quot;: true, &quot;persistent&quot;: true, &quot;playable&quot;: true, &quot;targetWindowDuration&quot;: 0 }, &quot;type&quot;: &quot;hls&quot; } } Delete the component from the room Authorizations: authorization path Parameters room_id required string Room ID id required string Component ID Responses 204 Successfully deleted 401 Unauthorized 404 Either component or the room doesn't exist delete/room/{room_id}/component/{id} https://raw.githubusercontent.com/room/{room_id}/component/{id} Response samples 401404 Content type application/json Copy { &quot;errors&quot;: &quot;Token has expired&quot; } Create peer Authorizations: authorization path Parameters room_id required string Room id Request Body schema: application/json Peer specification options required PeerOptionsWebRTC (object) (PeerOptions) Peer-specific options type required string (PeerType) Peer type Responses 201 Peer successfully created 400 Invalid request body structure 401 Unauthorized 404 Room doesn't exist 503 Peer limit has been reached post/room/{room_id}/peer https://raw.githubusercontent.com/room/{room_id}/peer Request samples Payload Content type application/json Copy Expand all Collapse all { &quot;options&quot;: { &quot;enableSimulcast&quot;: true }, &quot;type&quot;: &quot;webrtc&quot; } Response samples 201400401404503 Content type application/json Copy Expand all Collapse all { &quot;data&quot;: { &quot;peer&quot;: { &quot;id&quot;: &quot;peer-1&quot;, &quot;status&quot;: &quot;disconnected&quot;, &quot;type&quot;: &quot;webrtc&quot; }, &quot;token&quot;: &quot;5cdac726-57a3-4ecb-b1d5-72a3d62ec242&quot; } } Delete peer Authorizations: authorization path Parameters room_id required string Room ID id required string Peer id Responses 204 Peer successfully deleted 401 Unauthorized 404 Room ID or Peer ID references a resource that doesn't exist delete/room/{room_id}/peer/{id} https://raw.githubusercontent.com/room/{room_id}/peer/{id} Response samples 401404 Content type application/json Copy { &quot;errors&quot;: &quot;Token has expired&quot; }","keywords":""},{"title":"React Native Minimal Working Example","type":0,"sectionRef":"#","url":"/jellyfish-docs/0.2.0/tutorials/react-native","content":"","keywords":""},{"title":"What you'll learn​","type":1,"pageTitle":"React Native Minimal Working Example","url":"/jellyfish-docs/0.2.0/tutorials/react-native#what-youll-learn","content":"This tutorial will guide you through creating your first React Native / Expo project which uses Jellyfish client. By the end of the tutorial, you'll have a working application that connects to an instance of Jellyfish Server using WebRTC and streams and receives camera tracks.  You can check out the finished project here. "},{"title":"What do you need​","type":1,"pageTitle":"React Native Minimal Working Example","url":"/jellyfish-docs/0.2.0/tutorials/react-native#what-do-you-need","content":"a little bit of experience in creating apps with React Native and/or Expo - refer to the React Native Guide or Expo Guide to learn more "},{"title":"Jellyfish architecture​","type":1,"pageTitle":"React Native Minimal Working Example","url":"/jellyfish-docs/0.2.0/tutorials/react-native#jellyfish-architecture","content":"info You can learn more about Jellyfish architecture in Jellyfish docs. This section provides a brief description aimed at front-end developers Let's introduce some concepts first: Peer - A peer is a client-side entity that connects to the server to publish, subscribe or publish and subscribe to tracks published by components or other peers. You can think of it as a participant in a room. At the moment, there is only one type of peer - WebRTC.Track - An object that represents an audio or video stream. A track can be associated with a local media source, such as a camera or microphone, or a remote media source received from another user. Tracks are used to capture, transmit, and receive audio and video data in WebRTC applications.Room - In Jellyfish, a room serves as a holder for peers and components, its function varying based on application. From a front-end perspective, this will be probably one meeting or a broadcast. For a better understanding of these concepts here is an example of a room that holds a standard WebRTC conference from a perspective of the User:  In this example, peers stream multiple video and audio tracks. Peer #1 streams even two video tracks (camera and screencast track). You can differentiate between them by using track metadata. The user gets info about peers and their tracks from the server using Jellyfish Client. The user is also informed in real time about peers joining/leaving and tracks being added/removed. To keep this tutorial short we'll simplify things a little. Every peer will stream just one video track. "},{"title":"Connecting and joining the room​","type":1,"pageTitle":"React Native Minimal Working Example","url":"/jellyfish-docs/0.2.0/tutorials/react-native#connecting-and-joining-the-room","content":"The general flow of connecting to the server and joining the room in a standard WebRTC conference setup looks like this:  The parts that you need to implement are marked in blue and things handled by Jellyfish are marked in red. Firstly, the user logs in. Then your backend authenticates the user and obtains a peer token. It allows the user to authenticate and join the room in Jellyfish Server. The backend passes the token to your front-end, and your front-end passes it to Jellyfish Client. The client establishes the connection with Jellyfish Server. Then Jellyfish Client sets up tracks (camera, microphone) to stream and joins the room on Jellyfish Server. Finally, your front-end can display the room for the user. For this tutorial we simplified this process a bit - you don't have to implement a backend or authentication. Jellyfish Dashboard will do this for you. It's also a nice tool to test and play around with Jellyfish. The flow with Jellyfish The dashboard looks like this:  You can see that the only things you need to implement are interactions with the user and Jellyfish Client. This tutorial will show you how to do it. "},{"title":"Setup​","type":1,"pageTitle":"React Native Minimal Working Example","url":"/jellyfish-docs/0.2.0/tutorials/react-native#setup","content":""},{"title":"Start the Jellyfish Dashboard​","type":1,"pageTitle":"React Native Minimal Working Example","url":"/jellyfish-docs/0.2.0/tutorials/react-native#start-the-jellyfish-dashboard","content":"For testing, we'll run the Jellyfish Media Server locally using Docker image: docker run -p 50000-50050:50000-50050/udp \\ -p 5002:5002/tcp \\ -e JF_CHECK_ORIGIN=false \\ -e JF_HOST=&lt;your ip address&gt;:5002 \\ -e JF_PORT=&quot;5002&quot; \\ -e JF_WEBRTC_USED=true \\ -e JF_WEBRTC_TURN_PORT_RANGE=50000-50050 \\ -e JF_WEBRTC_TURN_IP=&lt;your ip address&gt; \\ -e JF_WEBRTC_TURN_LISTEN_IP=0.0.0.0 \\ -e JF_SERVER_API_TOKEN=development \\ ghcr.io/jellyfish-dev/jellyfish:0.2.0  Make sure to set JF_WEBRTC_TURN_IP and JF_HOST to your local IP address. Without it, the mobile device won't be able to connect to the Jellyfish. tip To check your local IP you can use this handy command (Linux/macOS): ifconfig | grep &quot;inet &quot; | grep -Fv 127.0.0.1 | awk '{print $2}'  "},{"title":"Start the dashboard web front-end​","type":1,"pageTitle":"React Native Minimal Working Example","url":"/jellyfish-docs/0.2.0/tutorials/react-native#start-the-dashboard-web-front-end","content":"There are a couple of ways to start the dashboard: Up-to-date versionDocker containerOfficial repository The current version of the dashboard is ready to use and availablehere. Ensure that it is compatible with your Jellyfish server! Please note that this dashboard only supports secure connections (https/wss) or connections to localhost. Any insecure requests (http/ws) will be automatically blocked by the browser. "},{"title":"Create React Native / Expo project​","type":1,"pageTitle":"React Native Minimal Working Example","url":"/jellyfish-docs/0.2.0/tutorials/react-native#create-react-native--expo-project","content":"Firstly create a brand new project. React NativeExpo Bare workflow npx react-native@latest init JellyfishDashboard  "},{"title":"Add dependencies​","type":1,"pageTitle":"React Native Minimal Working Example","url":"/jellyfish-docs/0.2.0/tutorials/react-native#add-dependencies","content":"note Please make sure to install or update expo to version ^49.0.0 You have two options here. You can follow configuration instructions for React Native (Expo Bare workflow is a React Native project after all) or if you're using expo prebuild command to set up native code you can add our Expo plugin. Just add it to app.json: { &quot;expo&quot;: { &quot;name&quot;: &quot;example&quot;, //... &quot;plugins&quot;: [&quot;@jellyfish-dev/react-native-membrane-webrtc&quot;] } }  React NativeExpo Bare workflow In order for this module to work you'll need to also add `expo` package. The expo package has a small footprint and it's necessary as Jellyfish Client package is built as Expo module. npx install-expo-modules@latest npm install @jellyfish-dev/react-native-client-sdk  tip Run pod install in the /ios directory to install the new pods "},{"title":"Native permissions configuration​","type":1,"pageTitle":"React Native Minimal Working Example","url":"/jellyfish-docs/0.2.0/tutorials/react-native#native-permissions-configuration","content":"In order for camera and audio to work you'll need to add some native configuration: You need to at least set up camera permissions. On Android add to your AndroidManifest.xml: AndroidManifest.xml &lt;uses-permission android:name=&quot;android.permission.CAMERA&quot;/&gt;  For audio you'll need the RECORD_AUDIO permission: AndroidManifest.xml &lt;uses-permission android:name=&quot;android.permission.RECORD_AUDIO&quot;/&gt;  On iOS you must set NSCameraUsageDescription in Info.plist file. You can edit this file in Xcode. This value is a description that is shown when iOS asks user for camera permission. ios/jellyfish-dashboard/Info.plist &lt;key&gt;NSCameraUsageDescription&lt;/key&gt; &lt;string&gt; 🙏 🎥 &lt;/string&gt;  Similarly, for audio there is NSMicrophoneUsageDescription. ios/jellyfish-dashboard/Info.plist &lt;key&gt;NSMicrophoneUsageDescription&lt;/key&gt; &lt;string&gt; 🙏 🎤 &lt;/string&gt;  For screencast there is more configuration needed, it's described here. We also suggest setting background mode to audio so that the app doesn't disconnect when it's in the background: ios/jellyfish-dashboard/Info.plist &lt;key&gt;UIBackgroundModes&lt;/key&gt; &lt;array&gt; &lt;string&gt;audio&lt;/string&gt; &lt;/array&gt;  "},{"title":"Add components library​","type":1,"pageTitle":"React Native Minimal Working Example","url":"/jellyfish-docs/0.2.0/tutorials/react-native#add-components-library","content":"For your convenience, we've prepared a library with nice-looking components useful for following this tutorial. Feel free to use standard React Native components or your own components though! npx expo install @expo/vector-icons expo-barcode-scanner expo-font @expo-google-fonts/noto-sans @jellyfish-dev/react-native-jellyfish-components @react-navigation/native-stack  You'll also need to install Reanimated library (3.3.0) and React Navigation (6.1.7) tip Run pod install in the /ios directory to install the new pods "},{"title":"Screens​","type":1,"pageTitle":"React Native Minimal Working Example","url":"/jellyfish-docs/0.2.0/tutorials/react-native#screens","content":"For managing screens we will use React Navigation library, but feel free to pick whatever suits you. Our app will consist of two screens. The first one ConnectScreen will allow a user to type, paste or scan a peer token and connect to the room. The second one RoomScreen will show room participants with their video tracks. /App.tsx import React from &quot;react&quot;; import { NavigationContainer } from &quot;@react-navigation/native&quot;; import { createNativeStackNavigator } from &quot;@react-navigation/native-stack&quot;; import ConnectScreen from &quot;./screens/Connect&quot;; import RoomScreen from &quot;./screens/Room&quot;; const Stack = createNativeStackNavigator(); function App(): JSX.Element { return ( &lt;NavigationContainer&gt; &lt;Stack.Navigator&gt; &lt;Stack.Screen name=&quot;Connect&quot; component={ConnectScreen} /&gt; &lt;Stack.Screen name=&quot;Room&quot; component={RoomScreen} /&gt; &lt;/Stack.Navigator&gt; &lt;/NavigationContainer&gt; ); } export default App;  "},{"title":"ConnectScreen​","type":1,"pageTitle":"React Native Minimal Working Example","url":"/jellyfish-docs/0.2.0/tutorials/react-native#connectscreen","content":"The UI of the ConnectScreen consists of a simple text input and a few buttons. The flow for this screen is simple: the user either copies the peer token from the dashboard or scans it with a QR code scanner and presses Connect button. The QR code scanner is provided by our components library and it's completely optional, just for convenience. The code for the UI looks like this: /screens/Connect.tsx import React, { useState } from &quot;react&quot;; import { View, StyleSheet } from &quot;react-native&quot;; import { Button, TextInput, QRCodeScanner, } from &quot;@jellyfish-dev/react-native-jellyfish-components&quot;; import { NavigationProp } from &quot;@react-navigation/native&quot;; interface ConnectScreenProps { navigation: NavigationProp&lt;any&gt;; } function ConnectScreen({ navigation }: ConnectScreenProps): JSX.Element { const [peerToken, setPeerToken] = useState&lt;string&gt;(&quot;&quot;); return ( &lt;View style={styles.container}&gt; &lt;TextInput placeholder=&quot;Enter peer token&quot; value={peerToken} onChangeText={setPeerToken} /&gt; &lt;Button onPress={() =&gt; { /* to be filled */ }} title=&quot;Connect&quot; disabled={!peerToken} /&gt; &lt;QRCodeScanner onCodeScanned={setPeerToken} /&gt; &lt;/View&gt; ); } const styles = StyleSheet.create({ container: { flex: 1, justifyContent: &quot;center&quot;, backgroundColor: &quot;#BFE7F8&quot;, padding: 24, rowGap: 24, }, }); export default ConnectScreen;  "},{"title":"Connecting to the server​","type":1,"pageTitle":"React Native Minimal Working Example","url":"/jellyfish-docs/0.2.0/tutorials/react-native#connecting-to-the-server","content":"Once the UI is ready, let's implement the logic responsible for connecting to the server. Firstly wrap your app with JelyfishContextProvider: /App.tsx import React from &quot;react&quot;; import { JellyfishContextProvider } from &quot;@jellyfish-dev/react-native-client-sdk&quot;; import { NavigationContainer } from &quot;@react-navigation/native&quot;; import { createNativeStackNavigator } from &quot;@react-navigation/native-stack&quot;; import ConnectScreen from &quot;./screens/Connect&quot;; import RoomScreen from &quot;./screens/Room&quot;; const Stack = createNativeStackNavigator(); function App(): JSX.Element { return ( &lt;JellyfishContextProvider&gt; &lt;NavigationContainer&gt; &lt;Stack.Navigator&gt; &lt;Stack.Screen name=&quot;Connect&quot; component={ConnectScreen} /&gt; &lt;Stack.Screen name=&quot;Room&quot; component={RoomScreen} /&gt; &lt;/Stack.Navigator&gt; &lt;/NavigationContainer&gt; &lt;/JellyfishContextProvider&gt; ); } export default App;  Then in the ConnectScreen use the useJellyfishClient hook to connect to the server. Simply call the connect method with your Jellyfish server URL and the peer token. The connect function establishes a connection with the Jellyfish server via web socket and authenticates the peer. /screens/Connect.tsx import { useJellyfishClient } from &quot;@jellyfish-dev/react-native-client-sdk&quot;; import { NavigationProp } from &quot;@react-navigation/native&quot;; interface ConnectScreenProps { navigation: NavigationProp&lt;any&gt;; } // This is the address of the Jellyfish backend. Change the local IP to yours. We // strongly recommend setting this as an environment variable, we hardcoded it here // for simplicity. const JELLYFISH_URL = &quot;ws://X.X.X.X:4000/socket/peer/websocket&quot;; function ConnectScreen({ navigation }: ConnectScreenProps): JSX.Element { const [peerToken, setPeerToken] = useState&lt;string&gt;(&quot;&quot;); const { connect } = useJellyfishClient(); const connectToRoom = async () =&gt; { try { await connect(JELLYFISH_URL, peerToken.trim()); } catch (e) { console.log(&quot;Error while connecting&quot;, e); } }; return ( &lt;View style={styles.container}&gt; &lt;TextInput placeholder=&quot;Enter peer token&quot; value={peerToken} onChangeText={setPeerToken} /&gt; &lt;Button onPress={connectToRoom} title=&quot;Connect&quot; disabled={!peerToken} /&gt; &lt;QRCodeScanner onCodeScanned={setPeerToken} /&gt; &lt;/View&gt; ); } // ...  "},{"title":"Camera permissions (Android only)​","type":1,"pageTitle":"React Native Minimal Working Example","url":"/jellyfish-docs/0.2.0/tutorials/react-native#camera-permissions-android-only","content":"To start the camera we need to ask the user for permission first. We'll use a standard React Native module for this: /screens/Connect.tsx import { View, StyleSheet, type Permission, PermissionsAndroid, Platform, } from &quot;react-native&quot;; // ... function ConnectScreen({ navigation }: ConnectScreenProps): JSX.Element { // ... const grantedCameraPermissions = async () =&gt; { if (Platform.OS === &quot;ios&quot;) return true; const granted = await PermissionsAndroid.request( PermissionsAndroid.PERMISSIONS.CAMERA as Permission ); if (granted !== PermissionsAndroid.RESULTS.GRANTED) { console.error(&quot;Camera permission denied&quot;); return false; } return true; }; const connectToRoom = async () =&gt; { try { await connect(JELLYFISH_URL, peerToken.trim()); if (!(await grantedCameraPermissions())) { return; } } catch (e) { console.log(&quot;Error while connecting&quot;, e); } }; // ... } // ...  "},{"title":"Starting the camera​","type":1,"pageTitle":"React Native Minimal Working Example","url":"/jellyfish-docs/0.2.0/tutorials/react-native#starting-the-camera","content":"Jellyfish Client provides a handy hook for managing the camera: useCamera. Not only it can start a camera but also toggle it, manage its state, simulcast and bandwidth settings, and switch between multiple sources. Also when starting the camera you can provide multiple different settings such as resolution, quality, and metadata. In this example though we'll simply turn it on to stream the camera to the dashboard with default settings /screens/Connect.tsx import { useJellyfishClient, useCamera, } from &quot;@jellyfish-dev/react-native-client-sdk&quot;; // ... function ConnectScreen({ navigation }: ConnectScreenProps): JSX.Element { // ... const { startCamera } = useCamera(); const connectToRoom = async () =&gt; { try { await connect(JELLYFISH_URL, peerToken.trim()); if (!(await grantedCameraPermissions())) { return; } await startCamera(); } catch (e) { console.log(&quot;Error while connecting&quot;, e); } }; // ... } // ...  "},{"title":"Joining the room​","type":1,"pageTitle":"React Native Minimal Working Example","url":"/jellyfish-docs/0.2.0/tutorials/react-native#joining-the-room","content":"The last step of connecting to the room would be actually joining it so that your camera track is visible to the other users. To do this simply use the join function from the useJellyfishClient hook. You can also provide some user metadata when joining. Metadata can be anything and is forwarded to the other participants as is. In our case, we pass a username. After joining the room we navigate to the next screen: Room screen. /screens/Connect.tsx // ... function ConnectScreen({ navigation }: ConnectScreenProps): JSX.Element { const { connect, join } = useJellyfishClient(); const connectToRoom = async () =&gt; { try { await connect(JELLYFISH_URL, peerToken.trim()); if (!(await grantedCameraPermissions())) { return; } await startCamera(); await join({ name: &quot;Mobile RN Client&quot; }); navigation.navigate(&quot;Room&quot;); } catch (e) { console.log(&quot;Error while connecting&quot;, e); } }; // ... } // ...  Now the app is ready for the first test. If everything went well you should see a video from your camera in the front-end dashboard. Now onto the second part: displaying the streams from other participants. "},{"title":"RoomScreen​","type":1,"pageTitle":"React Native Minimal Working Example","url":"/jellyfish-docs/0.2.0/tutorials/react-native#roomscreen","content":""},{"title":"Displaying video tracks​","type":1,"pageTitle":"React Native Minimal Working Example","url":"/jellyfish-docs/0.2.0/tutorials/react-native#displaying-video-tracks","content":"The Room screen has a couple of responsibilities: it displays your own video. Note that it's taken directly from your camera i.e. we don't send it to the JF and get it back so other participants might see you a little bit differentlyit presents current room state so participants list, their video tiles, etc.it allows you to leave a meeting To get information about all participants (also the local one) in the room useusePeers() hook from Jellyfish Client. The hook returns all the participants with their ids, tracks and metadata. When a new participant joins or any participant leaves or anything else changes, the hook updates with the new information. To display video tracks Jellyfish Client comes with a dedicated component for displaying a video track: &lt;VideoRenderer&gt;. It takes a track id as a prop (it may be a local or remote track) and, as any other &lt;View&gt; in react, a style. style property gives a lot of possibilities. You can even animate your track! So, let's display all the participants in the simplest way possible: /screens/Room.tsx import React from &quot;react&quot;; import { View, StyleSheet } from &quot;react-native&quot;; import { NavigationProp, RouteProp } from &quot;@react-navigation/native&quot;; import { usePeers, VideoRendererView, } from &quot;@jellyfish-dev/react-native-client-sdk&quot;; interface RoomScreenProps { navigation: NavigationProp&lt;YourNavigatorParamList&gt;; } function RoomScreen({ navigation }: RoomScreenProps): JSX.Element { const peers = usePeers(); return ( &lt;View style={styles.container}&gt; &lt;View style={styles.videoContainer}&gt; {peers.map((peer) =&gt; peer.tracks[0] ? ( &lt;VideoRendererView trackId={peer.tracks[0].id} style={styles.video} /&gt; ) : null )} &lt;/View&gt; &lt;/View&gt; ); } const styles = StyleSheet.create({ container: { flex: 1, alignItems: &quot;center&quot;, justifyContent: &quot;space-between&quot;, backgroundColor: &quot;#F1FAFE&quot;, padding: 24, }, videoContainer: { flexDirection: &quot;row&quot;, gap: 8, flexWrap: &quot;wrap&quot;, }, video: { width: 200, height: 200 }, }); export default RoomScreen;  You should now see your own camera on your mobile device. You can add another participant and their new track (displaying for example rotating frog) in the dashboard like this:  It should show up in the Room screen automatically:  For your convenience in our components library we provided a component to layout videos in a nice grid: /screens/Room.tsx import { VideosGrid } from &quot;@jellyfish-dev/react-native-jellyfish-components&quot;; // ... function RoomScreen({ navigation }: RoomScreenProps): JSX.Element { const peers = usePeers(); return ( &lt;View style={styles.container}&gt; &lt;VideosGrid tracks={peers.map((peer) =&gt; peer.tracks[0]?.id).filter((t) =&gt; t)} /&gt; &lt;/View&gt; ); }  "},{"title":"Gracefully leaving the room​","type":1,"pageTitle":"React Native Minimal Working Example","url":"/jellyfish-docs/0.2.0/tutorials/react-native#gracefully-leaving-the-room","content":"To leave a room we'll add a button for the user. When the user clicks it, we gracefully leave the room, close the server connection and go back to theConnectscreen. For leaving the room and closing the server connection you can use the cleanUp method from the useJellyfishClient() hook. /screens/Room.tsx // ... import { usePeers, VideoRendererView, useJellyfishClient, } from &quot;@jellyfish-dev/react-native-client-sdk&quot;; import { InCallButton } from &quot;@jellyfish-dev/react-native-jellyfish-components&quot;; // ... function RoomScreen({ navigation }: RoomScreenProps): JSX.Element { const peers = usePeers(); const { cleanUp } = useJellyfishClient(); const onDisconnectPress = () =&gt; { cleanUp(); navigation.goBack(); }; return ( &lt;View style={styles.container}&gt; &lt;VideosGrid tracks={peers.map((peer) =&gt; peer.tracks[0]?.id).filter((t) =&gt; t)} /&gt; &lt;InCallButton type=&quot;disconnect&quot; iconName=&quot;phone-hangup&quot; onPress={onDisconnectPress} /&gt; &lt;/View&gt; ); } // ...  To launch your app, you can use the following command: iosandroid npm run ios  "},{"title":"Summary​","type":1,"pageTitle":"React Native Minimal Working Example","url":"/jellyfish-docs/0.2.0/tutorials/react-native#summary","content":"Congrats on finishing your first Jellyfish mobile application! In this tutorial, you've learned how to make a basic Jellyfish client application that streams and receives video tracks with WebRTC technology. But this was just the beginning. Jellyfish Client supports much more than just streaming camera: it can also stream audio, screencast your device's screen, configure your camera and audio devices, detect voice activity, control simulcast, bandwidth and encoding settings, show camera preview, display WebRTC stats and more to come. Check out our other tutorials to learn about those features. You can also take a look at our fully featured Videoroom Demo example:  "},{"title":"Simple React App","type":0,"sectionRef":"#","url":"/jellyfish-docs/0.2.0/tutorials/simple-react-app","content":"","keywords":""},{"title":"What you'll learn​","type":1,"pageTitle":"Simple React App","url":"/jellyfish-docs/0.2.0/tutorials/simple-react-app#what-youll-learn","content":"This tutorial will guide you through creating your first React project that uses the Jellyfish Client. By the end of the tutorial, you'll have a working web application that connects toJellyfish Media Server using WebRTC technology.  You can check out the finished project here "},{"title":"What do you need​","type":1,"pageTitle":"Simple React App","url":"/jellyfish-docs/0.2.0/tutorials/simple-react-app#what-do-you-need","content":"a little bit of experience in creating React appsIDE of your choice (for example Visual Studio Code)Node.js installed on your machine "},{"title":"Jellyfish architecture​","type":1,"pageTitle":"Simple React App","url":"/jellyfish-docs/0.2.0/tutorials/simple-react-app#jellyfish-architecture","content":"info You can learn more about Jellyfish architecture in Jellyfish docs. This section provides a brief description aimed at front-end developers Let's introduce some concepts first: Peer - A peer is a client-side entity that connects to the server to publish, subscribe or publish and subscribe to tracks published by components or other peers. You can think of it as a participant in a room. At the moment, there is only one type of peer - WebRTC.Track - An object that represents an audio or video stream. A track can be associated with a local media source, such as a camera or microphone, or a remote media source received from another user. Tracks are used to capture, transmit, and receive audio and video data in WebRTC applications.Room - In Jellyfish, a room serves as a holder for peers and components, its function varying based on application. From a front-end perspective, this will be probably one meeting or a broadcast. For a better understanding of these concepts here is an example of a room that holds a standard WebRTC conference from a perspective of the User:  In this example, peers stream multiple video and audio tracks. Peer #1 streams even two video tracks (camera and screencast track). You can differentiate between them by using track metadata. The user gets info about peers and their tracks from the server using Jellyfish Client. The user is also informed in real time about peers joining/leaving and tracks being added/removed. To keep this tutorial short we'll simplify things a little. Every peer will stream just one video track. "},{"title":"Connecting and joining the room​","type":1,"pageTitle":"Simple React App","url":"/jellyfish-docs/0.2.0/tutorials/simple-react-app#connecting-and-joining-the-room","content":"The general flow of connecting to the server and joining the room in a standard WebRTC conference setup looks like this:  The parts that you need to implement are marked in blue and things handled by Jellyfish are marked in red. Firstly, the user logs in. Then your backend authenticates the user and obtains a peer token. It allows the user to authenticate and join the room in Jellyfish Server. The backend passes the token to your front-end, and your front-end passes it to Jellyfish Client. The client establishes the connection with Jellyfish Server. Then Jellyfish Client sets up tracks (camera, microphone) to stream and joins the room on Jellyfish Server. Finally, your front-end can display the room for the user. For this tutorial we simplified this process a bit - you don't have to implement a backend or authentication. Jellyfish Dashboard will do this for you. It's also a nice tool to test and play around with Jellyfish. The flow with Jellyfish The dashboard looks like this:  You can see that the only things you need to implement are interactions with the user and Jellyfish Client. This tutorial will show you how to do it. "},{"title":"Setup​","type":1,"pageTitle":"Simple React App","url":"/jellyfish-docs/0.2.0/tutorials/simple-react-app#setup","content":""},{"title":"Create React + Vite project​","type":1,"pageTitle":"Simple React App","url":"/jellyfish-docs/0.2.0/tutorials/simple-react-app#create-react--vite-project","content":"Firstly create a brand new project. npm create vite@latest my-react-app -- --template react-ts  "},{"title":"Add dependencies​","type":1,"pageTitle":"Simple React App","url":"/jellyfish-docs/0.2.0/tutorials/simple-react-app#add-dependencies","content":"For this module to work you'll need to add our `react-client-sdk` package. This is necessary to create and connect Jellyfish Client. npm install https://github.com/jellyfish-dev/react-client-sdk#0.1.2  "},{"title":"Start the Jellyfish backend​","type":1,"pageTitle":"Simple React App","url":"/jellyfish-docs/0.2.0/tutorials/simple-react-app#start-the-jellyfish-backend","content":"For testing, we'll run the Jellyfish Media Server locally using Docker image: docker run -p 50000-50050:50000-50050/udp \\ -p 5002:5002/tcp \\ -e JF_CHECK_ORIGIN=false \\ -e JF_HOST=&lt;your ip address&gt;:5002 \\ -e JF_PORT=&quot;5002&quot; \\ -e JF_WEBRTC_USED=true \\ -e JF_WEBRTC_TURN_PORT_RANGE=50000-50050 \\ -e JF_WEBRTC_TURN_IP=&lt;your ip address&gt; \\ -e JF_WEBRTC_TURN_LISTEN_IP=0.0.0.0 \\ -e JF_SERVER_API_TOKEN=development \\ ghcr.io/jellyfish-dev/jellyfish:0.2.0  Make sure to set JF_WEBRTC_TURN_IP and JF_HOST to your local IP address. Without it, the mobile device won't be able to connect to the Jellyfish. tip To check your local IP you can use this handy command (Linux/macOS): ifconfig | grep &quot;inet &quot; | grep -Fv 127.0.0.1 | awk '{print $2}'  "},{"title":"Start the dashboard web front-end​","type":1,"pageTitle":"Simple React App","url":"/jellyfish-docs/0.2.0/tutorials/simple-react-app#start-the-dashboard-web-front-end","content":"There are a couple of ways to start the dashboard: Up-to-date versionDocker containerOfficial repository The current version of the dashboard is ready to use and availablehere. Ensure that it is compatible with your Jellyfish server! Please note that this dashboard only supports secure connections (https/wss) or connections to localhost. Any insecure requests (http/ws) will be automatically blocked by the browser. "},{"title":"(Optional) Add a bit of CSS styling​","type":1,"pageTitle":"Simple React App","url":"/jellyfish-docs/0.2.0/tutorials/simple-react-app#optional-add-a-bit-of-css-styling","content":"For this project, we prepared simple CSS classes, You are free to use it or create your own. "},{"title":"General project structure​","type":1,"pageTitle":"Simple React App","url":"/jellyfish-docs/0.2.0/tutorials/simple-react-app#general-project-structure","content":"Our app will consist of two parts: a component that will connect to the server and join the room a component that will display the video tracks from other participants "},{"title":"First step - prepare all the hooks and the context​","type":1,"pageTitle":"Simple React App","url":"/jellyfish-docs/0.2.0/tutorials/simple-react-app#first-step---prepare-all-the-hooks-and-the-context","content":"To connect to the Jellyfish backend, we need to create a Membrane Client instance. We can do it by using the create function from the@jellyfish-dev/react-client-sdk package. It needs two generic parameters: PeerMetadata - the type of metadata that will be sent to the server when connecting to the room (for example, user name) it has to be serializable TrackMetadata - the type of the metadata that will be sent to the server when sending a track (for example, track name) it has to be serializable as well App.tsx import React from &quot;react&quot;; import { create } from &quot;@jellyfish-dev/react-client-sdk&quot;; // Example metadata types for peer and track // You can define your metadata types just make sure they are serializable type PeerMetadata = { name: string; }; type TrackMetadata = { type: &quot;camera&quot; | &quot;screen&quot;; }; // Create a Jellyfish client instance // Since we will use this context outside of the component we need to export it export const { JellyfishContextProvider, // Context provider } = create&lt;PeerMetadata, TrackMetadata&gt;(); export const App = () =&gt; {};  "},{"title":"Now we need to wrap our app with the context provider​","type":1,"pageTitle":"Simple React App","url":"/jellyfish-docs/0.2.0/tutorials/simple-react-app#now-we-need-to-wrap-our-app-with-the-context-provider","content":"That's all we will need to do in this file. Simply import the JellyfishContextProvider along with the Appcomponent and wrap the App component with the JellyfishContextProvider: main.tsx import React from &quot;react&quot;; import ReactDOM from &quot;react-dom/client&quot;; import { App, JellyfishContextProvider } from &quot;./components/App&quot;; ReactDOM.createRoot(document.getElementById(&quot;root&quot;) as HTMLElement).render( &lt;React.StrictMode&gt; &lt;JellyfishContextProvider&gt; &lt;App /&gt; &lt;/JellyfishContextProvider&gt; &lt;/React.StrictMode&gt; );  "},{"title":"UI component that will connect to the server and join the room​","type":1,"pageTitle":"Simple React App","url":"/jellyfish-docs/0.2.0/tutorials/simple-react-app#ui-component-that-will-connect-to-the-server-and-join-the-room","content":"The UI of the component will be quite simple. It will consist of a simple text input field that will allow us to enter the peer token and a button that will connect to the server and join the room. We can also display the status of the connection. App.tsx import React, { useState } from &quot;react&quot;; //... export const App = () =&gt; { // Create a state to store the peer token const [token, setToken] = useState(&quot;&quot;); return ( &lt;div style={{ display: &quot;flex&quot;, flexDirection: &quot;column&quot;, gap: &quot;8px&quot; }}&gt; &lt;input value={token} onChange={(e) =&gt; setToken(() =&gt; e?.target?.value)} placeholder=&quot;token&quot; /&gt; &lt;div style={{ display: &quot;flex&quot;, flexDirection: &quot;row&quot;, gap: &quot;8px&quot; }}&gt; &lt;button disabled={} onClick={() =&gt; {}}; &gt; Connect &lt;/button&gt; &lt;button disabled={} onClick={() =&gt; {}}; &gt; Disconnect &lt;/button&gt; &lt;span&gt;Status: {}&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; ); };  "},{"title":"Once the UI is ready, we need to implement the logic​","type":1,"pageTitle":"Simple React App","url":"/jellyfish-docs/0.2.0/tutorials/simple-react-app#once-the-ui-is-ready-we-need-to-implement-the-logic","content":"App.tsx import { SignalingUrl } from &quot;@jellyfish-dev/react-client-sdk/.&quot;; //... export const { useStatus, // Hook to check the status of the connection useConnect, // Hook to connect to the server useDisconnect, // Hook to disconnect from the server JellyfishContextProvider, // Context provider }; export const App = () =&gt; { // Create a state to store the peer token const [token, setToken] = useState(&quot;&quot;); // Use the built-in hook to check the status of the connection const status = useStatus(); const connect = useConnect(); const disconnect = useDisconnect(); return ( &lt;div style={{ display: &quot;flex&quot;, flexDirection: &quot;column&quot;, gap: &quot;8px&quot; }}&gt; &lt;input className=&quot;input-field&quot; value={token} onChange={(e) =&gt; setToken(() =&gt; e?.target?.value)} placeholder=&quot;token&quot; /&gt; &lt;div style={{ display: &quot;flex&quot;, flexDirection: &quot;row&quot;, gap: &quot;8px&quot; }}&gt; &lt;button className=&quot;button&quot; disabled={token === &quot;&quot; || status === &quot;joined&quot;} // simple check to avoid errors onClick={() =&gt; { connect({ peerMetadata: { name: &quot;John Doe&quot; }, // example metadata token: token, }); }} &gt; Connect &lt;/button&gt; &lt;button className=&quot;button&quot; disabled={status !== &quot;joined&quot;} onClick={() =&gt; { disconnect(); }} &gt; Disconnect &lt;/button&gt; &lt;span className=&quot;span-status&quot;&gt;Status: {status}&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; ); };  Great! Now we can connect to the server and join the room. But we still need to add some logic to send our tracks to the server and receive tracks from others. "},{"title":"Let's send our screen to the server​","type":1,"pageTitle":"Simple React App","url":"/jellyfish-docs/0.2.0/tutorials/simple-react-app#lets-send-our-screen-to-the-server","content":"This hook uses Navigator.mediaDevices take a look how it works App.tsx import React, { useEffect, useState } from &quot;react&quot;; import { create, SCREEN_SHARING_MEDIA_CONSTRAINTS } from &quot;@jellyfish-dev/react-client-sdk&quot;; import { SignalingUrl, Peer } from &quot;@jellyfish-dev/react-client-sdk/.&quot;; //... export const { useStatus, // Hook to check the status of the connection useApi, // Hook to get the webrtcApi reference useConnect, // Hook to connect to the server useDisconnect, // Hook to disconnect from the server JellyfishContextProvider, // Context provider } = create&lt;PeerMetadata, TrackMetadata&gt;(); export const App = () =&gt; { //... // Get the webrtcApi reference const webrtcApi = useApi(); function startScreenSharing() { // Get screen sharing MediaStream navigator.mediaDevices.getDisplayMedia(SCREEN_SHARING_MEDIA_CONSTRAINTS).then((screenStream) =&gt; { // Add local MediaStream to webrtc screenStream.getTracks().forEach((track) =&gt; webrtcApi.addTrack(track, screenStream, { type: &quot;screen&quot; })); }; }; return ( //... &lt;button className=&quot;button&quot; disabled={status !== &quot;joined&quot;} onClick={() =&gt; { startScreenSharing(); }} &gt; Start screen share &lt;/button&gt; &lt;span&gt;Status: {status}&lt;/span&gt; //... ) };  You should now see your screen received for each connected client on the dashboard. You can add another participant to check this out! The streaming part of the app is ready! "},{"title":"What about the receiving part?​","type":1,"pageTitle":"Simple React App","url":"/jellyfish-docs/0.2.0/tutorials/simple-react-app#what-about-the-receiving-part","content":""},{"title":"This is where the second component comes in handy​","type":1,"pageTitle":"Simple React App","url":"/jellyfish-docs/0.2.0/tutorials/simple-react-app#this-is-where-the-second-component-comes-in-handy","content":"For each track received, we will create a new video element and display it on the screen. For clarity, we will separate this component into another file: Create in your directory file VideoPlayer.tsx VideoPlayer.tsx type Props = { stream: MediaStream | null | undefined; }; const VideoPlayer = ({ stream }: Props) =&gt; { return ( &lt;div className=&quot;video-container&quot;&gt; &lt;video autoPlay playsInline muted ref={/* place for track ref*/} /&gt; &lt;/div&gt; ); }; export default VideoPlayer;  "},{"title":"Now the logic for the component​","type":1,"pageTitle":"Simple React App","url":"/jellyfish-docs/0.2.0/tutorials/simple-react-app#now-the-logic-for-the-component","content":"VideoPlayer.tsx type Props = { stream: MediaStream | null | undefined; }; const VideoPlayer = ({ stream }: Props) =&gt; { const videoRef: RefObject&lt;HTMLVideoElement&gt; = useRef&lt;HTMLVideoElement&gt;(null); useEffect(() =&gt; { if (!videoRef.current) return; videoRef.current.srcObject = stream || null; }, [stream]); return ( &lt;div&gt; &lt;video autoPlay playsInline muted ref={videoRef} /&gt; &lt;/div&gt; ); }; export default VideoPlayer;  "},{"title":"Now we can use it in our main component​","type":1,"pageTitle":"Simple React App","url":"/jellyfish-docs/0.2.0/tutorials/simple-react-app#now-we-can-use-it-in-our-main-component","content":"App.tsx import React, { useEffect, useState } from &quot;react&quot;; import { create, SCREEN_SHARING_MEDIA_CONSTRAINTS } from &quot;@jellyfish-dev/react-client-sdk&quot;; import { SignalingUrl, Peer } from &quot;@jellyfish-dev/react-client-sdk/.&quot;; import VideoPlayer from &quot;./VideoPlayer&quot;; //... export const { useStatus, // Hook to check the status of the connection useTracks, // Hook to get the tracks from the server useApi, // Hook to get the webrtcApi reference useConnect, // Hook to connect to the server useDisconnect, // Hook to disconnect from the server JellyfishContextProvider, // Context provider } = create&lt;PeerMetadata, TrackMetadata&gt;(); export const App = () =&gt; { const tracks = useTracks(); //... &lt;div style={{ display: &quot;flex&quot;, flexWrap: &quot;wrap&quot;, justifyContent: &quot;center&quot;, // To align items in the center gap: &quot;20px&quot;, }} &gt; {Object.values(tracks).map(({ stream, trackId }) =&gt; ( &lt;VideoPlayer key={trackId} stream={stream} /&gt; // pass the stream to the component ))} &lt;/div&gt; //... )  You should see all the tracks sent from the dashboard directly on your page, to test them, add a new client, and add a track (for example a rotating frog). It will show up in your app automatically: "},{"title":"Summary​","type":1,"pageTitle":"Simple React App","url":"/jellyfish-docs/0.2.0/tutorials/simple-react-app#summary","content":"Congrats on finishing your first Jellyfish web application! In this tutorial, You've learned how to make a basic Jellyfish client application that streams your screen and receives video tracks with WebRTC technology. But this was just the beginning. Jellyfish Client supports much more than just streaming camera: It can also stream audio or your device's camera, configure your camera and audio devices, detect voice activity, control simulcast, bandwidth and encoding settings, show camera preview, display WebRTC stats and more to come. Check out our other tutorials to learn about those features. You can also take a look at our fully featured Videoroom Demo example:  "},{"title":"Benchmarks","type":0,"sectionRef":"#","url":"/jellyfish-docs/next/benchmarks","content":"","keywords":""},{"title":"HLS​","type":1,"pageTitle":"Benchmarks","url":"/jellyfish-docs/next/benchmarks#hls","content":"The conducted stress tests were geared towards assessing performance of both regular HLS and Low-Latency HLS under substantial load. We assumed a livestream scenario, where all of the clients demanded the most recent segments or partial segments as they were produced. This model closely simulates real-time broadcasting situations where all participants are consuming the same (latest) content concurrently. It could be contrasted e.g. with a video-on-demand (VOD) scenario, where any client can request any segment at any given time. "},{"title":"Setup​","type":1,"pageTitle":"Benchmarks","url":"/jellyfish-docs/next/benchmarks#setup","content":"Machine A, running Jellyfish with one room One WebRTC peer in the room (WebRTC video stream with constant bitrate of 1.8 Mbps)One HLS component in the room (segment length: 6 s, partial segment length: 1 s) Machine B, running a stress test utility The utility steadily increases the number of simulated clients over the course of the test, up to a given amountClients simulate an HLS player continuously requesting the most recent segments/partials (as if watching a livestream)Each client opens a separate connection to Jellyfish on machine A (no connection pooling) Machine specs​ CPU: AMD EPYC 7502P (32 cores, 64 threads at 2.5 GHz)Memory: 128 GBNetwork bandwidth (A &lt;---&gt; B): 10 Gbps "},{"title":"Test results​","type":1,"pageTitle":"Benchmarks","url":"/jellyfish-docs/next/benchmarks#test-results","content":"We varied the number of client connections and recorded server metrics at each level to determine how it would perform under increasing load. Values for mean incoming throughput, mean and peak outgoing throughput, peak memory used, peak CPU utilisation and mean request latency (grouped by request type) were all recorded. Before any clients were connected to the server, the memory usage stood at 130 MB and CPU utilisation was noted at 11%. These values serve as the base or idle state of the server for comparison against the usage under stress testing. info It's important to remember that, in the context of HLS, the outgoing throughput is greatly influenced by the bitrate of the generated segments, which is directly connected to the bitrate of the streams used for segment generation. Specifically, for video streams featuring high and fluctuating bitrates (such as sports events and video game live streams) you may typically observe amplified mean and peak outgoing throughputs. Caveat Values italicised in the Latency columns indicate instances where network bandwidth limits were reached, resulting in throttling; in such cases, the observed latency does not reflect the server's innate processing capabilities. Regular HLS​ Client connections\tIncoming throughput (mean)\tOutgoing throughput (mean)\tOutgoing throughput (peak)\tMemory used (peak)\tCPU utilisation (peak)\tPlaylist request latency (mean)\tSegment request latency (mean)500\t6 Mbps\t0.9 Gbps\t1.3 Gbps\t0.9 GB\t18%\t4 ms\t66 ms 1000\t12 Mbps\t1.9 Gbps\t2.6 Gbps\t1.9 GB\t19%\t3 ms\t65 ms 2000\t24 Mbps\t3.6 Gbps\t5.2 Gbps\t2.8 GB\t23%\t3 ms\t66 ms 3000\t36 Mbps\t5.1 Gbps\t6.5 Gbps\t4.5 GB\t30%\t4 ms\t67 ms 4000\t48 Mbps\t7.0 Gbps\t9.2 Gbps (limit)\t9.2 GB\t34%\t17 ms*\t243 ms* Low-Latency HLS​ In Low-Latency HLS, the server intentionally delays the response to playlist requests until the specifically requested partial segment becomes available. This makes the &quot;Playlist request latency (mean)&quot; metric meaningless, and it is thus omitted from the following table. Client connections\tIncoming throughput (mean)\tOutgoing throughput (mean)\tOutgoing throughput (peak)\tMemory used (peak)\tCPU utilisation (peak)\tPartial segment request latency (mean)500\t25 Mbps\t1.1 Gbps\t4.7 Gbps\t210 MB\t25%\t98 ms 1000\t50 Mbps\t2.3 Gbps\t9.0 Gbps\t290 MB\t34%\t138 ms 1500\t75 Mbps\t3.3 Gbps\t9.2 Gbps (limit)\t340 MB\t43%\t244 ms* 2000\t100 Mbps\t4.5 Gbps\t9.2 Gbps (limit)\t410 MB\t47%\t341 ms* 2500\t125 Mbps\t5.7 Gbps\t9.2 Gbps (limit)\t480 MB\t48%\t402 ms* 3000\t150 Mbps\t6.6 Gbps\t9.2 Gbps (limit)\t560 MB\t50%\t514 ms* "},{"title":"What is Jellyfish?","type":0,"sectionRef":"#","url":"/jellyfish-docs/next","content":"","keywords":""},{"title":"Supported protocols​","type":1,"pageTitle":"What is Jellyfish?","url":"/jellyfish-docs/next#supported-protocols","content":"Jellyfish supports following protocols: WebRTC - used for creating real-time video conferencing systemsHLS - allows for implementing broadcasting solutionsRTSP - very often used for consuming streams from IP cameras "},{"title":"Fly.io (experimental)","type":0,"sectionRef":"#","url":"/jellyfish-docs/next/deploying/fly_io","content":"","keywords":""},{"title":"Creating new app​","type":1,"pageTitle":"Fly.io (experimental)","url":"/jellyfish-docs/next/deploying/fly_io#creating-new-app","content":"Launch fly launch. When prompted, copy the configuration from the existing fly.toml file. Select appropriate app name and region, don't create any databases. Don't deploy the app just yet. Running fly launch may modify the Dockerfile. Make sure to remove the lines appended by flyctl. "},{"title":"Configuring the App​","type":1,"pageTitle":"Fly.io (experimental)","url":"/jellyfish-docs/next/deploying/fly_io#configuring-the-app","content":"Before deploying your app, make sure it is correctly configured. "},{"title":"Dedicated IPv4​","type":1,"pageTitle":"Fly.io (experimental)","url":"/jellyfish-docs/next/deploying/fly_io#dedicated-ipv4","content":"In order to transmit multimedia via UDP, the app has to be publicly available with an IPv4 address. By default Fly.io uses shared IP. To enable dedicated IPv4 address run fly ips allocate-v4  Note, that dedicated IP address is a paid feature on Fly.io. You can learn more about dedicated IPv4 address here. "},{"title":"fly.toml​","type":1,"pageTitle":"Fly.io (experimental)","url":"/jellyfish-docs/next/deploying/fly_io#flytoml","content":"Make sure you don't have the following lines in the fly.toml, which are automatically generated by fly launch. You don't need to run migrations, since you don't have a database. [deploy] release_command = &quot;/app/bin/migrate&quot;  Jellyfish uses JF_HOST variable instead of the default PHX_HOST. JF_HOST = &quot;&lt;YOUR APP HOSTNAME&gt;&quot;  Also, make sure you have set the correct port. The environment variable JF_PORT has to match the TCP internal_port defined under services section. The default for Jellyfish is 5002 in development and 8080 in production (when using Docker or mix release). To be able to receive and send UDP traffic, Jellyfish has to open its UDP ports on a special fly-global-services address, not 0.0.0.0. This must be set using the JF_WEBRTC_TURN_LISTEN_IP enviroment variable. You also need to specify the Jellyfish IP address for UDP, it is the IP address which you generated in the previous step. JF_WEBRTC_TURN_LISTEN_IP = &quot;fly-global-services&quot; JF_WEBRTC_TURN_IP=&quot;&lt;YOUR APP IP ADDRESS&gt;&quot;  You can also read tutorial for running Fly.io apps which use UDP. "},{"title":"Fly.io secrets​","type":1,"pageTitle":"Fly.io (experimental)","url":"/jellyfish-docs/next/deploying/fly_io#flyio-secrets","content":"There are environment variables, which you may not want to keep in the fly.toml config. Fly.io provides a way to store such values securely. For Jellyfish you need to configure just one secret - JF_SERVER_API_TOKEN. flyctl secrets set JF_SERVER_API_TOKEN=development  "},{"title":"Deploying​","type":1,"pageTitle":"Fly.io (experimental)","url":"/jellyfish-docs/next/deploying/fly_io#deploying","content":"With everything configured you can deploy the app fly deploy  Note that it may take a moment for the UDP traffic to be forwarded to the application. This means for example, that WebRTC may not be working yet. This is the tricky part of the deployment, which we weren't able to entirely figure out. Sometimes the UDP just works, others it takes ages for it to start flowing.This topic describes the exact issue we had with Fly.io. In general, it is unclear when the UDP traffic starts to be forwarded, sometimes it happens relatively quickly after deployment, sometimes you need to wait for some time. Also, the Fly.io documentation isn't clear in regard to opening UDP sockets. Some information was gathered experimentally, or based on Fly.io community questions, such as this one. "},{"title":"Cluster","type":0,"sectionRef":"#","url":"/jellyfish-docs/next/cluster","content":"","keywords":""},{"title":"Strategies​","type":1,"pageTitle":"Cluster","url":"/jellyfish-docs/next/cluster#strategies","content":"Currently, Jellyfish supports two clustering strategies: NODES_LIST and DNS, but other strategies might be added in the future. NODES_LIST - form a cluster basing on a list of Jellyfish addressesDNS - regularly query DNS to discover other Jellyfishes Regardless of the strategy, Erlang Distribution is transitive. When node A connects to node B, it also connects to all other nodes that node B is connected to. "},{"title":"NODES_LIST​","type":1,"pageTitle":"Cluster","url":"/jellyfish-docs/next/cluster#nodes_list","content":"To form a cluster using NODES_LIST strategy: Enable distribution mode with JF_DIST_ENABLED=trueGive your node a name with JF_DIST_NODE_NAMESpecify a list of nodes to connect to with JF_DIST_NODES "},{"title":"Running from source​","type":1,"pageTitle":"Cluster","url":"/jellyfish-docs/next/cluster#running-from-source","content":"Run the first Jellyfish: JF_DIST_ENABLED=true JF_DIST_NODE_NAME=j1@127.0.0.1 mix phx.server  Run the second Jellyfish JF_DIST_ENABLED=true JF_DIST_NODE_NAME=j2@127.0.0.1 JF_DIST_NODES=&quot;j1@127.0.0.1&quot; JF_PORT=4002 JF_METRICS_PORT=9468 mix phx.server  info Note that when running the second Jellyfish, we had to change its HTTP and metrics ports. "},{"title":"Running with Docker (locally)​","type":1,"pageTitle":"Cluster","url":"/jellyfish-docs/next/cluster#running-with-docker-locally","content":"This simple docker compose file sets a cluster of two Jellyfishes. version: &quot;3&quot; x-jellyfish-template: &amp;jellyfish-template build: . environment: &amp;jellyfish-environment JF_SERVER_API_TOKEN: &quot;development&quot; JF_DIST_ENABLED: &quot;true&quot; JF_DIST_MODE: &quot;sname&quot; JF_DIST_NODES: &quot;j1@jellyfish1 j2@jellyfish2&quot; restart: on-failure services: jellyfish1: &lt;&lt;: *jellyfish-template environment: &lt;&lt;: *jellyfish-environment JF_HOST: &quot;localhost:5001&quot; JF_PORT: 5001 JF_METRICS_PORT: 6001 JF_DIST_NODE_NAME: j1@jellyfish1 ports: - 5001:5001 - 6001:6001 jellyfish2: &lt;&lt;: *jellyfish-template environment: &lt;&lt;: *jellyfish-environment JF_HOST: &quot;localhost:5002&quot; JF_PORT: 5002 JF_METRICS_PORT: 6002 JF_DIST_NODE_NAME: j2@jellyfish2 ports: - 5002:5002 - 6002:6002  Because we run Jellyfishes in the same Docker network: we can use JF_DIST_NODE: &quot;sname&quot;, which allows us to reference Jellyfishes using their service names sojellyfish1 and jellyfish2we don't need to export EPMD (4369) or distribution (9000) ports "},{"title":"Running with Docker (globally)​","type":1,"pageTitle":"Cluster","url":"/jellyfish-docs/next/cluster#running-with-docker-globally","content":"When forming a cluster across multiple machines: you have to take care of Extra Network Configurationyou also can't use JF_DIST_MODE=&quot;sname&quot; as you have to name Jellyfish nodes using their publicly available IP address or domain names (see JF_DIST_NODE_NAME and JF_DIST_MODE)you can't simulate this setup locally as you won't be able to expose two EMPD ports on the same machine. See Deeper dive into Erlang Distribution for more information. See our Jellyfish Videoroom deployment configuration for an example. "},{"title":"DNS​","type":1,"pageTitle":"Cluster","url":"/jellyfish-docs/next/cluster#dns","content":"To form a cluster using DNS strategy: Enable distribution mode with JF_DIST_ENABLED=trueChose DNS strategy with JF_DIST_STRATEGY_NAME.Give your node a name with JF_DIST_NODE_NAME. Important It has to be in the form of &lt;nodename&gt;@&lt;ip_address&gt;where all Jellyfishes MUST have the same &lt;nodename&gt;.Specify a query under which Jellyfishes are register in DNS with JF_DIST_QUERY. Important Jellyfish does not register itself in DNS. It is user responsibility to enusre that your Jellyfish is registered in DNS under JF_DIST_QUERY. "},{"title":"Running with Docker​","type":1,"pageTitle":"Cluster","url":"/jellyfish-docs/next/cluster#running-with-docker","content":"This simple docker compose file sets a cluster of two Jellyfishes and starts a DNS with use of dnsmasq. version: &quot;3&quot; x-jellyfish-template: &amp;jellyfish-template build: . environment: &amp;jellyfish-environment JF_SERVER_API_TOKEN: &quot;development&quot; JF_DIST_ENABLED: &quot;true&quot; JF_DIST_STRATEGY_NAME: &quot;DNS&quot; restart: on-failure services: app1: &lt;&lt;: *jellyfish-template environment: &lt;&lt;: *jellyfish-environment JF_HOST: &quot;localhost:4001&quot; JF_PORT: 4001 JF_DIST_NODE_NAME: app@172.28.1.2 JF_DIST_QUERY: app.dns-network ports: - 4001:4001 networks: dns-network: ipv4_address: 172.28.1.2 aliases: - app.dns-network dns: - 172.28.1.4:5353 app2: container_name: name &lt;&lt;: *jellyfish-template environment: &lt;&lt;: *jellyfish-environment JF_HOST: &quot;localhost:4002&quot; JF_PORT: 4002 JF_DIST_NODE_NAME: app@172.28.1.3 JF_DIST_QUERY: app.dns-network ports: - 4002:4002 networks: dns-network: ipv4_address: 172.28.1.3 aliases: - app.dns-network dns: - 172.28.1.4:5353 dnsmasq: image: andyshinn/dnsmasq:2.78 volumes: - /etc/resolv.conf:/etc/resolv.dnsmasq.conf command: -d -q --no-hosts --no-resolv --no-poll --server 127.0.0.11 --listen-address 0.0.0.0 --port 5353 --log-queries --log-facility=- --address=/./127.0.0.11 networks: dns-network: ipv4_address: 172.28.1.4 aliases: - dnsmasq networks: dns-network: ipam: config: - subnet: 172.28.1.0/24  Because we run Jellyfishes in the same Docker network we don't need to export EPMD (4369) or distribution (9000) ports. "},{"title":"Verifying that a cluster has been created​","type":1,"pageTitle":"Cluster","url":"/jellyfish-docs/next/cluster#verifying-that-a-cluster-has-been-created","content":"When a cluster is created correctly you will see a log indicating that one of your Jellyfishes connected to the other one, e.g.: [info] [libcluster:epmd_cluster] connected to :&quot;j1@127.0.0.1&quot;  To see clustering in action, create two rooms using the same Jellyfish address and observe how they are load balanced: curl -X POST -H &quot;authorization: Bearer development&quot; http://localhost:4002/room # {&quot;data&quot;:{&quot;jellyfish_address&quot;:&quot;localhost:4001&quot;}}  curl -X POST -H &quot;authorization: Bearer development&quot; http://localhost:4002/room # {&quot;data&quot;:{&quot;jellyfish_address&quot;:&quot;localhost:4002&quot;}}  Load balancing can also be tested using Jellyfish Dashboard. See here for more information. "},{"title":"Deeper dive into Erlang Distribution​","type":1,"pageTitle":"Cluster","url":"/jellyfish-docs/next/cluster#deeper-dive-into-erlang-distribution","content":"The most tricky thing when running Jellyfish in a cluster is to understand the role of EPMD. EPMD is responsible for mapping node names to ports they use. Node names consist of two parts nodename@hostname.hostname identifies a host machine, and nodename identifies a node on this machine. When node A wants to connect to node B, it uses node's B name to ask EPMD (running on node B) for the actual port node B is accessible on. Example Let's assume that node's B name is nodeb@192.168.1.2.Node A will contact EPMD using 192.168.1.2 IP address and port 4369, and ask for the port number used by a node with the name nodeb.After that, node A can contact node B using 192.168.1.2 IP address and port returned by EPMD. A couple of notes about EPMD: it always uses port 4369 (TCP)it is started automatically when running Jellyfishthere is one EPMD per machine or one EPMD per docker container - that's why we can't simulate Global Docker setup locally You can read more about Erlang Distribution here. "},{"title":"Examples","type":0,"sectionRef":"#","url":"/jellyfish-docs/next/examples","content":"Examples Jellyfish usage examples utilising server SDKs can be found in the following locations: Elixir","keywords":""},{"title":"API Reference","type":0,"sectionRef":"#","url":"/jellyfish-docs/next/for_developers/api_reference","content":"API Reference Jellyfish API is composed of three layers a REST API for managing Jellyfish statea WS connection for client SDK communication (socket path /socket/peer)a WS connection for server notifications (socket path /socket/server) You can find them here: OpenAPI REST descriptionProtobufs used by peer WSProtobufs used by server WS The communication via WebSockets uses Protobuf format. The very first message that has to be sent on either of the WebSocket connections (peer to Jellyfish oryour_backend_server to Jellyfish) is AuthRequest. All supported messages are listed in the Jellyfish protos repo. If you want to create your own Jellyfish SDK, the easiest way to reference defined protobuf messages will be by adding protos to your git repository as a git submodule. You can do it with this command: git submodule add https://github.com/jellyfish-dev/protos You could also consider creating a script that will pull the newest changes from the git submodule and compile.proto files to your chosen programming language. For reference, see the script used in our Elixir SDK.","keywords":""},{"title":"Cloud VPS with cloud-init","type":0,"sectionRef":"#","url":"/jellyfish-docs/next/deploying/vps","content":"","keywords":""},{"title":"1. Creating primary IP​","type":1,"pageTitle":"Cloud VPS with cloud-init","url":"/jellyfish-docs/next/deploying/vps#1-creating-primary-ip","content":"Because configuring a server with cloud-init using our script requires you to have a registered domain pointing at a particular IP address, we divided the process of creating VPS into two parts: obtaining dedicated IP addressconfiguring the server using cloud-init Let's start with the first one. In Hetzner's project site go to the section Primary IPs then click Create Primary IP button. Choose a data center location for your server and select IPv4 protocol. You can also name that IP if you'd like. "},{"title":"2. Registering Domain​","type":1,"pageTitle":"Cloud VPS with cloud-init","url":"/jellyfish-docs/next/deploying/vps#2-registering-domain","content":"We'll not suggest you to use a specific domain provider, maybe you've got one chosen so we'll describe this step without details that may be different among providers. If you'd like, you can use Hetzner as well to register a domain. After registering your domain go to the DNS Records Table of your provider and create an A record pointing to the IP you've created in the previous step. "},{"title":"3. Choosing the right VPS​","type":1,"pageTitle":"Cloud VPS with cloud-init","url":"/jellyfish-docs/next/deploying/vps#3-choosing-the-right-vps","content":"Now let's go back to the Hetzner project site. It's time to choose and configure a server for Jellyfish. Although Jellyfish doesn't have minimum requirements to work, we encourage you to choose a middle-sized VPS (at least 8 cores) as media processing is consuming quite a lot of CPU. Remember to choose a server located in the data center where you've created an IP address in the first step. For this tutorial, we decided on CPX21 from Hetzner Cloud running Ubuntu 22:  "},{"title":"4. Assigning Primary IP​","type":1,"pageTitle":"Cloud VPS with cloud-init","url":"/jellyfish-docs/next/deploying/vps#4-assigning-primary-ip","content":"Below the list of the VPS types there is a Networking section where your Primary IP from Step 1 is waiting to be used. Select it.  "},{"title":"5. Adding a cloud-init configuration​","type":1,"pageTitle":"Cloud VPS with cloud-init","url":"/jellyfish-docs/next/deploying/vps#5-adding-a-cloud-init-configuration","content":"To configure a server and install Jellyfish on it we're going to use cloud-init. It's a preinstalled tool that lets you set up a newly created server with a YAML config file. In the configuration you can create a user, choose packages to be installed, configure them, write or modify files and in our case finally run a docker container. Full documentation about keys you can use in a cloud-config file can be found in the official cloud-init documentation. "},{"title":"A cloud-config template​","type":1,"pageTitle":"Cloud VPS with cloud-init","url":"/jellyfish-docs/next/deploying/vps#a-cloud-config-template","content":"We prepared a template cloud-config that will configure your server and start a chosen version of Jellyfish: cloud-config.yaml #cloud-config users: - name: jellyfish groups: docker sudo: null shell: /bin/false no_create_home: true ssh_pwauth: false disable_root_opts: no-port-forwarding,no-agent-forwarding,no-X11-forwarding apt: sources: docker.list: source: &quot;deb [arch=amd64,arm64] https://download.docker.com/linux/ubuntu jammy stable&quot; keyid: 9DC858229FC7DD38854AE2D88D81803C0EBFCD88 packages: - ufw - fail2ban - gzip - containerd.io - docker-ce - docker-ce-cli - nginx - certbot write_files: - path: /opt/jellyfish/env-file defer: true owner: jellyfish:jellyfish runcmd: - export JELLYFISH_VERSION=0.2.0 - export JELLYFISH_DOMAIN=mydomain.example.com - export LETSENCRYPT_EMAIL=my@email.com - export SERVER_API_TOKEN=test_token - systemctl enable fail2ban - ufw default deny outgoing - ufw default deny incoming - ufw default deny routed - ufw allow in ssh - ufw allow out https - ufw allow out domain - ufw allow in 80/tcp - ufw allow in 443/tcp - ufw allow in 50000:500100/udp - ufw allow in 49999/tcp - ufw allow out 5002 - ufw allow out from any port 50000:50100 proto udp to any - ufw allow out 49999 proto tcp to any - ufw enable - service nginx stop - &quot;[ ! -f /etc/letsencrypt/live/$JELLYFISH_DOMAIN/cert.pem ] &amp;&amp; certbot certonly --standalone --noninteractive --agree-tos --email $LETSENCRYPT_EMAIL -d $JELLYFISH_DOMAIN&quot; - | cat &lt;&lt; EOF &gt; /etc/cron.d/cert_renew 0 4 * * * [jellyfish] certbot certonly --webroot -w /usr/share/nginx/html -d $JELLYFISH_DOMAIN --keep-until-expiring --quiet 5 4 * * * [jellyfish] service nginx reload EOF - | cat &lt;&lt; EOF &gt; /etc/nginx/sites-available/$JELLYFISH_DOMAIN server { server_name $JELLYFISH_DOMAIN; location / { proxy_pass http://localhost:5002; proxy_http_version 1.1; proxy_set_header Upgrade \\$http_upgrade; proxy_set_header Connection &quot;Upgrade&quot;; proxy_set_header Host \\$host; } listen [::]:443 ssl http2; # managed by Certbot listen 443 ssl http2; # managed by Certbot ssl_certificate /etc/letsencrypt/live/$JELLYFISH_DOMAIN/fullchain.pem; # managed by Certbot ssl_certificate_key /etc/letsencrypt/live/$JELLYFISH_DOMAIN/privkey.pem; # managed by Certbot } server { listen 80; listen [::]:80; server_name $JELLYFISH_DOMAIN; # Do not HTTPS redirect Let'sEncrypt ACME challenge location /.well-known/acme-challenge/ { auth_basic off; allow all; root /usr/share/nginx/html; try_files \\$uri =404; break; } location / { return 301 https://\\$host\\$request_uri; } } EOF - ln -sf /etc/nginx/sites-available/$JELLYFISH_DOMAIN /etc/nginx/sites-enabled/$JELLYFISH_DOMAIN - service nginx start - | cat &lt;&lt; EOF &gt; /opt/jellyfish/env-file JF_HOST=$JELLYFISH_DOMAIN JF_PORT=5002 JF_SERVER_API_TOKEN=$SERVER_API_TOKEN JF_CHECK_ORIGIN=false JF_WEBRTC_TURN_IP=$(ip route get 1.0.0.0 | sed -n 's/^.*src \\([0-9.]*\\) .*$/\\1/p') JF_WEBRTC_TURN_TCP_PORT=49999 JF_WEBRTC_TURN_PORT_RANGE=50000-50100 JF_WEBRTC_TURN_LISTEN_IP=0.0.0.0 EOF - [ su, jellyfish, -s, /bin/bash, -c, &quot;docker run -d \\ --restart unless-stopped \\ -p 50000-50100:50000-50100/udp \\ -p 5002:5002 \\ --env-file /opt/jellyfish/env-file \\ -v /opt/jellyfish/jellyfish_output:/app/jellyfish_output \\ ghcr.io/jellyfish-dev/jellyfish:$JELLYFISH_VERSION&quot;, ]  You'll need to manually take care of four lines in that template: - export JELLYFISH_VERSION=0.1.0-ed317bChange the value if you want to deploy a different version of Jellyfish. You can find the list of available versions in our package repository- export JELLYFISH_DOMAIN=mydomain.example.comEnter here a domain you've configured with A record in step 2.- export LETSENCRYPT_EMAIL=my@email.comEnter your email address to be notified when the SSL certificate will be about to expire.export SERVER_API_TOKEN=test_tokenServer API token is a token you'll need to connect to Jellyfish via API or SDK. Write here a chosen secret value you're going to remember later. Copy the file and change up those two variables. You're going to need the content of the file in the next section. "},{"title":"Other tools we'll install with cloud-init​","type":1,"pageTitle":"Cloud VPS with cloud-init","url":"/jellyfish-docs/next/deploying/vps#other-tools-well-install-with-cloud-init","content":"As you might noticed we've chosen some packages to be installed: ufw - Uncomplicated Firewall. We'll need it to allow or block traffic on specific ports https://help.ubuntu.com/community/UFW.fail2ban - Tool to block traffic recognized as unauthorized https://www.fail2ban.org/wiki/index.php/Main_Pagegzip - Compression Utility https://www.gzip.org/containerd.io, docker-ce, docker-ce-cli - Docker and Docker-related libraries. "},{"title":"Setting up Hetzner cloud VPS with cloud-config​","type":1,"pageTitle":"Cloud VPS with cloud-init","url":"/jellyfish-docs/next/deploying/vps#setting-up-hetzner-cloud-vps-with-cloud-config","content":"Now, we're going to use the content of the file you prepared in the Hetzner cloud VPS creating form. To do it scroll to the Cloud config section of the form and paste the content of your cloud-config.yaml file.  caution cloud-init will recognize the file as a configuration only if the file starts with that comment: #cloud-config ... So be careful while copying. That's it. You can click 'Create &amp; Buy' and the server will start to configure. tip Think about adding your public SSH key while creating a VPS instance. It will ease up connecting to VPS later. If you don't add any key you're going to need a root password (you'll receive it in an email after creating VPS) "},{"title":"6. Checking cloud-init status​","type":1,"pageTitle":"Cloud VPS with cloud-init","url":"/jellyfish-docs/next/deploying/vps#6-checking-cloud-init-status","content":"Configuring your server will take some time, but it's created almost immediately after creation. You can log into the server using ssh: ssh root@&lt;VPS_IP&gt;  then, in the server's terminal you can check the current status of cloud-init: cloud-init status  Possible responses are running, error and done. The first one informs you that cloud-init is still configuring your server. The second one means that something went wrong. You can find logs from the cloud-init run in /var/log/cloud-init-output.log file.done means that your jellyfish server is ready to be used. If you'd like to keep an eye on the cloud-init process you can use: cloud-init status --wait  To see the output when the process is finished (successfully or not). "},{"title":"Testing your instance with the Jellyfish dashboard​","type":1,"pageTitle":"Cloud VPS with cloud-init","url":"/jellyfish-docs/next/deploying/vps#testing-your-instance-with-the-jellyfish-dashboard","content":"To see how (or if) your Jellyfish server is working you can test it by connecting our Jellyfish Dashboard with your server. Detailed instructions on how to use Jellyfish Dashboard can be found here. "},{"title":"Design Docs","type":0,"sectionRef":"#","url":"/jellyfish-docs/next/for_developers/design_docs","content":"Design Docs Crucial parts of Jellyfish architecture are always discussed and written down in the form of design documents. Each design document describes, in a nutshell, a few possible solutions or approaches to some problem and states which solution was accepted and why. The list of Jellyfish Design Docs is available here.","keywords":""},{"title":"Architecture","type":0,"sectionRef":"#","url":"/jellyfish-docs/next/getting_started/architecture","content":"","keywords":""},{"title":"Server SDKs​","type":1,"pageTitle":"Architecture","url":"/jellyfish-docs/next/getting_started/architecture#server-sdks","content":"Server SDKs allow you to manage Jellyfish state. In particular, you can: authenticatecreate/delete roomsadd/remove peersadd/remove componentssubscribe for notifications Under the hood, Server SDKs just use Jellyfish REST and WS API, see Jellyfish API. tip As an example, you can use server SDK to introduce a time limit on meeting duration and shut down the room after it passes. "},{"title":"Client SDKs​","type":1,"pageTitle":"Architecture","url":"/jellyfish-docs/next/getting_started/architecture#client-sdks","content":"Client SDKs allow you to connect to Jellyfish to publish and consume tracks. In particular, you can: authenticatejoin specific roompublish audio and videoreceive audio and video from other peers and components At the moment, Jellyfish supports only one type of client - WebRTC. "},{"title":"Diagram​","type":1,"pageTitle":"Architecture","url":"/jellyfish-docs/next/getting_started/architecture#diagram","content":"The whole concept is presented in the following diagram.     Your Backend (BE) - serves your application frontend, and manages the database and application-specific logic. Jellyfish (JF) - Jellyfish media server. Manages media. Admin - someone who has special permission in your application - can create/delete rooms, add/remove peers, etc. User - someone who connects to Jellyfish to send and receive media. Everything starts with Admin who sends an HTTP request to BE to create a new room.BE uses jellyfish-server-sdk to communicate with JF and create the room. Under the hood, jellyfish-server-sdk uses REST API exposed by JF. After the room has been created, the Admin invites a user by sending a new HTTP request to BE. Again, BE uses jellyfish-server-sdk to add the new peer to JF. On the user side, they send a request to BE to join the room.BE replies with JF IP address it should connect to. Then, the User uses jellyfish-client-sdk to connect to JF. After the connection has been established, the User can send and receive media. "},{"title":"Authentication","type":0,"sectionRef":"#","url":"/jellyfish-docs/next/getting_started/authentication","content":"Authentication The Authentication mechanism is based on a bearer token. How does it work? Both Jellyfish and Business Logic are configured with the same secret. This secret is used for authorizing HTTP requests between them (via HTTP authorization request header). When a new client wants to join a room, Business Logic (assuming the client is authorized to join) requests adding a new peer and receives a token generated by Jellyfish. The token must then be passed to the client, that will use it to connect to the room as a new peer. The token encodes both peer and room IDs. The token exchange is handled by our Client SDKs when connecting. Under the hood, Jellyfish expects the token in the first message after opening the Web Socket connection. Token encodes peer id and room id. Run Jellyfish JF_SERVER_API_TOKEN=JF_SERVER_API_TOKEN mix phx.server Create a room and add one peer Business Logic client = Jellyfish.Client.new(&quot;http://address-of-your-server.com&quot;, &quot;JF_SERVER_API_TOKEN&quot;) {:ok, room, _jellyfish_address} = Jellyfish.Room.create(client, max_peers: 10) {:ok, peer, peer_token} = Jellyfish.Room.add_peer(client, room.id, &quot;BobId&quot;) Connect as a peer to Jellyfish Client client.connect({ token: peerToken, peerMetadata: { name: &quot;Bob&quot; }, isSimulcastOn: false }) ","keywords":""},{"title":"HLS","type":0,"sectionRef":"#","url":"/jellyfish-docs/next/getting_started/components/hls","content":"","keywords":""},{"title":"Compatibility​","type":1,"pageTitle":"HLS","url":"/jellyfish-docs/next/getting_started/components/hls#compatibility","content":"WebRTCRTSP "},{"title":"Requirements​","type":1,"pageTitle":"HLS","url":"/jellyfish-docs/next/getting_started/components/hls#requirements","content":"The Room in which the HLS component is created must have the video codec set to H264. See API for more information.Max 1 HLS component allowed per room. "},{"title":"Configuration options​","type":1,"pageTitle":"HLS","url":"/jellyfish-docs/next/getting_started/components/hls#configuration-options","content":"Optional lowLatency (boolean, default: false) - whether the component should use LL-HLSpersistent (boolean, default: false) - whether the stream should be saved or nottargetWindowDuration (positive integer, default: null) - represents the duration, in seconds, of the live streaming content to be maintained in a rolling window. If set to null (default), the entire stream will be available. "},{"title":"Env variables​","type":1,"pageTitle":"HLS","url":"/jellyfish-docs/next/getting_started/components/hls#env-variables","content":"Currently, there are no environment variables related to this component. "},{"title":"Output​","type":1,"pageTitle":"HLS","url":"/jellyfish-docs/next/getting_started/components/hls#output","content":"After adding a WebRTC peer (and at least one track) or an RTSP component, the HLS stream will be available under http://&lt;jellyfish-address&gt;/hls/&lt;room_id&gt;/index.m3u8 (or https://, if using TLS). "},{"title":"Recordings​","type":1,"pageTitle":"HLS","url":"/jellyfish-docs/next/getting_started/components/hls#recordings","content":"After a meeting that integrates an HLS component (with the persistent option set to true) ends, the meeting is preserved as a recording. To manage this recording, use the Recording API. The recording is also available as HLS Video On Demand (VOD) API. "},{"title":"Example Docker commands​","type":1,"pageTitle":"HLS","url":"/jellyfish-docs/next/getting_started/components/hls#example-docker-commands","content":"The HLS playlist will be created inside the Docker container. To access it from the host, you need to create a volume, e.g. by adding the option -v $(pwd)/jellyfish_output:/app/jellyfish_outputto your Docker command. Other than that, your Docker commands shouldn't be affected by adding this component. docker run -p 8080:8080/tcp \\ -e JF_SERVER_API_TOKEN=token \\ -e JF_HOST=localhost:8080 \\ -v $(pwd)/jellyfish_output:/app/jellyfish_output \\ ghcr.io/jellyfish-dev/jellyfish:0.2.0  "},{"title":"RTSP","type":0,"sectionRef":"#","url":"/jellyfish-docs/next/getting_started/components/rtsp","content":"","keywords":""},{"title":"Compatibility​","type":1,"pageTitle":"RTSP","url":"/jellyfish-docs/next/getting_started/components/rtsp#compatibility","content":"WebRTCHLS "},{"title":"Requirements​","type":1,"pageTitle":"RTSP","url":"/jellyfish-docs/next/getting_started/components/rtsp#requirements","content":"RTSP component always outputs H264 stream so if the Room in which the RTSP component is created enforces a video codec, it must be set to H264. See API for more information. "},{"title":"Configuration options​","type":1,"pageTitle":"RTSP","url":"/jellyfish-docs/next/getting_started/components/rtsp#configuration-options","content":"Required sourceUri (string) - URI of RTSP source stream, e.g. &quot;rtsp://mysite.net:554/stream&quot; Optional rtpPort (integer 1..65535, default: 20000) - Local port RTP stream will be received atreconnectDelay (integer 0.., default: 15000) - Delay (in ms) between successive reconnect attemptskeepAliveInterval (integer 0.., default: 15000) - Interval (in ms) in which keep-alive RTSP messages will be sent to the remote stream sourcepierceNat (boolean, default: true) - Whether to attempt to create client-side NAT binding by sending an empty datagram from client to source, after the completion of RTSP setup "},{"title":"Env variables​","type":1,"pageTitle":"RTSP","url":"/jellyfish-docs/next/getting_started/components/rtsp#env-variables","content":"Currently, there are no environment variables related to this component. "},{"title":"Example Docker commands​","type":1,"pageTitle":"RTSP","url":"/jellyfish-docs/next/getting_started/components/rtsp#example-docker-commands","content":"caution If the client is behind NAT, the option --network=host is necessary since Docker can change the source port of UDP packets for routing reasons, which breaks the pierceNat functionality. This means that users on macOS will most likely be unable to access any RTSP stream source outside of their network when running Jellyfish using Docker. If you're on macOS and want to receive RTSP streams from behind NAT, right now the only way is to build Jellyfish natively from source. Explicit port exposure (macOS compatible) docker run -p 20000:20000/udp \\ -p 8080:8080/tcp \\ -e JF_SERVER_API_TOKEN=token \\ -e JF_HOST=localhost:8080 \\ ghcr.io/jellyfish-dev/jellyfish:0.2.0  caution Make sure that the exposed UDP port matches the one used by the RTSP component (option rtpPort, default: 20000). If using multiple RTSP components, more ports will need to be exposed. Using host network (Linux only) docker run --network=host \\ -e JF_SERVER_API_TOKEN=token \\ -e JF_HOST=localhost:8080 \\ ghcr.io/jellyfish-dev/jellyfish:0.2.0  "},{"title":"Installation","type":0,"sectionRef":"#","url":"/jellyfish-docs/next/getting_started/installation","content":"","keywords":""},{"title":"Building from source​","type":1,"pageTitle":"Installation","url":"/jellyfish-docs/next/getting_started/installation#building-from-source","content":"Make sure to have both Elixir and Rust installed. Check the links below for instructions: ElixirRust Clone the Jellyfish repo git clone https://github.com/jellyfish-dev/jellyfish.git  Install native dependencies macOS IntelmacOS Apple SiliconUbuntu These instructions assume you have Homebrew installed. You can get it here. brew install srtp libnice clang-format ffmpeg opus pkg-config export LDFLAGS=&quot;-L/usr/local/opt/openssl@1.1/lib&quot; export CFLAGS=&quot;-I/usr/local/opt/openssl@1.1/include/&quot; export CPPFLAGS=&quot;-I/usr/local/opt/openssl@1.1/include/&quot; export PKG_CONFIG_PATH=&quot;/usr/local/opt/openssl@1.1/lib/pkgconfig&quot;  Install elixir dependencies mix deps.get  Run the server in development mix phx.server  Create a binary You can also create Jellyfish binary with: MIX_ENV=prod mix release  Then follow instructions printed in your terminal. info The difference between running with mix phx.server and generating target binary is that the latter is prepared for running in production so e.g. it includes some Erlang Virtual Machine tweaks. Jellyfish Dockerfile always uses mix release under the hood. "},{"title":"Running with Docker​","type":1,"pageTitle":"Installation","url":"/jellyfish-docs/next/getting_started/installation#running-with-docker","content":"Docker images are built for production which means that you always need to set a couple of environment variables. An example docker command running bare Jellyfish HTTP service locally: docker run -p 8080:8080/tcp -e JF_HOST=localhost:8080 JF_SERVER_API_TOKEN=token ghcr.io/jellyfish-dev/jellyfish:0.2.0  Note that in real case scenarios, docker commands depend on peers/components you are going to use. Therefore, we don't present them here but rather in each peer/component's documentation. As an example see WebRTC Peer. For the full list of Jellyfish Docker images, see this page. tip Instead of passing environmental variables manually, you can use the --env-file ./env-file flag, where the env-file is a file containing the variables that the image expects, see example file .env.sample in the Jellyfish repository. "},{"title":"Environment variables​","type":1,"pageTitle":"Installation","url":"/jellyfish-docs/next/getting_started/installation#environment-variables","content":"Environment variables are split into two groups: general ones - presented belowpeer/component-specific - each Peer and Component can expose its own environment variables. They are always listed in a Peer/Component description. See the list of Peers and Components. Below there are general, Jellyfish environment variables. If you are running Jellyfish in development, you don't need to set any of them. Required in production:​ JF_SERVER_API_TOKEN - token for authorizing HTTP requests. Defaults to development for development builds.JF_HOST - defines how Jellyfish should be seen from the outside. Defaults to JF_IP:JF_PORT. It can be in the form of ip:port, domain:port or simply domain. Useful when hosting Jellyfish behind proxy. It is returned e.g. when creating a new room. When running with Docker, JF_IP is set to 0.0.0.0making the default value of JF_HOST incorrect. Therefore, for Docker, you have to set JF_HOST manually. For running Docker locally, it can simply be localhost:8080. Optional:​ JF_IP - an ip address to run the HTTP server on. Defaults to 127.0.0.1 when running from source or using mix release, or 0.0.0.0 for Docker.JF_PORT - port to run the HTTP server on. Defaults to 5002 for development builds and 8080 for production builds (mix release or Docker).JF_SECRET_KEY_BASE - used to sign/encrypt tokens generated for Peers. Generated if not provided.JF_CHECK_ORIGIN - defines if Jellyfish will check the origin of incoming requests and socket connection. Defaults to true. Possible values are true, false or a space-separated list of allowed origins (wildcards are allowed). Example: JF_CHECK_ORIGIN=&quot;https://example.com //another.com:888 //*.other.com&quot;JF_OUTPUT_BASE_PATH - a base path where Jellyfish will save its artifacts. Defaults to ./jellyfish_output/. When running via docker, the directory can be mounted as -v $(pwd)/host_directory:/app/jellyfish_output.JF_METRICS_IP - an IP address to run metrics endpoint on. Defaults to 127.0.0.1 when running from source or using mix release, or 0.0.0.0 for Docker.JF_METRICS_PORT - a port to run metrics endpoint on. Defaults to 9568.MIX_ENV - defines compilation environment. This variable takes effect only when running from the source. Docker images are always built with MIX_ENV=prod. Possible values are: dev - uses default values for environment variables (default option when running with mix phx.server)prod - requires that you provide values for environment variablestest - used in tests Distribution:​ JF_DIST_ENABLED - whether to run Jellyfish in a cluster. Defaults to false.JF_DIST_STRATEGY_NAME - specify which clustering strategy to use. Possible values are DNS or NODES_LIST. Defaults to NODES_LIST.JF_DIST_NODE_NAME - Node name used in a cluster. It consists of two parts - nodename@hostname. The first part identifies a node on a single machine and can be any string. The second part identifies the host machine and has to be an ip address or FQDN of a machine Jellyfish runs on. If you run a cluster using NODES_LIST strategy on a single machine or in the same docker network and you don't want to use IP addresses or FQDN as hostnames, you can use short names (see JF_DIST_MODE). If you run a cluster using DNS strategy, every Jellyfish instance must have nodename set to the same value.JF_DIST_MODE - distribution mode - can be name or sname. Defaults to name. When using name, your hostname has to be an IP address or FQDN of a machine Jellyfish runs on. When using sname, your hostname can be any string. See our docker-compose.yaml, which we use in our integration tests for an example.JF_DIST_COOKIE - used to group Jellyfishes in a cluster. Defaults to jellyfish_cookie. Use different cookies to create multiple clusters on the same machine. Important: cookie does not provide any cryptographic security. Its only purpose is to prevent a node from connecting to a cluster with which it is not intended to communicate.JF_DIST_MIN_PORT- minimal port used by Jellyfish when forming a cluster (connecting to other Jellyfishes). Defaults to 9000 when running with Docker. Only available when running with Docker or mix release.JF_DIST_MAX_PORT- maximal port used by Jellyfish when forming a cluster (connecting to other Jellyfishes). Defaults to 9000 when running with Docker. Only available when running with Docker or mix release. Distribution NODES_LIST specific:​ JF_DIST_NODES - space-separated list of other Jellyfishes to connect to. Defaults to &quot;&quot;. Example: JF_DIST_NODES=&quot;jellyfish1@127.0.0.1 jellyfish2@127.0.0.1&quot;. This list can also include ourselves so that you can pass the same value to every Jellyfish. Note: Jellyfish connection to other Jellyfish is transitive meaning that when you connect to one Jellyfish you also connect to all other Jellyfishes this one was connected to. Distribution DNS specific:​ JF_DIST_QUERY - query sent to DNS to discover other Jellyfishes. Returned list of IPs from DNS is used for creating distribution node name in the format &lt;nodename&gt;@&lt;IP_ADDRESS&gt;. JF_DIST_POLLING_INTERVAL - DNS polling interval in ms. Default value is 5000. tip You can use a single port to form a cluster, even if a cluster consists of more than two Jellyfishes. caution Besides ports specified using JF_DIST_MIN_PORT and JF_DIST_MAX_PORT, Jellyfish also uses one more service called EPMD that runs on port 4369. This port has to be explicitly exported when running with Docker. Read more in the Cluster section. "},{"title":"Metrics","type":0,"sectionRef":"#","url":"/jellyfish-docs/next/getting_started/metrics","content":"Metrics Jellyfish exports several metrics in the Prometheus format. By default, they are available on port 9568 at /metrics. See JF_METRICS_IP and JF_METRICS_PORT for configuration options. Name\tLabels\tDescriptionjellyfish_traffic_ingress_webrtc_total_bytes Total WebRTC traffic received jellyfish_traffic_ingress_webrtc_throughput_bytes_per_second Current throughput for received WebRTC traffic jellyfish_traffic_egress_webrtc_total_bytes Total WebRTC traffic sent jellyfish_traffic_egress_webrtc_throughput_bytes_per_second Current throughput for sent WebRTC traffic jellyfish_traffic_ingress_http_total_bytes Total HTTP traffic received jellyfish_traffic_ingress_http_throughput_bytes_per_second Current throughput for received HTTP traffic jellyfish_traffic_egress_http_total_bytes Total HTTP traffic sent jellyfish_traffic_egress_http_throughput_bytes_per_second Current throughput for sent HTTP traffic jellyfish_traffic_ingress_total_bytes Total traffic received jellyfish_traffic_ingress_throughput_bytes_per_second Current throughput for received traffic jellyfish_traffic_egress_total_bytes Total traffic sent jellyfish_traffic_egress_throughput_bytes_per_second Current throughput for sent traffic jellyfish_rooms Amount of rooms currently present in Jellyfish jellyfish_room_peers\troom_id\tAmount of peers currently present in a given room jellyfish_room_peer_time_total_seconds\troom_id\tTotal peer time accumulated for a given room vm_memory_total_bytes Total memory used by Erlang Virtual Machine vm_total_run_queue_lengths_total Number of Erlang processes waiting to be executed vm_total_run_queue_lengths_cpu Number of Erlang processes waiting to be executed on CPU schedulers vm_total_run_queue_lengths_io Number of Erlang processes waiting to be executed on IO schedulers","keywords":""},{"title":"Notifications","type":0,"sectionRef":"#","url":"/jellyfish-docs/next/getting_started/notifications","content":"Notifications Jellyfish sends server side notifications whenever some important event occurs, e.g.: a room has been createdsome peer has connectedcomponent has crashedetc. A full list of available notifications is always present in specific server SDK documentation. Here, we present how you can subscribe for server side notifications using Elixir Server SDK: server_address = &quot;localhost:5002&quot; server_api_token = &quot;development&quot; {:ok, notifier} = Jellyfish.Notifier.start(server_address: server_address, server_api_token: server_api_token) :ok = Jellyfish.Notifier.subscribe_server_notifications(notifier) :ok = Jellyfish.Notifier.subscribe_metrics(notifier) As a result, you should see the following logs on the server side 07:45:02.684 [info] New incoming server WebSocket connection, accepting 07:45:02.688 [info] Server WS authenticated. ","keywords":""},{"title":"WebRTC","type":0,"sectionRef":"#","url":"/jellyfish-docs/next/getting_started/peers/webrtc","content":"","keywords":""},{"title":"Compatibility​","type":1,"pageTitle":"WebRTC","url":"/jellyfish-docs/next/getting_started/peers/webrtc#compatibility","content":"HLSRTSP "},{"title":"Configuration options​","type":1,"pageTitle":"WebRTC","url":"/jellyfish-docs/next/getting_started/peers/webrtc#configuration-options","content":"Optional enableSimulcast (boolean, default: true) - Enables the peer to use simulcast "},{"title":"Env variables​","type":1,"pageTitle":"WebRTC","url":"/jellyfish-docs/next/getting_started/peers/webrtc#env-variables","content":"JF_WEBRTC_USED - has to be true if WebRTC peers will be usedJF_WEBRTC_TURN_LISTEN_IP - the IP address on which TURN servers will listen. By default set to 127.0.0.1. When running Jellyfish via Docker, this MUST be set to 0.0.0.0, even for local tests.JF_WEBRTC_TURN_IP - the IP address, under which TURN will present itself to the clients. By default set to 127.0.0.1. When running Jellyfish via Docker, this MUST be set to real (non-loopback) address, even for local tests.JF_WEBRTC_TURN_PORT_RANGE - port range, where UDP TURN will try to open ports. By default set to 50000-59999. The bigger the range is, the more users server will be able to handle. Useful when not using the --network=host option to limit the UDP ports used only to ones published from a Docker container.JF_WEBRTC_TURN_TCP_PORT - port number of TCP TURN "},{"title":"Example Docker commands​","type":1,"pageTitle":"WebRTC","url":"/jellyfish-docs/next/getting_started/peers/webrtc#example-docker-commands","content":"Explicit port exposure (macOS compatible) docker run -p 50000-50050:50000-50050/udp \\ -p 8080:8080/tcp \\ -e JF_SERVER_API_TOKEN=token \\ -e JF_HOST=localhost:8080 \\ -e JF_WEBRTC_USED=true \\ -e JF_WEBRTC_TURN_PORT_RANGE=50000-50050 \\ -e JF_WEBRTC_TURN_IP=192.168.0.1 \\ -e JF_WEBRTC_TURN_LISTEN_IP=0.0.0.0 \\ ghcr.io/jellyfish-dev/jellyfish:0.2.0  caution Make sure that the exposed UDP ports match JF_WEBRTC_TURN_PORT_RANGE. The range of the ports shouldn't be too wide as it might cause problems with container startup. Using host network (Linux only) docker run --network=host \\ -e JF_SERVER_API_TOKEN=token \\ -e JF_HOST=localhost:8080 \\ -e JF_WEBRTC_USED=true \\ -e JF_WEBRTC_TURN_IP=192.168.0.1 \\ -e JF_WEBRTC_TURN_LISTEN_IP=0.0.0.0 \\ ghcr.io/jellyfish-dev/jellyfish:0.2.0  "},{"title":"SDKs","type":0,"sectionRef":"#","url":"/jellyfish-docs/next/getting_started/sdks","content":"","keywords":""},{"title":"Server SDKs​","type":1,"pageTitle":"SDKs","url":"/jellyfish-docs/next/getting_started/sdks#server-sdks","content":"SDK\tResourcesElixir\tCode examples RTSP to HLS conversion Python\t "},{"title":"Client SDKs​","type":1,"pageTitle":"SDKs","url":"/jellyfish-docs/next/getting_started/sdks#client-sdks","content":"SDK\tResourcesReact\tReact Minimal Working Example Guide Jellyfish Videoroom Code examples TypeScript\tCode examples IOS\tCode example Android\tCode example React Native\tCode example "},{"title":"Rest API","type":0,"sectionRef":"#","url":"/jellyfish-docs/next/for_developers/api_reference/rest_api","content":"Rest API hls getSend file recording getShows information about the roomdelDelete the recordinggetSend file room getShow information about all roomspostCreates a roomdelDelete the roomgetShows information about the roompostCreates the component and adds it to the roomdelDelete the component from the roompostCreate peerdelDelete peer API docs by Redocly Jellyfish Media Server (0.2.0) Download OpenAPI specification:Download License: Apache 2.0 hls Send file Authorizations: authorization path Parameters room_id required string Room id filename required string Name of the file query Parameters _HLS_msn integer or null (HlsMsn) &gt;= 0 Example: _HLS_msn=10 Segment sequence number _HLS_part integer or null (HlsPart) &gt;= 0 Example: _HLS_part=10 Partial segment sequence number _HLS_skip string or null (HlsSkip) Value: &quot;YES&quot; Example: _HLS_skip=YES Is delta manifest requested header Parameters range string Byte range of partial segment Responses 200 File was found 404 File not found get/hls/{room_id}/{filename} https://raw.githubusercontent.com/hls/{room_id}/{filename} Response samples 200404 Content type application/json Copy &quot;string&quot; recording Shows information about the room Authorizations: authorization Responses 200 Success 404 Unable to obtain recordings get/recording https://raw.githubusercontent.com/recording Response samples 200404 Content type application/json Copy Expand all Collapse all { &quot;data&quot;: [ &quot;string&quot; ] } Delete the recording Authorizations: authorization path Parameters recording_id required string Recording id Responses 204 Successfully deleted recording 404 Recording doesn't exist delete/recording/{recording_id} https://raw.githubusercontent.com/recording/{recording_id} Response samples 404 Content type application/json Copy { &quot;errors&quot;: &quot;Token has expired&quot; } Send file Authorizations: authorization path Parameters recording_id required string Recording id filename required string Name of the file Responses 200 File was found 404 File not found get/recording/{recording_id}/{filename} https://raw.githubusercontent.com/recording/{recording_id}/{filename} Response samples 200404 Content type application/json Copy &quot;string&quot; room Show information about all rooms Authorizations: authorization Responses 200 Success 401 Unauthorized get/room https://raw.githubusercontent.com/room Response samples 200401 Content type application/json Copy Expand all Collapse all { &quot;data&quot;: [ { &quot;components&quot;: [ { &quot;id&quot;: &quot;component-1&quot;, &quot;metadata&quot;: { &quot;lowLatency&quot;: true, &quot;persistent&quot;: true, &quot;playable&quot;: true, &quot;targetWindowDuration&quot;: 0 }, &quot;type&quot;: &quot;hls&quot; } ], &quot;config&quot;: { &quot;maxPeers&quot;: 10, &quot;videoCodec&quot;: &quot;h264&quot;, &quot;webhookUrl&quot;: &quot;https://backend.address.com/jellyfish-notifications-endpoint&quot; }, &quot;id&quot;: &quot;room-1&quot;, &quot;peers&quot;: [ { &quot;id&quot;: &quot;peer-1&quot;, &quot;status&quot;: &quot;disconnected&quot;, &quot;type&quot;: &quot;webrtc&quot; } ] } ] } Creates a room Authorizations: authorization Request Body schema: application/json Room configuration maxPeers integer or null &gt;= 1 Maximum amount of peers allowed into the room videoCodec string or null Enum: &quot;h264&quot; &quot;vp8&quot; Enforces video codec for each peer in the room webhookUrl string or null URL where Jellyfish notifications will be sent Responses 201 Room successfully created 400 Invalid request structure 401 Unauthorized post/room https://raw.githubusercontent.com/room Request samples Payload Content type application/json Copy { &quot;maxPeers&quot;: 10, &quot;videoCodec&quot;: &quot;h264&quot;, &quot;webhookUrl&quot;: &quot;https://backend.address.com/jellyfish-notifications-endpoint&quot; } Response samples 201400401 Content type application/json Copy Expand all Collapse all { &quot;data&quot;: { &quot;jellyfish_address&quot;: &quot;jellyfish1:5003&quot;, &quot;room&quot;: { &quot;components&quot;: [ { &quot;id&quot;: &quot;component-1&quot;, &quot;metadata&quot;: { &quot;lowLatency&quot;: true, &quot;persistent&quot;: true, &quot;playable&quot;: true, &quot;targetWindowDuration&quot;: 0 }, &quot;type&quot;: &quot;hls&quot; } ], &quot;config&quot;: { &quot;maxPeers&quot;: 10, &quot;videoCodec&quot;: &quot;h264&quot;, &quot;webhookUrl&quot;: &quot;https://backend.address.com/jellyfish-notifications-endpoint&quot; }, &quot;id&quot;: &quot;room-1&quot;, &quot;peers&quot;: [ { &quot;id&quot;: &quot;peer-1&quot;, &quot;status&quot;: &quot;disconnected&quot;, &quot;type&quot;: &quot;webrtc&quot; } ] } } } Delete the room Authorizations: authorization path Parameters room_id required string Room id Responses 204 Successfully deleted room 401 Unauthorized 404 Room doesn't exist delete/room/{room_id} https://raw.githubusercontent.com/room/{room_id} Response samples 401404 Content type application/json Copy { &quot;errors&quot;: &quot;Token has expired&quot; } Shows information about the room Authorizations: authorization path Parameters room_id required string Room ID Responses 200 Success 401 Unauthorized 404 Room doesn't exist get/room/{room_id} https://raw.githubusercontent.com/room/{room_id} Response samples 200401404 Content type application/json Copy Expand all Collapse all { &quot;data&quot;: { &quot;components&quot;: [ { &quot;id&quot;: &quot;component-1&quot;, &quot;metadata&quot;: { &quot;lowLatency&quot;: true, &quot;persistent&quot;: true, &quot;playable&quot;: true, &quot;targetWindowDuration&quot;: 0 }, &quot;type&quot;: &quot;hls&quot; } ], &quot;config&quot;: { &quot;maxPeers&quot;: 10, &quot;videoCodec&quot;: &quot;h264&quot;, &quot;webhookUrl&quot;: &quot;https://backend.address.com/jellyfish-notifications-endpoint&quot; }, &quot;id&quot;: &quot;room-1&quot;, &quot;peers&quot;: [ { &quot;id&quot;: &quot;peer-1&quot;, &quot;status&quot;: &quot;disconnected&quot;, &quot;type&quot;: &quot;webrtc&quot; } ] } } Creates the component and adds it to the room Authorizations: authorization path Parameters room_id required string Room ID Request Body schema: application/json Component config options ComponentOptionsHLS (object) or ComponentOptionsRTSP (object) (ComponentOptions) Component-specific options type required string (ComponentType) Component type Responses 201 Successfully added component 400 Invalid request 401 Unauthorized 404 Room doesn't exist post/room/{room_id}/component https://raw.githubusercontent.com/room/{room_id}/component Request samples Payload Content type application/json Copy Expand all Collapse all { &quot;options&quot;: { &quot;lowLatency&quot;: false, &quot;persistent&quot;: false, &quot;targetWindowDuration&quot;: 0 }, &quot;type&quot;: &quot;hls&quot; } Response samples 201400401404 Content type application/json Copy Expand all Collapse all { &quot;data&quot;: { &quot;id&quot;: &quot;component-1&quot;, &quot;metadata&quot;: { &quot;lowLatency&quot;: true, &quot;persistent&quot;: true, &quot;playable&quot;: true, &quot;targetWindowDuration&quot;: 0 }, &quot;type&quot;: &quot;hls&quot; } } Delete the component from the room Authorizations: authorization path Parameters room_id required string Room ID id required string Component ID Responses 204 Successfully deleted 401 Unauthorized 404 Either component or the room doesn't exist delete/room/{room_id}/component/{id} https://raw.githubusercontent.com/room/{room_id}/component/{id} Response samples 401404 Content type application/json Copy { &quot;errors&quot;: &quot;Token has expired&quot; } Create peer Authorizations: authorization path Parameters room_id required string Room id Request Body schema: application/json Peer specification options required PeerOptionsWebRTC (object) (PeerOptions) Peer-specific options type required string (PeerType) Peer type Responses 201 Peer successfully created 400 Invalid request body structure 401 Unauthorized 404 Room doesn't exist 503 Peer limit has been reached post/room/{room_id}/peer https://raw.githubusercontent.com/room/{room_id}/peer Request samples Payload Content type application/json Copy Expand all Collapse all { &quot;options&quot;: { &quot;enableSimulcast&quot;: true }, &quot;type&quot;: &quot;webrtc&quot; } Response samples 201400401404503 Content type application/json Copy Expand all Collapse all { &quot;data&quot;: { &quot;peer&quot;: { &quot;id&quot;: &quot;peer-1&quot;, &quot;status&quot;: &quot;disconnected&quot;, &quot;type&quot;: &quot;webrtc&quot; }, &quot;token&quot;: &quot;5cdac726-57a3-4ecb-b1d5-72a3d62ec242&quot; } } Delete peer Authorizations: authorization path Parameters room_id required string Room ID id required string Peer id Responses 204 Peer successfully deleted 401 Unauthorized 404 Room ID or Peer ID references a resource that doesn't exist delete/room/{room_id}/peer/{id} https://raw.githubusercontent.com/room/{room_id}/peer/{id} Response samples 401404 Content type application/json Copy { &quot;errors&quot;: &quot;Token has expired&quot; }","keywords":""},{"title":"Basic Concepts","type":0,"sectionRef":"#","url":"/jellyfish-docs/next/introduction/basic_concepts","content":"","keywords":""},{"title":"Room​","type":1,"pageTitle":"Basic Concepts","url":"/jellyfish-docs/next/introduction/basic_concepts#room","content":"In Jellyfish, a room serves as a holder for peers and components, its function varying based on application. For instance, within a video conferencing system, a Jellyfish room represents a single online meeting or a channel accommodating multiple users for conversation. On the other hand, in a broadcasting system setting, one room will be a container for two components - one responsible for receiving stream from a streaming host (e.g. via RTMP) and the other one responsible for converting this stream into an HLS playlist ready to be broadcasted via CDN. "},{"title":"Component​","type":1,"pageTitle":"Basic Concepts","url":"/jellyfish-docs/next/introduction/basic_concepts#component","content":"A component is a server-side process that publishes or subscribes to tracks. Example components are: HLS component - subscribes to all other tracks and creates from them an HLS playlist ready to be broadcasted via CDNRTSP component - connects to the remote media source (e.g. an IP camera) and publishes its media to be consumed by other components or peers "},{"title":"Peer​","type":1,"pageTitle":"Basic Concepts","url":"/jellyfish-docs/next/introduction/basic_concepts#peer","content":"A peer is a client-side entity that connects to the server to publish, subscribe or publish and subscribe to tracks published by components or other peers. The peer's process is spawned after the peer connects to the server. At the moment, there is only one type of peer - WebRTC. "},{"title":"Difference between Component and Peer​","type":1,"pageTitle":"Basic Concepts","url":"/jellyfish-docs/next/introduction/basic_concepts#difference-between-component-and-peer","content":"The most important difference between a component and a peer is that component is a purely server-side thing. It starts its work right after adding it to the server. On the other hand, a peer is something that has to connect to the server. Therefore, peers are allowed to open so-called signaling channels to the server. See also Example Scenarios. "},{"title":"Example Scenarios","type":0,"sectionRef":"#","url":"/jellyfish-docs/next/introduction/example_scenarios","content":"","keywords":""},{"title":"Real-time video conferencing system​","type":1,"pageTitle":"Example Scenarios","url":"/jellyfish-docs/next/introduction/example_scenarios#real-time-video-conferencing-system","content":"In this scenario, we want to create a simple video conferencing system where people can talk to each other in the real-time. Because of interactive and real-time requirements, the natural choice is to use the WebRTC standard. The final architecture would look like this:   "},{"title":"Broadcasting system with the real-time mixin​","type":1,"pageTitle":"Example Scenarios","url":"/jellyfish-docs/next/introduction/example_scenarios#broadcasting-system-with-the-real-time-mixin","content":"In this scenario, we want to create a broadcasting solution where the conversation between multiple people is broadcasted to the broader audience. Here, we choose WebRTC as a standard used for connecting people talking to each other in real-time and HLS for creating a playlist that can be then uploaded to CDN and broadcasted to the broader audience. As you can see, the whole system will automatically adapt to the number of participants talking in real-time. In particular, Jellyfish will handle a scenario with only one streamer out of the box.   "},{"title":"Displaying IP camera streams in a web browser​","type":1,"pageTitle":"Example Scenarios","url":"/jellyfish-docs/next/introduction/example_scenarios#displaying-ip-camera-streams-in-a-web-browser","content":"In this scenario, we have a set of IP cameras and we want to display their streams in a web browser. IP cameras very often use RTSP for streaming media but browsers don't ship with support for this protocol. Therefore, to display audio and video in a web browser, we have to use either WebRTC or HLS. Because, in this scenario, the delay is not the most crucial thing, we choose HLS. The most important thing here is that the RTSP component connects to the IP camera and then the camera starts streaming. It's not the camera that initializes the connection to the server. Therefore, the RTSP component is a purely server-side thing - once you add it, it should be able to work on its own.   "},{"title":"The Whats and Hows of Jellyfish Dashboard","type":0,"sectionRef":"#","url":"/jellyfish-docs/next/tutorials/dashboard","content":"","keywords":""},{"title":"What is Jellyfish Dashboard?​","type":1,"pageTitle":"The Whats and Hows of Jellyfish Dashboard","url":"/jellyfish-docs/next/tutorials/dashboard#what-is-jellyfish-dashboard","content":"Jellyfish Dashboard is a web application that allows you to manage your Jellyfish Media Server instance. It is a React application that uses the Jellyfish React Client APIfor adding and receiving tracks and Jellyfish Server APIfor adding peers, creating rooms etc. It was created to help Jellyfish developers in testing but was later extended and adapted as a tool for tutorials and demos. Here, we present a short introduction to the dashboard and its features. "},{"title":"How to start Jellyfish Dashboard?​","type":1,"pageTitle":"The Whats and Hows of Jellyfish Dashboard","url":"/jellyfish-docs/next/tutorials/dashboard#how-to-start-jellyfish-dashboard","content":"There are a couple of ways to start the dashboard: Up-to-date versionDocker containerOfficial repository The current version of the dashboard is ready to use and availablehere. Ensure that it is compatible with your Jellyfish server! Please note that this dashboard only supports secure connections (https/wss) or connections to localhost. Any insecure requests (http/ws) will be automatically blocked by the browser. "},{"title":"How to start Jellyfish Media Server?​","type":1,"pageTitle":"The Whats and Hows of Jellyfish Dashboard","url":"/jellyfish-docs/next/tutorials/dashboard#how-to-start-jellyfish-media-server","content":"For testing, we'll run the Jellyfish Media Server locally using Docker image: docker run -p 50000-50050:50000-50050/udp \\ -p 5002:5002/tcp \\ -e JF_CHECK_ORIGIN=false \\ -e JF_HOST=&lt;your ip address&gt;:5002 \\ -e JF_PORT=&quot;5002&quot; \\ -e JF_WEBRTC_USED=true \\ -e JF_WEBRTC_TURN_PORT_RANGE=50000-50050 \\ -e JF_WEBRTC_TURN_IP=&lt;your ip address&gt; \\ -e JF_WEBRTC_TURN_LISTEN_IP=0.0.0.0 \\ -e JF_SERVER_API_TOKEN=development \\ ghcr.io/jellyfish-dev/jellyfish:0.2.0  Make sure to set JF_WEBRTC_TURN_IP and JF_HOST to your local IP address. Without it, the mobile device won't be able to connect to the Jellyfish. tip To check your local IP you can use this handy command (Linux/macOS): ifconfig | grep &quot;inet &quot; | grep -Fv 127.0.0.1 | awk '{print $2}'  "},{"title":"How to use Jellyfish Dashboard?​","type":1,"pageTitle":"The Whats and Hows of Jellyfish Dashboard","url":"/jellyfish-docs/next/tutorials/dashboard#how-to-use-jellyfish-dashboard","content":"Since we have Dashboard and Jellyfish Media Server up and running, we can dive into the features. "},{"title":"Connecting to the server​","type":1,"pageTitle":"The Whats and Hows of Jellyfish Dashboard","url":"/jellyfish-docs/next/tutorials/dashboard#connecting-to-the-server","content":"We started the dashboard and the Jellyfish Media Server separately, so we need to connect them. Open the dashboard in your browser. Open the side menu and fill in the parameters:  Server token - a token necessary to authenticate the dashboard with the Jellyfish. For now, it's simply development, but it is meant to authenticate the dashboard to the Jellyfish, so the good practice is to use a token that is hard to guess.WS/WSS - whether to use a secure or insecure connection. , it's ws, but if the Jellyfish uses secure WebSocket, use wss.HTTP/HTTPS - whether to use a secure or insecure connection. By default, it's http, but if the Jellyfish uses secure HTTP, use https.Server URL - URL of the Jellyfish server. Here, localhost:5002 would be a local build, but it can be any URL that points to the Jellyfish.Socket Path - path to the WebSocket endpoint. The default value is /socket/peer/websocket. Click Connect to server. If everything is correct, a server will appear in the list of connected servers:  "},{"title":"Creating a room​","type":1,"pageTitle":"The Whats and Hows of Jellyfish Dashboard","url":"/jellyfish-docs/next/tutorials/dashboard#creating-a-room","content":"There are plenty of settings that You can adjust in a room:  h264 or vp8 - video codec used in the room. If you want to use HLS streaming, you need to use h264.Max Peers - maximum number of peers that can join to the room. When you select the settings, click the Add room button. If everything is correct, a room will appear in the list of rooms:  "},{"title":"Adding and connecting peers to the room​","type":1,"pageTitle":"The Whats and Hows of Jellyfish Dashboard","url":"/jellyfish-docs/next/tutorials/dashboard#adding-and-connecting-peers-to-the-room","content":"Using the Create peer button, you can create a peer that will be ready to connect to the room.  The peer has its ID and Token. The ID is used to identify the peer in the Jellyfish Server, and the Token is used to authenticate the peer with the Jellyfish Server. Dashboard has an option to copy both of those values to the clipboard. You can also create a QR code with the peer's Token to make connecting to Jellyfish with a mobile device easier.  To connect the peer to the room, you can either press the Connect button in the peer's row, or scan the QR code with your mobile app, and connect there. "},{"title":"Sending tracks​","type":1,"pageTitle":"The Whats and Hows of Jellyfish Dashboard","url":"/jellyfish-docs/next/tutorials/dashboard#sending-tracks","content":"When the peer connects to the room, you will see the track menu. It allows you to send tracks to the room.  You can select the audio or video track you want to create. Created tracks will be visible in the list below. You can select any track from the list and send it to the room. Apart from your camera/microphone, you can easily share your screen with its audio or pick one from a list of mock tracks that we prepared. You can also select the resolution of the video track or if you want, send the video as a simulcast stream. There is also an option to add custom metadata (in JSON format) to the track. The peer will send metadata with the track to the room. Each recipient will be able to see it. When you select the track, click the Add track button. If everything is correct, client will send the track to the room and other peers will be able to see and hear you. "},{"title":"Receiving tracks​","type":1,"pageTitle":"The Whats and Hows of Jellyfish Dashboard","url":"/jellyfish-docs/next/tutorials/dashboard#receiving-tracks","content":"When the peer connects to the room, it will automatically receive tracks from other peers. Congrats! The basic utils of the dashboard are now covered. Next, we will dive into useful features that will help you with testing. "},{"title":"A ton of information that the dashboard provides​","type":1,"pageTitle":"The Whats and Hows of Jellyfish Dashboard","url":"/jellyfish-docs/next/tutorials/dashboard#a-ton-of-information-that-the-dashboard-provides","content":""},{"title":"Server logs in console​","type":1,"pageTitle":"The Whats and Hows of Jellyfish Dashboard","url":"/jellyfish-docs/next/tutorials/dashboard#server-logs-in-console","content":"On the side menu, you can set up the dashboard to display React Client logs in the console. Logs are great for debugging purposes and provide insight into the various communications that occur between the dashboard and the Jellyfish Server. You can also register your event handlers in your Jellyfish-based projects, both in theReact Client SDK and theTS Client SDK. These logs can show you when particular events occur and provide data that you can use in your own handlers  "},{"title":"Server/Room/Client state​","type":1,"pageTitle":"The Whats and Hows of Jellyfish Dashboard","url":"/jellyfish-docs/next/tutorials/dashboard#serverroomclient-state","content":"Each server, room, and client has its state. You can see the state of each of them in the dashboard by clicking appropriate buttons.  "},{"title":"Server events​","type":1,"pageTitle":"The Whats and Hows of Jellyfish Dashboard","url":"/jellyfish-docs/next/tutorials/dashboard#server-events","content":"Apart from the state, you can also see the events that occur on the server. You can see them after clicking the Show Server Events button.  "},{"title":"HLS and RTSP streaming​","type":1,"pageTitle":"The Whats and Hows of Jellyfish Dashboard","url":"/jellyfish-docs/next/tutorials/dashboard#hls-and-rtsp-streaming","content":"The dashboard allows adding HLS and RTSP streams in the room. You can set up the streams and see them in the room. It will look like this:  "},{"title":"Loadbalancing in Dashboard​","type":1,"pageTitle":"The Whats and Hows of Jellyfish Dashboard","url":"/jellyfish-docs/next/tutorials/dashboard#loadbalancing-in-dashboard","content":"Jellyfish Server supports load balancing. This means you can run multiple instances of the server and use them simultaneously to distribute the load evenly among them. The dashboard reflects this feature. If you run multiple Jellyfish instances (which Docker Compose does by default), connect one server to the dashboard. When a server opens a room on a different instance, the Dashboard will automatically connect to it and display the room. When Jellyfish runs in a cluster, and the Dashboard requests a new room, it's created on the Jellyfish instance with the lowest load. Information about the specific Jellyfish instance that hosts the newly created room is returned in the HTTP response body. "},{"title":"Data collected by Jellyfish​","type":1,"pageTitle":"The Whats and Hows of Jellyfish Dashboard","url":"/jellyfish-docs/next/tutorials/dashboard#data-collected-by-jellyfish","content":"For each server, Jellyfish collects WebRTC statistics about the rooms, clients and streamed tracks. You can see them in the dashboard using the Internals button.  The button opens a new tab with the panel to connect to the WebSocket of the Jellyfish of choice. You can observe the data with the dynamically generated charts showing what flows through the Jellyfish.  "},{"title":"Summary​","type":1,"pageTitle":"The Whats and Hows of Jellyfish Dashboard","url":"/jellyfish-docs/next/tutorials/dashboard#summary","content":"Congrats on finishing the tutorial! You should now be able to use the dashboard to its full potential. But this was just the beginning. Jellyfish Client API is a powerful tool that allows you to create your own web or mobile multimedia application. Check out the other tutorials to learn more about the Jellyfish Client API and how to use it in your projects. You can also take a look at our fully featured Videoroom Demo example:  It's written in React Native, but it uses the same Jellyfish Client API as the dashboard, so you can learn a lot from it. "},{"title":"Simple React App","type":0,"sectionRef":"#","url":"/jellyfish-docs/next/tutorials/simple-react-app","content":"","keywords":""},{"title":"What you'll learn​","type":1,"pageTitle":"Simple React App","url":"/jellyfish-docs/next/tutorials/simple-react-app#what-youll-learn","content":"This tutorial will guide you through creating your first React project that uses the Jellyfish Client. By the end of the tutorial, you'll have a working web application that connects toJellyfish Media Server using WebRTC technology.  You can check out the finished project here "},{"title":"What do you need​","type":1,"pageTitle":"Simple React App","url":"/jellyfish-docs/next/tutorials/simple-react-app#what-do-you-need","content":"a little bit of experience in creating React appsIDE of your choice (for example Visual Studio Code)Node.js installed on your machine "},{"title":"Jellyfish architecture​","type":1,"pageTitle":"Simple React App","url":"/jellyfish-docs/next/tutorials/simple-react-app#jellyfish-architecture","content":"info You can learn more about Jellyfish architecture in Jellyfish docs. This section provides a brief description aimed at front-end developers Let's introduce some concepts first: Peer - A peer is a client-side entity that connects to the server to publish, subscribe or publish and subscribe to tracks published by components or other peers. You can think of it as a participant in a room. At the moment, there is only one type of peer - WebRTC.Track - An object that represents an audio or video stream. A track can be associated with a local media source, such as a camera or microphone, or a remote media source received from another user. Tracks are used to capture, transmit, and receive audio and video data in WebRTC applications.Room - In Jellyfish, a room serves as a holder for peers and components, its function varying based on application. From a front-end perspective, this will be probably one meeting or a broadcast. For a better understanding of these concepts here is an example of a room that holds a standard WebRTC conference from a perspective of the User:  In this example, peers stream multiple video and audio tracks. Peer #1 streams even two video tracks (camera and screencast track). You can differentiate between them by using track metadata. The user gets info about peers and their tracks from the server using Jellyfish Client. The user is also informed in real time about peers joining/leaving and tracks being added/removed. To keep this tutorial short we'll simplify things a little. Every peer will stream just one video track. "},{"title":"Connecting and joining the room​","type":1,"pageTitle":"Simple React App","url":"/jellyfish-docs/next/tutorials/simple-react-app#connecting-and-joining-the-room","content":"The general flow of connecting to the server and joining the room in a standard WebRTC conference setup looks like this:  The parts that you need to implement are marked in blue and things handled by Jellyfish are marked in red. Firstly, the user logs in. Then your backend authenticates the user and obtains a peer token. It allows the user to authenticate and join the room in Jellyfish Server. The backend passes the token to your front-end, and your front-end passes it to Jellyfish Client. The client establishes the connection with Jellyfish Server. Then Jellyfish Client sets up tracks (camera, microphone) to stream and joins the room on Jellyfish Server. Finally, your front-end can display the room for the user. For this tutorial we simplified this process a bit - you don't have to implement a backend or authentication. Jellyfish Dashboard will do this for you. It's also a nice tool to test and play around with Jellyfish. The flow with Jellyfish Dashboard looks like this:  You can see that the only things you need to implement are interactions with the user and Jellyfish Client. This tutorial will show you how to do it. "},{"title":"Setup​","type":1,"pageTitle":"Simple React App","url":"/jellyfish-docs/next/tutorials/simple-react-app#setup","content":""},{"title":"Create React + Vite project​","type":1,"pageTitle":"Simple React App","url":"/jellyfish-docs/next/tutorials/simple-react-app#create-react--vite-project","content":"Firstly create a brand new project. npm create vite@latest my-react-app -- --template react-ts  "},{"title":"Add dependencies​","type":1,"pageTitle":"Simple React App","url":"/jellyfish-docs/next/tutorials/simple-react-app#add-dependencies","content":"For this module to work you'll need to add our `react-client-sdk` package. This is necessary to create and connect Jellyfish Client. npm install https://github.com/jellyfish-dev/react-client-sdk#0.1.2  "},{"title":"Start the Jellyfish backend​","type":1,"pageTitle":"Simple React App","url":"/jellyfish-docs/next/tutorials/simple-react-app#start-the-jellyfish-backend","content":"For testing, we'll run the Jellyfish Media Server locally using Docker image: docker run -p 50000-50050:50000-50050/udp \\ -p 5002:5002/tcp \\ -e JF_CHECK_ORIGIN=false \\ -e JF_HOST=&lt;your ip address&gt;:5002 \\ -e JF_PORT=&quot;5002&quot; \\ -e JF_WEBRTC_USED=true \\ -e JF_WEBRTC_TURN_PORT_RANGE=50000-50050 \\ -e JF_WEBRTC_TURN_IP=&lt;your ip address&gt; \\ -e JF_WEBRTC_TURN_LISTEN_IP=0.0.0.0 \\ -e JF_SERVER_API_TOKEN=development \\ ghcr.io/jellyfish-dev/jellyfish:0.2.0  Make sure to set JF_WEBRTC_TURN_IP and JF_HOST to your local IP address. Without it, the mobile device won't be able to connect to the Jellyfish. tip To check your local IP you can use this handy command (Linux/macOS): ifconfig | grep &quot;inet &quot; | grep -Fv 127.0.0.1 | awk '{print $2}'  "},{"title":"Start the dashboard web front-end​","type":1,"pageTitle":"Simple React App","url":"/jellyfish-docs/next/tutorials/simple-react-app#start-the-dashboard-web-front-end","content":"There are a couple of ways to start the dashboard: Up-to-date versionDocker containerOfficial repository The current version of the dashboard is ready to use and availablehere. Ensure that it is compatible with your Jellyfish server! Please note that this dashboard only supports secure connections (https/wss) or connections to localhost. Any insecure requests (http/ws) will be automatically blocked by the browser. "},{"title":"(Optional) Add a bit of CSS styling​","type":1,"pageTitle":"Simple React App","url":"/jellyfish-docs/next/tutorials/simple-react-app#optional-add-a-bit-of-css-styling","content":"For this project, we prepared simple CSS classes, You are free to use it or create your own. "},{"title":"General project structure​","type":1,"pageTitle":"Simple React App","url":"/jellyfish-docs/next/tutorials/simple-react-app#general-project-structure","content":"Our app will consist of two parts: a component that will connect to the server and join the room a component that will display the video tracks from other participants "},{"title":"First step - prepare all the hooks and the context​","type":1,"pageTitle":"Simple React App","url":"/jellyfish-docs/next/tutorials/simple-react-app#first-step---prepare-all-the-hooks-and-the-context","content":"To connect to the Jellyfish backend, we need to create a Membrane Client instance. We can do it by using the create function from the@jellyfish-dev/react-client-sdk package. It needs two generic parameters: PeerMetadata - the type of metadata that will be sent to the server when connecting to the room (for example, user name) it has to be serializable TrackMetadata - the type of the metadata that will be sent to the server when sending a track (for example, track name) it has to be serializable as well App.tsx import React from &quot;react&quot;; import { create } from &quot;@jellyfish-dev/react-client-sdk&quot;; // Example metadata types for peer and track // You can define your metadata types just make sure they are serializable type PeerMetadata = { name: string; }; type TrackMetadata = { type: &quot;camera&quot; | &quot;screen&quot;; }; // Create a Jellyfish client instance // Since we will use this context outside of the component we need to export it export const { JellyfishContextProvider, // Context provider } = create&lt;PeerMetadata, TrackMetadata&gt;(); export const App = () =&gt; {};  "},{"title":"Now we need to wrap our app with the context provider​","type":1,"pageTitle":"Simple React App","url":"/jellyfish-docs/next/tutorials/simple-react-app#now-we-need-to-wrap-our-app-with-the-context-provider","content":"That's all we will need to do in this file. Simply import the JellyfishContextProvider along with the Appcomponent and wrap the App component with the JellyfishContextProvider: main.tsx import React from &quot;react&quot;; import ReactDOM from &quot;react-dom/client&quot;; import { App, JellyfishContextProvider } from &quot;./components/App&quot;; ReactDOM.createRoot(document.getElementById(&quot;root&quot;) as HTMLElement).render( &lt;React.StrictMode&gt; &lt;JellyfishContextProvider&gt; &lt;App /&gt; &lt;/JellyfishContextProvider&gt; &lt;/React.StrictMode&gt; );  "},{"title":"UI component that will connect to the server and join the room​","type":1,"pageTitle":"Simple React App","url":"/jellyfish-docs/next/tutorials/simple-react-app#ui-component-that-will-connect-to-the-server-and-join-the-room","content":"The UI of the component will be quite simple. It will consist of a simple text input field that will allow us to enter the peer token and a button that will connect to the server and join the room. We can also display the status of the connection. App.tsx import React, { useState } from &quot;react&quot;; //... export const App = () =&gt; { // Create a state to store the peer token const [token, setToken] = useState(&quot;&quot;); return ( &lt;div style={{ display: &quot;flex&quot;, flexDirection: &quot;column&quot;, gap: &quot;8px&quot; }}&gt; &lt;input value={token} onChange={(e) =&gt; setToken(() =&gt; e?.target?.value)} placeholder=&quot;token&quot; /&gt; &lt;div style={{ display: &quot;flex&quot;, flexDirection: &quot;row&quot;, gap: &quot;8px&quot; }}&gt; &lt;button disabled={} onClick={() =&gt; {}}; &gt; Connect &lt;/button&gt; &lt;button disabled={} onClick={() =&gt; {}}; &gt; Disconnect &lt;/button&gt; &lt;span&gt;Status: {}&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; ); };  "},{"title":"Once the UI is ready, we need to implement the logic​","type":1,"pageTitle":"Simple React App","url":"/jellyfish-docs/next/tutorials/simple-react-app#once-the-ui-is-ready-we-need-to-implement-the-logic","content":"App.tsx import { SignalingUrl } from &quot;@jellyfish-dev/react-client-sdk/.&quot;; //... export const { useStatus, // Hook to check the status of the connection useConnect, // Hook to connect to the server useDisconnect, // Hook to disconnect from the server JellyfishContextProvider, // Context provider }; export const App = () =&gt; { // Create a state to store the peer token const [token, setToken] = useState(&quot;&quot;); // Use the built-in hook to check the status of the connection const status = useStatus(); const connect = useConnect(); const disconnect = useDisconnect(); return ( &lt;div style={{ display: &quot;flex&quot;, flexDirection: &quot;column&quot;, gap: &quot;8px&quot; }}&gt; &lt;input className=&quot;input-field&quot; value={token} onChange={(e) =&gt; setToken(() =&gt; e?.target?.value)} placeholder=&quot;token&quot; /&gt; &lt;div style={{ display: &quot;flex&quot;, flexDirection: &quot;row&quot;, gap: &quot;8px&quot; }}&gt; &lt;button className=&quot;button&quot; disabled={token === &quot;&quot; || status === &quot;joined&quot;} // simple check to avoid errors onClick={() =&gt; { connect({ peerMetadata: { name: &quot;John Doe&quot; }, // example metadata token: token, }); }} &gt; Connect &lt;/button&gt; &lt;button className=&quot;button&quot; disabled={status !== &quot;joined&quot;} onClick={() =&gt; { disconnect(); }} &gt; Disconnect &lt;/button&gt; &lt;span className=&quot;span-status&quot;&gt;Status: {status}&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; ); };  Great! Now we can connect to the server and join the room. But we still need to add some logic to send our tracks to the server and receive tracks from others. "},{"title":"Let's send our screen to the server​","type":1,"pageTitle":"Simple React App","url":"/jellyfish-docs/next/tutorials/simple-react-app#lets-send-our-screen-to-the-server","content":"This hook uses Navigator.mediaDevices take a look how it works App.tsx import React, { useEffect, useState } from &quot;react&quot;; import { create, SCREEN_SHARING_MEDIA_CONSTRAINTS } from &quot;@jellyfish-dev/react-client-sdk&quot;; import { SignalingUrl, Peer } from &quot;@jellyfish-dev/react-client-sdk/.&quot;; //... export const { useStatus, // Hook to check the status of the connection useApi, // Hook to get the webrtcApi reference useConnect, // Hook to connect to the server useDisconnect, // Hook to disconnect from the server JellyfishContextProvider, // Context provider } = create&lt;PeerMetadata, TrackMetadata&gt;(); export const App = () =&gt; { //... // Get the webrtcApi reference const webrtcApi = useApi(); function startScreenSharing() { // Get screen sharing MediaStream navigator.mediaDevices.getDisplayMedia(SCREEN_SHARING_MEDIA_CONSTRAINTS).then((screenStream) =&gt; { // Add local MediaStream to webrtc screenStream.getTracks().forEach((track) =&gt; webrtcApi.addTrack(track, screenStream, { type: &quot;screen&quot; })); }; }; return ( //... &lt;button className=&quot;button&quot; disabled={status !== &quot;joined&quot;} onClick={() =&gt; { startScreenSharing(); }} &gt; Start screen share &lt;/button&gt; &lt;span&gt;Status: {status}&lt;/span&gt; //... ) };  You should now see your screen received for each connected client on the dashboard. You can add another participant to check this out! The streaming part of the app is ready! "},{"title":"What about the receiving part?​","type":1,"pageTitle":"Simple React App","url":"/jellyfish-docs/next/tutorials/simple-react-app#what-about-the-receiving-part","content":""},{"title":"This is where the second component comes in handy​","type":1,"pageTitle":"Simple React App","url":"/jellyfish-docs/next/tutorials/simple-react-app#this-is-where-the-second-component-comes-in-handy","content":"For each track received, we will create a new video element and display it on the screen. For clarity, we will separate this component into another file: Create in your directory file VideoPlayer.tsx VideoPlayer.tsx type Props = { stream: MediaStream | null | undefined; }; const VideoPlayer = ({ stream }: Props) =&gt; { return ( &lt;div className=&quot;video-container&quot;&gt; &lt;video autoPlay playsInline muted ref={/* place for track ref*/} /&gt; &lt;/div&gt; ); }; export default VideoPlayer;  "},{"title":"Now the logic for the component​","type":1,"pageTitle":"Simple React App","url":"/jellyfish-docs/next/tutorials/simple-react-app#now-the-logic-for-the-component","content":"VideoPlayer.tsx type Props = { stream: MediaStream | null | undefined; }; const VideoPlayer = ({ stream }: Props) =&gt; { const videoRef: RefObject&lt;HTMLVideoElement&gt; = useRef&lt;HTMLVideoElement&gt;(null); useEffect(() =&gt; { if (!videoRef.current) return; videoRef.current.srcObject = stream || null; }, [stream]); return ( &lt;div&gt; &lt;video autoPlay playsInline muted ref={videoRef} /&gt; &lt;/div&gt; ); }; export default VideoPlayer;  "},{"title":"Now we can use it in our main component​","type":1,"pageTitle":"Simple React App","url":"/jellyfish-docs/next/tutorials/simple-react-app#now-we-can-use-it-in-our-main-component","content":"App.tsx import React, { useEffect, useState } from &quot;react&quot;; import { create, SCREEN_SHARING_MEDIA_CONSTRAINTS } from &quot;@jellyfish-dev/react-client-sdk&quot;; import { SignalingUrl, Peer } from &quot;@jellyfish-dev/react-client-sdk/.&quot;; import VideoPlayer from &quot;./VideoPlayer&quot;; //... export const { useStatus, // Hook to check the status of the connection useTracks, // Hook to get the tracks from the server useApi, // Hook to get the webrtcApi reference useConnect, // Hook to connect to the server useDisconnect, // Hook to disconnect from the server JellyfishContextProvider, // Context provider } = create&lt;PeerMetadata, TrackMetadata&gt;(); export const App = () =&gt; { const tracks = useTracks(); //... &lt;div style={{ display: &quot;flex&quot;, flexWrap: &quot;wrap&quot;, justifyContent: &quot;center&quot;, // To align items in the center gap: &quot;20px&quot;, }} &gt; {Object.values(tracks).map(({ stream, trackId }) =&gt; ( &lt;VideoPlayer key={trackId} stream={stream} /&gt; // pass the stream to the component ))} &lt;/div&gt; //... )  You should see all the tracks sent from the dashboard directly on your page, to test them, add a new client, and add a track (for example a rotating frog). It will show up in your app automatically: "},{"title":"Summary​","type":1,"pageTitle":"Simple React App","url":"/jellyfish-docs/next/tutorials/simple-react-app#summary","content":"Congrats on finishing your first Jellyfish web application! In this tutorial, You've learned how to make a basic Jellyfish client application that streams your screen and receives video tracks with WebRTC technology. But this was just the beginning. Jellyfish Client supports much more than just streaming camera: It can also stream audio or your device's camera, configure your camera and audio devices, detect voice activity, control simulcast, bandwidth and encoding settings, show camera preview, display WebRTC stats and more to come. Check out our other tutorials to learn about those features. You can also take a look at our fully featured Videoroom Demo example:  "},{"title":"Cluster","type":0,"sectionRef":"#","url":"/jellyfish-docs/cluster","content":"","keywords":""},{"title":"Configuring a Cluster​","type":1,"pageTitle":"Cluster","url":"/jellyfish-docs/cluster#configuring-a-cluster","content":"Jellyfish cluster can be created in 4 simple steps: Enable distribution mode with JF_DIST_ENABLED=trueGive your node a name with JF_DIST_NODE_NAMESpecify a list of nodes to connect to with JF_DIST_NODESConfigure HTTP and metrics ports so they don't overlap with other nodes. You can do this with JF_PORT and JF_METRICS_PORT environment variables. Distribution Environment Variables List of all cluster-related environment variables is available here. Security Currently, Jellyfish distribution is not encrypted meaning that data between Jellyfishes is sent as plain text. Cookie does not provide any cryptographic security. Do run a cluster only across machines in the same network! Extra network Configuration Jellyfish leverages Erlang Distribution to form a cluster. This means that we don't need to use any database where we would store information about network topology. Instead, some extra network configuration might be needed. Jellyfish uses a service called EPMD (Erlang Port Mapper Deamon) that runs on port 4369 (TCP). If you run Jellyfish using Docker, you have to explicitly export this port. In production deployment, you also have to allow for traffic on this port in your firewall. EPMD is started automatically when running Jellyfish, so you don't need to take any extra steps to make it work. Jellyfish uses a random port for connecting to other Jellyfishes. If you run Jellyfish using Docker, this port defaults to 9000 (TCP) but you can configure the range it is selected from with JF_DIST_MIN_PORT and JF_DIST_MAX_PORT. Note that JF_DIST_MIN_PORT and JF_DIST_MAX_PORT are not available when running from source (using mix phx.server) as in development you don't have to worry about the port used for forming a cluster. As in the case of EPMD, in production deployment, you have to modify your firewall rules appropriately. See Deeper dive into Erlang Distribution for more information. "},{"title":"Examples​","type":1,"pageTitle":"Cluster","url":"/jellyfish-docs/cluster#examples","content":""},{"title":"Running from source​","type":1,"pageTitle":"Cluster","url":"/jellyfish-docs/cluster#running-from-source","content":"Run the first Jellyfish: JF_DIST_ENABLED=true JF_DIST_NODE_NAME=j1@127.0.0.1 mix phx.server  Run the second Jellyfish JF_DIST_ENABLED=true JF_DIST_NODE_NAME=j2@127.0.0.1 JF_DIST_NODES=&quot;j1@127.0.0.1&quot; JF_PORT=4002 JF_METRICS_PORT=9468 mix phx.server  info Note that when running the second Jellyfish, we had to change its HTTP and metrics ports. "},{"title":"Running with Docker (locally)​","type":1,"pageTitle":"Cluster","url":"/jellyfish-docs/cluster#running-with-docker-locally","content":"This simple docker compose file sets a cluster of two Jellyfishes. version: &quot;3&quot; x-jellyfish-template: &amp;jellyfish-template build: . environment: &amp;jellyfish-environment JF_SERVER_API_TOKEN: &quot;development&quot; JF_DIST_ENABLED: &quot;true&quot; JF_DIST_MODE: &quot;sname&quot; JF_DIST_NODES: &quot;j1@jellyfish1 j2@jellyfish2&quot; restart: on-failure services: jellyfish1: &lt;&lt;: *jellyfish-template environment: &lt;&lt;: *jellyfish-environment JF_HOST: &quot;localhost:5001&quot; JF_PORT: 5001 JF_METRICS_PORT: 6001 JF_DIST_NODE_NAME: j1@jellyfish1 ports: - 5001:5001 - 6001:6001 jellyfish2: &lt;&lt;: *jellyfish-template environment: &lt;&lt;: *jellyfish-environment JF_HOST: &quot;localhost:5002&quot; JF_PORT: 5002 JF_METRICS_PORT: 6002 JF_DIST_NODE_NAME: j2@jellyfish2 ports: - 5002:5002 - 6002:6002  Because we run Jellyfishes in the same Docker network: we can use JF_DIST_NODE: &quot;sname&quot;, which allows us to reference Jellyfishes using their service names sojellyfish1 and jellyfish2we don't need to export EPMD (4369) or distribution (9000) ports "},{"title":"Running with Docker (globally)​","type":1,"pageTitle":"Cluster","url":"/jellyfish-docs/cluster#running-with-docker-globally","content":"When forming a cluster across multiple machines: you have to take care of Extra Network Configurationyou also can't use JF_DIST_MODE=&quot;sname&quot; as you have to name Jellyfish nodes using their publicly available IP address or domain names (see JF_DIST_NODE_NAME and JF_DIST_MODE)you can't simulate this setup locally as you won't be able to expose two EMPD ports on the same machine. See Deeper dive into Erlang Distribution for more information. See our Jellyfish Videoroom deployment configuration for an example. "},{"title":"Verifying that a cluster has been created​","type":1,"pageTitle":"Cluster","url":"/jellyfish-docs/cluster#verifying-that-a-cluster-has-been-created","content":"When a cluster is created correctly you will see a log indicating that one of your Jellyfishes connected to the other one, e.g.: [info] [libcluster:epmd_cluster] connected to :&quot;j1@127.0.0.1&quot;  To see clustering in action, create two rooms using the same Jellyfish address and observe how they are load balanced: curl -X POST -H &quot;authorization: Bearer development&quot; http://localhost:4002/room # {&quot;data&quot;:{&quot;jellyfish_address&quot;:&quot;localhost:4001&quot;}}  curl -X POST -H &quot;authorization: Bearer development&quot; http://localhost:4002/room # {&quot;data&quot;:{&quot;jellyfish_address&quot;:&quot;localhost:4002&quot;}}  Load balancing can also be tested using Jellyfish Dashboard. See here for more information. "},{"title":"Deeper dive into Erlang Distribution​","type":1,"pageTitle":"Cluster","url":"/jellyfish-docs/cluster#deeper-dive-into-erlang-distribution","content":"The most tricky thing when running Jellyfish in a cluster is to understand the role of EPMD. EPMD is responsible for mapping node names to ports they use. Node names consist of two parts nodename@hostname.hostname identifies a host machine, and nodename identifies a node on this machine. When node A wants to connect to node B, it uses node's B name to ask EPMD (running on node B) for the actual port node B is accessible on. Example Let's assume that node's B name is nodeb@192.168.1.2.Node A will contact EPMD using 192.168.1.2 IP address and port 4369, and ask for the port number used by a node with the name nodeb.After that, node A can contact node B using 192.168.1.2 IP address and port returned by EPMD. A couple of notes about EPMD: it always uses port 4369 (TCP)it is started automatically when running Jellyfishthere is one EPMD per machine or one EPMD per docker container - that's why we can't simulate Global Docker setup locally You can read more about Erlang Distribution here. "},{"title":"React Native Minimal Working Example","type":0,"sectionRef":"#","url":"/jellyfish-docs/next/tutorials/react-native","content":"","keywords":""},{"title":"What you'll learn​","type":1,"pageTitle":"React Native Minimal Working Example","url":"/jellyfish-docs/next/tutorials/react-native#what-youll-learn","content":"This tutorial will guide you through creating your first React Native / Expo project which uses Jellyfish client. By the end of the tutorial, you'll have a working application that connects to an instance of Jellyfish Server using WebRTC and streams and receives camera tracks.  You can check out the finished project here. "},{"title":"What do you need​","type":1,"pageTitle":"React Native Minimal Working Example","url":"/jellyfish-docs/next/tutorials/react-native#what-do-you-need","content":"a little bit of experience in creating apps with React Native and/or Expo - refer to the React Native Guide or Expo Guide to learn more "},{"title":"Jellyfish architecture​","type":1,"pageTitle":"React Native Minimal Working Example","url":"/jellyfish-docs/next/tutorials/react-native#jellyfish-architecture","content":"info You can learn more about Jellyfish architecture in Jellyfish docs. This section provides a brief description aimed at front-end developers Let's introduce some concepts first: Peer - A peer is a client-side entity that connects to the server to publish, subscribe or publish and subscribe to tracks published by components or other peers. You can think of it as a participant in a room. At the moment, there is only one type of peer - WebRTC.Track - An object that represents an audio or video stream. A track can be associated with a local media source, such as a camera or microphone, or a remote media source received from another user. Tracks are used to capture, transmit, and receive audio and video data in WebRTC applications.Room - In Jellyfish, a room serves as a holder for peers and components, its function varying based on application. From a front-end perspective, this will be probably one meeting or a broadcast. For a better understanding of these concepts here is an example of a room that holds a standard WebRTC conference from a perspective of the User:  In this example, peers stream multiple video and audio tracks. Peer #1 streams even two video tracks (camera and screencast track). You can differentiate between them by using track metadata. The user gets info about peers and their tracks from the server using Jellyfish Client. The user is also informed in real time about peers joining/leaving and tracks being added/removed. To keep this tutorial short we'll simplify things a little. Every peer will stream just one video track. "},{"title":"Connecting and joining the room​","type":1,"pageTitle":"React Native Minimal Working Example","url":"/jellyfish-docs/next/tutorials/react-native#connecting-and-joining-the-room","content":"The general flow of connecting to the server and joining the room in a standard WebRTC conference setup looks like this:  The parts that you need to implement are marked in blue and things handled by Jellyfish are marked in red. Firstly, the user logs in. Then your backend authenticates the user and obtains a peer token. It allows the user to authenticate and join the room in Jellyfish Server. The backend passes the token to your front-end, and your front-end passes it to Jellyfish Client. The client establishes the connection with Jellyfish Server. Then Jellyfish Client sets up tracks (camera, microphone) to stream and joins the room on Jellyfish Server. Finally, your front-end can display the room for the user. For this tutorial we simplified this process a bit - you don't have to implement a backend or authentication. Jellyfish Dashboard will do this for you. It's also a nice tool to test and play around with Jellyfish. The flow with Jellyfish Dashboard looks like this:  You can see that the only things you need to implement are interactions with the user and Jellyfish Client. This tutorial will show you how to do it. "},{"title":"Setup​","type":1,"pageTitle":"React Native Minimal Working Example","url":"/jellyfish-docs/next/tutorials/react-native#setup","content":""},{"title":"Start the Jellyfish Dashboard​","type":1,"pageTitle":"React Native Minimal Working Example","url":"/jellyfish-docs/next/tutorials/react-native#start-the-jellyfish-dashboard","content":"For testing, we'll run the Jellyfish Media Server locally using Docker image: docker run -p 50000-50050:50000-50050/udp \\ -p 5002:5002/tcp \\ -e JF_CHECK_ORIGIN=false \\ -e JF_HOST=&lt;your ip address&gt;:5002 \\ -e JF_PORT=&quot;5002&quot; \\ -e JF_WEBRTC_USED=true \\ -e JF_WEBRTC_TURN_PORT_RANGE=50000-50050 \\ -e JF_WEBRTC_TURN_IP=&lt;your ip address&gt; \\ -e JF_WEBRTC_TURN_LISTEN_IP=0.0.0.0 \\ -e JF_SERVER_API_TOKEN=development \\ ghcr.io/jellyfish-dev/jellyfish:0.2.0  Make sure to set JF_WEBRTC_TURN_IP and JF_HOST to your local IP address. Without it, the mobile device won't be able to connect to the Jellyfish. tip To check your local IP you can use this handy command (Linux/macOS): ifconfig | grep &quot;inet &quot; | grep -Fv 127.0.0.1 | awk '{print $2}'  "},{"title":"Start the dashboard web front-end​","type":1,"pageTitle":"React Native Minimal Working Example","url":"/jellyfish-docs/next/tutorials/react-native#start-the-dashboard-web-front-end","content":"There are a couple of ways to start the dashboard: Up-to-date versionDocker containerOfficial repository The current version of the dashboard is ready to use and availablehere. Ensure that it is compatible with your Jellyfish server! Please note that this dashboard only supports secure connections (https/wss) or connections to localhost. Any insecure requests (http/ws) will be automatically blocked by the browser. "},{"title":"Create React Native / Expo project​","type":1,"pageTitle":"React Native Minimal Working Example","url":"/jellyfish-docs/next/tutorials/react-native#create-react-native--expo-project","content":"Firstly create a brand new project. React NativeExpo Bare workflow npx react-native@latest init JellyfishDashboard  "},{"title":"Add dependencies​","type":1,"pageTitle":"React Native Minimal Working Example","url":"/jellyfish-docs/next/tutorials/react-native#add-dependencies","content":"note Please make sure to install or update expo to version ^49.0.0 You have two options here. You can follow configuration instructions for React Native (Expo Bare workflow is a React Native project after all) or if you're using expo prebuild command to set up native code you can add our Expo plugin. Just add it to app.json: { &quot;expo&quot;: { &quot;name&quot;: &quot;example&quot;, //... &quot;plugins&quot;: [&quot;@jellyfish-dev/react-native-membrane-webrtc&quot;] } }  React NativeExpo Bare workflow In order for this module to work you'll need to also add `expo` package. The expo package has a small footprint and it's necessary as Jellyfish Client package is built as Expo module. npx install-expo-modules@latest npm install @jellyfish-dev/react-native-client-sdk  tip Run pod install in the /ios directory to install the new pods "},{"title":"Native permissions configuration​","type":1,"pageTitle":"React Native Minimal Working Example","url":"/jellyfish-docs/next/tutorials/react-native#native-permissions-configuration","content":"In order for camera and audio to work you'll need to add some native configuration: You need to at least set up camera permissions. On Android add to your AndroidManifest.xml: AndroidManifest.xml &lt;uses-permission android:name=&quot;android.permission.CAMERA&quot;/&gt;  For audio you'll need the RECORD_AUDIO permission: AndroidManifest.xml &lt;uses-permission android:name=&quot;android.permission.RECORD_AUDIO&quot;/&gt;  On iOS you must set NSCameraUsageDescription in Info.plist file. You can edit this file in Xcode. This value is a description that is shown when iOS asks user for camera permission. ios/jellyfish-dashboard/Info.plist &lt;key&gt;NSCameraUsageDescription&lt;/key&gt; &lt;string&gt; 🙏 🎥 &lt;/string&gt;  Similarly, for audio there is NSMicrophoneUsageDescription. ios/jellyfish-dashboard/Info.plist &lt;key&gt;NSMicrophoneUsageDescription&lt;/key&gt; &lt;string&gt; 🙏 🎤 &lt;/string&gt;  For screencast there is more configuration needed, it's described here. We also suggest setting background mode to audio so that the app doesn't disconnect when it's in the background: ios/jellyfish-dashboard/Info.plist &lt;key&gt;UIBackgroundModes&lt;/key&gt; &lt;array&gt; &lt;string&gt;audio&lt;/string&gt; &lt;/array&gt;  "},{"title":"Add components library​","type":1,"pageTitle":"React Native Minimal Working Example","url":"/jellyfish-docs/next/tutorials/react-native#add-components-library","content":"For your convenience, we've prepared a library with nice-looking components useful for following this tutorial. Feel free to use standard React Native components or your own components though! npx expo install @expo/vector-icons expo-barcode-scanner expo-font @expo-google-fonts/noto-sans @jellyfish-dev/react-native-jellyfish-components @react-navigation/native-stack  You'll also need to install Reanimated library (3.3.0) and React Navigation (6.1.7) tip Run pod install in the /ios directory to install the new pods "},{"title":"Screens​","type":1,"pageTitle":"React Native Minimal Working Example","url":"/jellyfish-docs/next/tutorials/react-native#screens","content":"For managing screens we will use React Navigation library, but feel free to pick whatever suits you. Our app will consist of two screens. The first one ConnectScreen will allow a user to type, paste or scan a peer token and connect to the room. The second one RoomScreen will show room participants with their video tracks. /App.tsx import React from &quot;react&quot;; import { NavigationContainer } from &quot;@react-navigation/native&quot;; import { createNativeStackNavigator } from &quot;@react-navigation/native-stack&quot;; import ConnectScreen from &quot;./screens/Connect&quot;; import RoomScreen from &quot;./screens/Room&quot;; const Stack = createNativeStackNavigator(); function App(): JSX.Element { return ( &lt;NavigationContainer&gt; &lt;Stack.Navigator&gt; &lt;Stack.Screen name=&quot;Connect&quot; component={ConnectScreen} /&gt; &lt;Stack.Screen name=&quot;Room&quot; component={RoomScreen} /&gt; &lt;/Stack.Navigator&gt; &lt;/NavigationContainer&gt; ); } export default App;  "},{"title":"ConnectScreen​","type":1,"pageTitle":"React Native Minimal Working Example","url":"/jellyfish-docs/next/tutorials/react-native#connectscreen","content":"The UI of the ConnectScreen consists of a simple text input and a few buttons. The flow for this screen is simple: the user either copies the peer token from the dashboard or scans it with a QR code scanner and presses Connect button. The QR code scanner is provided by our components library and it's completely optional, just for convenience. The code for the UI looks like this: /screens/Connect.tsx import React, { useState } from &quot;react&quot;; import { View, StyleSheet } from &quot;react-native&quot;; import { Button, TextInput, QRCodeScanner, } from &quot;@jellyfish-dev/react-native-jellyfish-components&quot;; import { NavigationProp } from &quot;@react-navigation/native&quot;; interface ConnectScreenProps { navigation: NavigationProp&lt;any&gt;; } function ConnectScreen({ navigation }: ConnectScreenProps): JSX.Element { const [peerToken, setPeerToken] = useState&lt;string&gt;(&quot;&quot;); return ( &lt;View style={styles.container}&gt; &lt;TextInput placeholder=&quot;Enter peer token&quot; value={peerToken} onChangeText={setPeerToken} /&gt; &lt;Button onPress={() =&gt; { /* to be filled */ }} title=&quot;Connect&quot; disabled={!peerToken} /&gt; &lt;QRCodeScanner onCodeScanned={setPeerToken} /&gt; &lt;/View&gt; ); } const styles = StyleSheet.create({ container: { flex: 1, justifyContent: &quot;center&quot;, backgroundColor: &quot;#BFE7F8&quot;, padding: 24, rowGap: 24, }, }); export default ConnectScreen;  "},{"title":"Connecting to the server​","type":1,"pageTitle":"React Native Minimal Working Example","url":"/jellyfish-docs/next/tutorials/react-native#connecting-to-the-server","content":"Once the UI is ready, let's implement the logic responsible for connecting to the server. Firstly wrap your app with JelyfishContextProvider: /App.tsx import React from &quot;react&quot;; import { JellyfishContextProvider } from &quot;@jellyfish-dev/react-native-client-sdk&quot;; import { NavigationContainer } from &quot;@react-navigation/native&quot;; import { createNativeStackNavigator } from &quot;@react-navigation/native-stack&quot;; import ConnectScreen from &quot;./screens/Connect&quot;; import RoomScreen from &quot;./screens/Room&quot;; const Stack = createNativeStackNavigator(); function App(): JSX.Element { return ( &lt;JellyfishContextProvider&gt; &lt;NavigationContainer&gt; &lt;Stack.Navigator&gt; &lt;Stack.Screen name=&quot;Connect&quot; component={ConnectScreen} /&gt; &lt;Stack.Screen name=&quot;Room&quot; component={RoomScreen} /&gt; &lt;/Stack.Navigator&gt; &lt;/NavigationContainer&gt; &lt;/JellyfishContextProvider&gt; ); } export default App;  Then in the ConnectScreen use the useJellyfishClient hook to connect to the server. Simply call the connect method with your Jellyfish server URL and the peer token. The connect function establishes a connection with the Jellyfish server via web socket and authenticates the peer. /screens/Connect.tsx import { useJellyfishClient } from &quot;@jellyfish-dev/react-native-client-sdk&quot;; import { NavigationProp } from &quot;@react-navigation/native&quot;; interface ConnectScreenProps { navigation: NavigationProp&lt;any&gt;; } // This is the address of the Jellyfish backend. Change the local IP to yours. We // strongly recommend setting this as an environment variable, we hardcoded it here // for simplicity. const JELLYFISH_URL = &quot;ws://X.X.X.X:4000/socket/peer/websocket&quot;; function ConnectScreen({ navigation }: ConnectScreenProps): JSX.Element { const [peerToken, setPeerToken] = useState&lt;string&gt;(&quot;&quot;); const { connect } = useJellyfishClient(); const connectToRoom = async () =&gt; { try { await connect(JELLYFISH_URL, peerToken.trim()); } catch (e) { console.log(&quot;Error while connecting&quot;, e); } }; return ( &lt;View style={styles.container}&gt; &lt;TextInput placeholder=&quot;Enter peer token&quot; value={peerToken} onChangeText={setPeerToken} /&gt; &lt;Button onPress={connectToRoom} title=&quot;Connect&quot; disabled={!peerToken} /&gt; &lt;QRCodeScanner onCodeScanned={setPeerToken} /&gt; &lt;/View&gt; ); } // ...  "},{"title":"Camera permissions (Android only)​","type":1,"pageTitle":"React Native Minimal Working Example","url":"/jellyfish-docs/next/tutorials/react-native#camera-permissions-android-only","content":"To start the camera we need to ask the user for permission first. We'll use a standard React Native module for this: /screens/Connect.tsx import { View, StyleSheet, type Permission, PermissionsAndroid, Platform, } from &quot;react-native&quot;; // ... function ConnectScreen({ navigation }: ConnectScreenProps): JSX.Element { // ... const grantedCameraPermissions = async () =&gt; { if (Platform.OS === &quot;ios&quot;) return true; const granted = await PermissionsAndroid.request( PermissionsAndroid.PERMISSIONS.CAMERA as Permission ); if (granted !== PermissionsAndroid.RESULTS.GRANTED) { console.error(&quot;Camera permission denied&quot;); return false; } return true; }; const connectToRoom = async () =&gt; { try { await connect(JELLYFISH_URL, peerToken.trim()); if (!(await grantedCameraPermissions())) { return; } } catch (e) { console.log(&quot;Error while connecting&quot;, e); } }; // ... } // ...  "},{"title":"Starting the camera​","type":1,"pageTitle":"React Native Minimal Working Example","url":"/jellyfish-docs/next/tutorials/react-native#starting-the-camera","content":"Jellyfish Client provides a handy hook for managing the camera: useCamera. Not only it can start a camera but also toggle it, manage its state, simulcast and bandwidth settings, and switch between multiple sources. Also when starting the camera you can provide multiple different settings such as resolution, quality, and metadata. In this example though we'll simply turn it on to stream the camera to the dashboard with default settings /screens/Connect.tsx import { useJellyfishClient, useCamera, } from &quot;@jellyfish-dev/react-native-client-sdk&quot;; // ... function ConnectScreen({ navigation }: ConnectScreenProps): JSX.Element { // ... const { startCamera } = useCamera(); const connectToRoom = async () =&gt; { try { await connect(JELLYFISH_URL, peerToken.trim()); if (!(await grantedCameraPermissions())) { return; } await startCamera(); } catch (e) { console.log(&quot;Error while connecting&quot;, e); } }; // ... } // ...  "},{"title":"Joining the room​","type":1,"pageTitle":"React Native Minimal Working Example","url":"/jellyfish-docs/next/tutorials/react-native#joining-the-room","content":"The last step of connecting to the room would be actually joining it so that your camera track is visible to the other users. To do this simply use the join function from the useJellyfishClient hook. You can also provide some user metadata when joining. Metadata can be anything and is forwarded to the other participants as is. In our case, we pass a username. After joining the room we navigate to the next screen: Room screen. /screens/Connect.tsx // ... function ConnectScreen({ navigation }: ConnectScreenProps): JSX.Element { const { connect, join } = useJellyfishClient(); const connectToRoom = async () =&gt; { try { await connect(JELLYFISH_URL, peerToken.trim()); if (!(await grantedCameraPermissions())) { return; } await startCamera(); await join({ name: &quot;Mobile RN Client&quot; }); navigation.navigate(&quot;Room&quot;); } catch (e) { console.log(&quot;Error while connecting&quot;, e); } }; // ... } // ...  Now the app is ready for the first test. If everything went well you should see a video from your camera in the front-end dashboard. Now onto the second part: displaying the streams from other participants. "},{"title":"RoomScreen​","type":1,"pageTitle":"React Native Minimal Working Example","url":"/jellyfish-docs/next/tutorials/react-native#roomscreen","content":""},{"title":"Displaying video tracks​","type":1,"pageTitle":"React Native Minimal Working Example","url":"/jellyfish-docs/next/tutorials/react-native#displaying-video-tracks","content":"The Room screen has a couple of responsibilities: it displays your own video. Note that it's taken directly from your camera i.e. we don't send it to the JF and get it back so other participants might see you a little bit differentlyit presents current room state so participants list, their video tiles, etc.it allows you to leave a meeting To get information about all participants (also the local one) in the room useusePeers() hook from Jellyfish Client. The hook returns all the participants with their ids, tracks and metadata. When a new participant joins or any participant leaves or anything else changes, the hook updates with the new information. To display video tracks Jellyfish Client comes with a dedicated component for displaying a video track: &lt;VideoRenderer&gt;. It takes a track id as a prop (it may be a local or remote track) and, as any other &lt;View&gt; in react, a style. style property gives a lot of possibilities. You can even animate your track! So, let's display all the participants in the simplest way possible: /screens/Room.tsx import React from &quot;react&quot;; import { View, StyleSheet } from &quot;react-native&quot;; import { NavigationProp, RouteProp } from &quot;@react-navigation/native&quot;; import { usePeers, VideoRendererView, } from &quot;@jellyfish-dev/react-native-client-sdk&quot;; interface RoomScreenProps { navigation: NavigationProp&lt;YourNavigatorParamList&gt;; } function RoomScreen({ navigation }: RoomScreenProps): JSX.Element { const peers = usePeers(); return ( &lt;View style={styles.container}&gt; &lt;View style={styles.videoContainer}&gt; {peers.map((peer) =&gt; peer.tracks[0] ? ( &lt;VideoRendererView trackId={peer.tracks[0].id} style={styles.video} /&gt; ) : null )} &lt;/View&gt; &lt;/View&gt; ); } const styles = StyleSheet.create({ container: { flex: 1, alignItems: &quot;center&quot;, justifyContent: &quot;space-between&quot;, backgroundColor: &quot;#F1FAFE&quot;, padding: 24, }, videoContainer: { flexDirection: &quot;row&quot;, gap: 8, flexWrap: &quot;wrap&quot;, }, video: { width: 200, height: 200 }, }); export default RoomScreen;  You should now see your own camera on your mobile device. You can add another participant and their new track (displaying for example rotating frog) in the dashboard like this:  It should show up in the Room screen automatically:  For your convenience in our components library we provided a component to layout videos in a nice grid: /screens/Room.tsx import { VideosGrid } from &quot;@jellyfish-dev/react-native-jellyfish-components&quot;; // ... function RoomScreen({ navigation }: RoomScreenProps): JSX.Element { const peers = usePeers(); return ( &lt;View style={styles.container}&gt; &lt;VideosGrid tracks={peers.map((peer) =&gt; peer.tracks[0]?.id).filter((t) =&gt; t)} /&gt; &lt;/View&gt; ); }  "},{"title":"Gracefully leaving the room​","type":1,"pageTitle":"React Native Minimal Working Example","url":"/jellyfish-docs/next/tutorials/react-native#gracefully-leaving-the-room","content":"To leave a room we'll add a button for the user. When the user clicks it, we gracefully leave the room, close the server connection and go back to theConnectscreen. For leaving the room and closing the server connection you can use the cleanUp method from the useJellyfishClient() hook. /screens/Room.tsx // ... import { usePeers, VideoRendererView, useJellyfishClient, } from &quot;@jellyfish-dev/react-native-client-sdk&quot;; import { InCallButton } from &quot;@jellyfish-dev/react-native-jellyfish-components&quot;; // ... function RoomScreen({ navigation }: RoomScreenProps): JSX.Element { const peers = usePeers(); const { cleanUp } = useJellyfishClient(); const onDisconnectPress = () =&gt; { cleanUp(); navigation.goBack(); }; return ( &lt;View style={styles.container}&gt; &lt;VideosGrid tracks={peers.map((peer) =&gt; peer.tracks[0]?.id).filter((t) =&gt; t)} /&gt; &lt;InCallButton type=&quot;disconnect&quot; iconName=&quot;phone-hangup&quot; onPress={onDisconnectPress} /&gt; &lt;/View&gt; ); } // ...  To launch your app, you can use the following command: iosandroid npm run ios  "},{"title":"Summary​","type":1,"pageTitle":"React Native Minimal Working Example","url":"/jellyfish-docs/next/tutorials/react-native#summary","content":"Congrats on finishing your first Jellyfish mobile application! In this tutorial, you've learned how to make a basic Jellyfish client application that streams and receives video tracks with WebRTC technology. But this was just the beginning. Jellyfish Client supports much more than just streaming camera: it can also stream audio, screencast your device's screen, configure your camera and audio devices, detect voice activity, control simulcast, bandwidth and encoding settings, show camera preview, display WebRTC stats and more to come. Check out our other tutorials to learn about those features. You can also take a look at our fully featured Videoroom Demo example:  "},{"title":"Fly.io (experimental)","type":0,"sectionRef":"#","url":"/jellyfish-docs/deploying/fly_io","content":"","keywords":""},{"title":"Creating new app​","type":1,"pageTitle":"Fly.io (experimental)","url":"/jellyfish-docs/deploying/fly_io#creating-new-app","content":"Launch fly launch. When prompted, copy the configuration from the existing fly.toml file. Select appropriate app name and region, don't create any databases. Don't deploy the app just yet. Running fly launch may modify the Dockerfile. Make sure to remove the lines appended by flyctl. "},{"title":"Configuring the App​","type":1,"pageTitle":"Fly.io (experimental)","url":"/jellyfish-docs/deploying/fly_io#configuring-the-app","content":"Before deploying your app, make sure it is correctly configured. "},{"title":"Dedicated IPv4​","type":1,"pageTitle":"Fly.io (experimental)","url":"/jellyfish-docs/deploying/fly_io#dedicated-ipv4","content":"In order to transmit multimedia via UDP, the app has to be publicly available with an IPv4 address. By default Fly.io uses shared IP. To enable dedicated IPv4 address run fly ips allocate-v4  Note, that dedicated IP address is a paid feature on Fly.io. You can learn more about dedicated IPv4 address here. "},{"title":"fly.toml​","type":1,"pageTitle":"Fly.io (experimental)","url":"/jellyfish-docs/deploying/fly_io#flytoml","content":"Make sure you don't have the following lines in the fly.toml, which are automatically generated by fly launch. You don't need to run migrations, since you don't have a database. [deploy] release_command = &quot;/app/bin/migrate&quot;  Jellyfish uses JF_HOST variable instead of the default PHX_HOST. JF_HOST = &quot;&lt;YOUR APP HOSTNAME&gt;&quot;  Also, make sure you have set the correct port. The environment variable JF_PORT has to match the TCP internal_port defined under services section. The default for Jellyfish is 5002 in development and 8080 in production (when using Docker or mix release). To be able to receive and send UDP traffic, Jellyfish has to open its UDP ports on a special fly-global-services address, not 0.0.0.0. This must be set using the JF_WEBRTC_TURN_LISTEN_IP enviroment variable. You also need to specify the Jellyfish IP address for UDP, it is the IP address which you generated in the previous step. JF_WEBRTC_TURN_LISTEN_IP = &quot;fly-global-services&quot; JF_WEBRTC_TURN_IP=&quot;&lt;YOUR APP IP ADDRESS&gt;&quot;  You can also read tutorial for running Fly.io apps which use UDP. "},{"title":"Fly.io secrets​","type":1,"pageTitle":"Fly.io (experimental)","url":"/jellyfish-docs/deploying/fly_io#flyio-secrets","content":"There are environment variables, which you may not want to keep in the fly.toml config. Fly.io provides a way to store such values securely. For Jellyfish you need to configure just one secret - JF_SERVER_API_TOKEN. flyctl secrets set JF_SERVER_API_TOKEN=development  "},{"title":"Deploying​","type":1,"pageTitle":"Fly.io (experimental)","url":"/jellyfish-docs/deploying/fly_io#deploying","content":"With everything configured you can deploy the app fly deploy  Note that it may take a moment for the UDP traffic to be forwarded to the application. This means for example, that WebRTC may not be working yet. This is the tricky part of the deployment, which we weren't able to entirely figure out. Sometimes the UDP just works, others it takes ages for it to start flowing.This topic describes the exact issue we had with Fly.io. In general, it is unclear when the UDP traffic starts to be forwarded, sometimes it happens relatively quickly after deployment, sometimes you need to wait for some time. Also, the Fly.io documentation isn't clear in regard to opening UDP sockets. Some information was gathered experimentally, or based on Fly.io community questions, such as this one. "},{"title":"Examples","type":0,"sectionRef":"#","url":"/jellyfish-docs/examples","content":"Examples Jellyfish usage examples utilising server SDKs can be found in the following locations: Elixir","keywords":""},{"title":"API Reference","type":0,"sectionRef":"#","url":"/jellyfish-docs/for_developers/api_reference","content":"API Reference Jellyfish API is composed of three layers a REST API for managing Jellyfish statea WS connection for client SDK communication (socket path /socket/peer)a WS connection for server notifications (socket path /socket/server) You can find them here: OpenAPI REST descriptionProtobufs used by peer WSProtobufs used by server WS The communication via WebSockets uses Protobuf format. The very first message that has to be sent on either of the WebSocket connections (peer to Jellyfish oryour_backend_server to Jellyfish) is AuthRequest. All supported messages are listed in the Jellyfish protos repo. If you want to create your own Jellyfish SDK, the easiest way to reference defined protobuf messages will be by adding protos to your git repository as a git submodule. You can do it with this command: git submodule add https://github.com/jellyfish-dev/protos You could also consider creating a script that will pull the newest changes from the git submodule and compile.proto files to your chosen programming language. For reference, see the script used in our Elixir SDK.","keywords":""},{"title":"Cloud VPS with cloud-init","type":0,"sectionRef":"#","url":"/jellyfish-docs/deploying/vps","content":"","keywords":""},{"title":"1. Creating primary IP​","type":1,"pageTitle":"Cloud VPS with cloud-init","url":"/jellyfish-docs/deploying/vps#1-creating-primary-ip","content":"Because configuring a server with cloud-init using our script requires you to have a registered domain pointing at a particular IP address, we divided the process of creating VPS into two parts: obtaining dedicated IP addressconfiguring the server using cloud-init Let's start with the first one. In Hetzner's project site go to the section Primary IPs then click Create Primary IP button. Choose a data center location for your server and select IPv4 protocol. You can also name that IP if you'd like. "},{"title":"2. Registering Domain​","type":1,"pageTitle":"Cloud VPS with cloud-init","url":"/jellyfish-docs/deploying/vps#2-registering-domain","content":"We'll not suggest you to use a specific domain provider, maybe you've got one chosen so we'll describe this step without details that may be different among providers. If you'd like, you can use Hetzner as well to register a domain. After registering your domain go to the DNS Records Table of your provider and create an A record pointing to the IP you've created in the previous step. "},{"title":"3. Choosing the right VPS​","type":1,"pageTitle":"Cloud VPS with cloud-init","url":"/jellyfish-docs/deploying/vps#3-choosing-the-right-vps","content":"Now let's go back to the Hetzner project site. It's time to choose and configure a server for Jellyfish. Although Jellyfish doesn't have minimum requirements to work, we encourage you to choose a middle-sized VPS (at least 8 cores) as media processing is consuming quite a lot of CPU. Remember to choose a server located in the data center where you've created an IP address in the first step. For this tutorial, we decided on CPX21 from Hetzner Cloud running Ubuntu 22:  "},{"title":"4. Assigning Primary IP​","type":1,"pageTitle":"Cloud VPS with cloud-init","url":"/jellyfish-docs/deploying/vps#4-assigning-primary-ip","content":"Below the list of the VPS types there is a Networking section where your Primary IP from Step 1 is waiting to be used. Select it.  "},{"title":"5. Adding a cloud-init configuration​","type":1,"pageTitle":"Cloud VPS with cloud-init","url":"/jellyfish-docs/deploying/vps#5-adding-a-cloud-init-configuration","content":"To configure a server and install Jellyfish on it we're going to use cloud-init. It's a preinstalled tool that lets you set up a newly created server with a YAML config file. In the configuration you can create a user, choose packages to be installed, configure them, write or modify files and in our case finally run a docker container. Full documentation about keys you can use in a cloud-config file can be found in the official cloud-init documentation. "},{"title":"A cloud-config template​","type":1,"pageTitle":"Cloud VPS with cloud-init","url":"/jellyfish-docs/deploying/vps#a-cloud-config-template","content":"We prepared a template cloud-config that will configure your server and start a chosen version of Jellyfish: cloud-config.yaml #cloud-config users: - name: jellyfish groups: docker sudo: null shell: /bin/false no_create_home: true ssh_pwauth: false disable_root_opts: no-port-forwarding,no-agent-forwarding,no-X11-forwarding apt: sources: docker.list: source: &quot;deb [arch=amd64,arm64] https://download.docker.com/linux/ubuntu jammy stable&quot; keyid: 9DC858229FC7DD38854AE2D88D81803C0EBFCD88 packages: - ufw - fail2ban - gzip - containerd.io - docker-ce - docker-ce-cli - nginx - certbot write_files: - path: /opt/jellyfish/env-file defer: true owner: jellyfish:jellyfish runcmd: - export JELLYFISH_VERSION=0.2.0 - export JELLYFISH_DOMAIN=mydomain.example.com - export LETSENCRYPT_EMAIL=my@email.com - export SERVER_API_TOKEN=test_token - systemctl enable fail2ban - ufw default deny outgoing - ufw default deny incoming - ufw default deny routed - ufw allow in ssh - ufw allow out https - ufw allow out domain - ufw allow in 80/tcp - ufw allow in 443/tcp - ufw allow in 50000:500100/udp - ufw allow in 49999/tcp - ufw allow out 5002 - ufw allow out from any port 50000:50100 proto udp to any - ufw allow out 49999 proto tcp to any - ufw enable - service nginx stop - &quot;[ ! -f /etc/letsencrypt/live/$JELLYFISH_DOMAIN/cert.pem ] &amp;&amp; certbot certonly --standalone --noninteractive --agree-tos --email $LETSENCRYPT_EMAIL -d $JELLYFISH_DOMAIN&quot; - | cat &lt;&lt; EOF &gt; /etc/cron.d/cert_renew 0 4 * * * [jellyfish] certbot certonly --webroot -w /usr/share/nginx/html -d $JELLYFISH_DOMAIN --keep-until-expiring --quiet 5 4 * * * [jellyfish] service nginx reload EOF - | cat &lt;&lt; EOF &gt; /etc/nginx/sites-available/$JELLYFISH_DOMAIN server { server_name $JELLYFISH_DOMAIN; location / { proxy_pass http://localhost:5002; proxy_http_version 1.1; proxy_set_header Upgrade \\$http_upgrade; proxy_set_header Connection &quot;Upgrade&quot;; proxy_set_header Host \\$host; } listen [::]:443 ssl http2; # managed by Certbot listen 443 ssl http2; # managed by Certbot ssl_certificate /etc/letsencrypt/live/$JELLYFISH_DOMAIN/fullchain.pem; # managed by Certbot ssl_certificate_key /etc/letsencrypt/live/$JELLYFISH_DOMAIN/privkey.pem; # managed by Certbot } server { listen 80; listen [::]:80; server_name $JELLYFISH_DOMAIN; # Do not HTTPS redirect Let'sEncrypt ACME challenge location /.well-known/acme-challenge/ { auth_basic off; allow all; root /usr/share/nginx/html; try_files \\$uri =404; break; } location / { return 301 https://\\$host\\$request_uri; } } EOF - ln -sf /etc/nginx/sites-available/$JELLYFISH_DOMAIN /etc/nginx/sites-enabled/$JELLYFISH_DOMAIN - service nginx start - | cat &lt;&lt; EOF &gt; /opt/jellyfish/env-file JF_HOST=$JELLYFISH_DOMAIN JF_PORT=5002 JF_SERVER_API_TOKEN=$SERVER_API_TOKEN JF_CHECK_ORIGIN=false JF_WEBRTC_TURN_IP=$(ip route get 1.0.0.0 | sed -n 's/^.*src \\([0-9.]*\\) .*$/\\1/p') JF_WEBRTC_TURN_TCP_PORT=49999 JF_WEBRTC_TURN_PORT_RANGE=50000-50100 JF_WEBRTC_TURN_LISTEN_IP=0.0.0.0 EOF - [ su, jellyfish, -s, /bin/bash, -c, &quot;docker run -d \\ --restart unless-stopped \\ -p 50000-50100:50000-50100/udp \\ -p 5002:5002 \\ --env-file /opt/jellyfish/env-file \\ -v /opt/jellyfish/jellyfish_output:/app/jellyfish_output \\ ghcr.io/jellyfish-dev/jellyfish:$JELLYFISH_VERSION&quot;, ]  You'll need to manually take care of four lines in that template: - export JELLYFISH_VERSION=0.1.0-ed317bChange the value if you want to deploy a different version of Jellyfish. You can find the list of available versions in our package repository- export JELLYFISH_DOMAIN=mydomain.example.comEnter here a domain you've configured with A record in step 2.- export LETSENCRYPT_EMAIL=my@email.comEnter your email address to be notified when the SSL certificate will be about to expire.export SERVER_API_TOKEN=test_tokenServer API token is a token you'll need to connect to Jellyfish via API or SDK. Write here a chosen secret value you're going to remember later. Copy the file and change up those two variables. You're going to need the content of the file in the next section. "},{"title":"Other tools we'll install with cloud-init​","type":1,"pageTitle":"Cloud VPS with cloud-init","url":"/jellyfish-docs/deploying/vps#other-tools-well-install-with-cloud-init","content":"As you might noticed we've chosen some packages to be installed: ufw - Uncomplicated Firewall. We'll need it to allow or block traffic on specific ports https://help.ubuntu.com/community/UFW.fail2ban - Tool to block traffic recognized as unauthorized https://www.fail2ban.org/wiki/index.php/Main_Pagegzip - Compression Utility https://www.gzip.org/containerd.io, docker-ce, docker-ce-cli - Docker and Docker-related libraries. "},{"title":"Setting up Hetzner cloud VPS with cloud-config​","type":1,"pageTitle":"Cloud VPS with cloud-init","url":"/jellyfish-docs/deploying/vps#setting-up-hetzner-cloud-vps-with-cloud-config","content":"Now, we're going to use the content of the file you prepared in the Hetzner cloud VPS creating form. To do it scroll to the Cloud config section of the form and paste the content of your cloud-config.yaml file.  caution cloud-init will recognize the file as a configuration only if the file starts with that comment: #cloud-config ... So be careful while copying. That's it. You can click 'Create &amp; Buy' and the server will start to configure. tip Think about adding your public SSH key while creating a VPS instance. It will ease up connecting to VPS later. If you don't add any key you're going to need a root password (you'll receive it in an email after creating VPS) "},{"title":"6. Checking cloud-init status​","type":1,"pageTitle":"Cloud VPS with cloud-init","url":"/jellyfish-docs/deploying/vps#6-checking-cloud-init-status","content":"Configuring your server will take some time, but it's created almost immediately after creation. You can log into the server using ssh: ssh root@&lt;VPS_IP&gt;  then, in the server's terminal you can check the current status of cloud-init: cloud-init status  Possible responses are running, error and done. The first one informs you that cloud-init is still configuring your server. The second one means that something went wrong. You can find logs from the cloud-init run in /var/log/cloud-init-output.log file.done means that your jellyfish server is ready to be used. If you'd like to keep an eye on the cloud-init process you can use: cloud-init status --wait  To see the output when the process is finished (successfully or not). "},{"title":"Testing your instance with the Jellyfish dashboard​","type":1,"pageTitle":"Cloud VPS with cloud-init","url":"/jellyfish-docs/deploying/vps#testing-your-instance-with-the-jellyfish-dashboard","content":"To see how (or if) your Jellyfish server is working you can test it by connecting our Jellyfish Dashboard with your server. Detailed instructions on how to use Jellyfish Dashboard can be found here. "},{"title":"Design Docs","type":0,"sectionRef":"#","url":"/jellyfish-docs/for_developers/design_docs","content":"Design Docs Crucial parts of Jellyfish architecture are always discussed and written down in the form of design documents. Each design document describes, in a nutshell, a few possible solutions or approaches to some problem and states which solution was accepted and why. The list of Jellyfish Design Docs is available here.","keywords":""},{"title":"Architecture","type":0,"sectionRef":"#","url":"/jellyfish-docs/getting_started/architecture","content":"","keywords":""},{"title":"Server SDKs​","type":1,"pageTitle":"Architecture","url":"/jellyfish-docs/getting_started/architecture#server-sdks","content":"Server SDKs allow you to manage Jellyfish state. In particular, you can: authenticatecreate/delete roomsadd/remove peersadd/remove componentssubscribe for notifications Under the hood, Server SDKs just use Jellyfish REST and WS API, see Jellyfish API. tip As an example, you can use server SDK to introduce a time limit on meeting duration and shut down the room after it passes. "},{"title":"Client SDKs​","type":1,"pageTitle":"Architecture","url":"/jellyfish-docs/getting_started/architecture#client-sdks","content":"Client SDKs allow you to connect to Jellyfish to publish and consume tracks. In particular, you can: authenticatejoin specific roompublish audio and videoreceive audio and video from other peers and components At the moment, Jellyfish supports only one type of client - WebRTC. "},{"title":"Diagram​","type":1,"pageTitle":"Architecture","url":"/jellyfish-docs/getting_started/architecture#diagram","content":"The whole concept is presented in the following diagram.     Your Backend (BE) - serves your application frontend, and manages the database and application-specific logic. Jellyfish (JF) - Jellyfish media server. Manages media. Admin - someone who has special permission in your application - can create/delete rooms, add/remove peers, etc. User - someone who connects to Jellyfish to send and receive media. Everything starts with Admin who sends an HTTP request to BE to create a new room.BE uses jellyfish-server-sdk to communicate with JF and create the room. Under the hood, jellyfish-server-sdk uses REST API exposed by JF. After the room has been created, the Admin invites a user by sending a new HTTP request to BE. Again, BE uses jellyfish-server-sdk to add the new peer to JF. On the user side, they send a request to BE to join the room.BE replies with JF IP address it should connect to. Then, the User uses jellyfish-client-sdk to connect to JF. After the connection has been established, the User can send and receive media. "},{"title":"Authentication","type":0,"sectionRef":"#","url":"/jellyfish-docs/getting_started/authentication","content":"Authentication The Authentication mechanism is based on a bearer token. How does it work? Both Jellyfish and Business Logic are configured with the same secret. This secret is used for authorizing HTTP requests between them (via HTTP authorization request header). When a new client wants to join a room, Business Logic (assuming the client is authorized to join) requests adding a new peer and receives a token generated by Jellyfish. The token must then be passed to the client, that will use it to connect to the room as a new peer. The token encodes both peer and room IDs. The token exchange is handled by our Client SDKs when connecting. Under the hood, Jellyfish expects the token in the first message after opening the Web Socket connection. Token encodes peer id and room id. Run Jellyfish JF_SERVER_API_TOKEN=JF_SERVER_API_TOKEN mix phx.server Create a room and add one peer Business Logic client = Jellyfish.Client.new(&quot;http://address-of-your-server.com&quot;, &quot;JF_SERVER_API_TOKEN&quot;) {:ok, room, _jellyfish_address} = Jellyfish.Room.create(client, max_peers: 10) {:ok, peer, peer_token} = Jellyfish.Room.add_peer(client, room.id, &quot;BobId&quot;) Connect as a peer to Jellyfish Client client.connect({ token: peerToken, peerMetadata: { name: &quot;Bob&quot; }, isSimulcastOn: false }) ","keywords":""},{"title":"HLS","type":0,"sectionRef":"#","url":"/jellyfish-docs/getting_started/components/hls","content":"","keywords":""},{"title":"Compatibility​","type":1,"pageTitle":"HLS","url":"/jellyfish-docs/getting_started/components/hls#compatibility","content":"WebRTCRTSP "},{"title":"Requirements​","type":1,"pageTitle":"HLS","url":"/jellyfish-docs/getting_started/components/hls#requirements","content":"The Room in which the HLS component is created must have the video codec set to H264. See API for more information.Max 1 HLS component allowed per room. "},{"title":"Configuration options​","type":1,"pageTitle":"HLS","url":"/jellyfish-docs/getting_started/components/hls#configuration-options","content":"Optional lowLatency (boolean, default: false) - whether the component should use LL-HLS "},{"title":"Env variables​","type":1,"pageTitle":"HLS","url":"/jellyfish-docs/getting_started/components/hls#env-variables","content":"Currently, there are no environment variables related to this component. "},{"title":"Output​","type":1,"pageTitle":"HLS","url":"/jellyfish-docs/getting_started/components/hls#output","content":"After adding a WebRTC peer (and at least one track) or an RTSP component, the HLS stream will be available under http://&lt;jellyfish-address&gt;/hls/&lt;room_id&gt;/index.m3u8 (or https://, if using TLS). "},{"title":"Example Docker commands​","type":1,"pageTitle":"HLS","url":"/jellyfish-docs/getting_started/components/hls#example-docker-commands","content":"The HLS playlist will be created inside the Docker container. To access it from the host, you need to create a volume, e.g. by adding the option -v $(pwd)/jellyfish_output:/app/jellyfish_outputto your Docker command. Other than that, your Docker commands shouldn't be affected by adding this component. docker run -p 8080:8080/tcp \\ -e JF_SERVER_API_TOKEN=token \\ -e JF_HOST=localhost:8080 \\ -v $(pwd)/jellyfish_output:/app/jellyfish_output \\ ghcr.io/jellyfish-dev/jellyfish:0.2.0  "},{"title":"RTSP","type":0,"sectionRef":"#","url":"/jellyfish-docs/getting_started/components/rtsp","content":"","keywords":""},{"title":"Compatibility​","type":1,"pageTitle":"RTSP","url":"/jellyfish-docs/getting_started/components/rtsp#compatibility","content":"WebRTCHLS "},{"title":"Requirements​","type":1,"pageTitle":"RTSP","url":"/jellyfish-docs/getting_started/components/rtsp#requirements","content":"RTSP component always outputs H264 stream so if the Room in which the RTSP component is created enforces a video codec, it must be set to H264. See API for more information. "},{"title":"Configuration options​","type":1,"pageTitle":"RTSP","url":"/jellyfish-docs/getting_started/components/rtsp#configuration-options","content":"Required sourceUri (string) - URI of RTSP source stream, e.g. &quot;rtsp://mysite.net:554/stream&quot; Optional rtpPort (integer 1..65535, default: 20000) - Local port RTP stream will be received atreconnectDelay (integer 0.., default: 15000) - Delay (in ms) between successive reconnect attemptskeepAliveInterval (integer 0.., default: 15000) - Interval (in ms) in which keep-alive RTSP messages will be sent to the remote stream sourcepierceNat (boolean, default: true) - Whether to attempt to create client-side NAT binding by sending an empty datagram from client to source, after the completion of RTSP setup "},{"title":"Env variables​","type":1,"pageTitle":"RTSP","url":"/jellyfish-docs/getting_started/components/rtsp#env-variables","content":"Currently, there are no environment variables related to this component. "},{"title":"Example Docker commands​","type":1,"pageTitle":"RTSP","url":"/jellyfish-docs/getting_started/components/rtsp#example-docker-commands","content":"caution If the client is behind NAT, the option --network=host is necessary since Docker can change the source port of UDP packets for routing reasons, which breaks the pierceNat functionality. This means that users on macOS will most likely be unable to access any RTSP stream source outside of their network when running Jellyfish using Docker. If you're on macOS and want to receive RTSP streams from behind NAT, right now the only way is to build Jellyfish natively from source. Explicit port exposure (macOS compatible) docker run -p 20000:20000/udp \\ -p 8080:8080/tcp \\ -e JF_SERVER_API_TOKEN=token \\ -e JF_HOST=localhost:8080 \\ ghcr.io/jellyfish-dev/jellyfish:0.2.0  caution Make sure that the exposed UDP port matches the one used by the RTSP component (option rtpPort, default: 20000). If using multiple RTSP components, more ports will need to be exposed. Using host network (Linux only) docker run --network=host \\ -e JF_SERVER_API_TOKEN=token \\ -e JF_HOST=localhost:8080 \\ ghcr.io/jellyfish-dev/jellyfish:0.2.0  "},{"title":"Installation","type":0,"sectionRef":"#","url":"/jellyfish-docs/getting_started/installation","content":"","keywords":""},{"title":"Building from source​","type":1,"pageTitle":"Installation","url":"/jellyfish-docs/getting_started/installation#building-from-source","content":"Make sure to have both Elixir and Rust installed. Check the links below for instructions: ElixirRust Clone the Jellyfish repo git clone https://github.com/jellyfish-dev/jellyfish.git  Install native dependencies macOS IntelmacOS Apple SiliconUbuntu These instructions assume you have Homebrew installed. You can get it here. brew install srtp libnice clang-format ffmpeg opus pkg-config export LDFLAGS=&quot;-L/usr/local/opt/openssl@1.1/lib&quot; export CFLAGS=&quot;-I/usr/local/opt/openssl@1.1/include/&quot; export CPPFLAGS=&quot;-I/usr/local/opt/openssl@1.1/include/&quot; export PKG_CONFIG_PATH=&quot;/usr/local/opt/openssl@1.1/lib/pkgconfig&quot;  Install elixir dependencies mix deps.get  Run the server in development mix phx.server  Create a binary You can also create Jellyfish binary with: MIX_ENV=prod mix release  Then follow instructions printed in your terminal. info The difference between running with mix phx.server and generating target binary is that the latter is prepared for running in production so e.g. it includes some Erlang Virtual Machine tweaks. Jellyfish Dockerfile always uses mix release under the hood. "},{"title":"Running with Docker​","type":1,"pageTitle":"Installation","url":"/jellyfish-docs/getting_started/installation#running-with-docker","content":"Docker images are built for production which means that you always need to set a couple of environment variables. An example docker command running bare Jellyfish HTTP service locally: docker run -p 8080:8080/tcp -e JF_HOST=localhost:8080 JF_SERVER_API_TOKEN=token ghcr.io/jellyfish-dev/jellyfish:0.2.0  Note that in real case scenarios, docker commands depend on peers/components you are going to use. Therefore, we don't present them here but rather in each peer/component's documentation. As an example see WebRTC Peer. For the full list of Jellyfish Docker images, see this page. tip Instead of passing environmental variables manually, you can use the --env-file ./env-file flag, where the env-file is a file containing the variables that the image expects, see example file .env.sample in the Jellyfish repository. "},{"title":"Environment variables​","type":1,"pageTitle":"Installation","url":"/jellyfish-docs/getting_started/installation#environment-variables","content":"Environment variables are split into two groups: general ones - presented belowpeer/component-specific - each Peer and Component can expose its own environment variables. They are always listed in a Peer/Component description. See the list of Peers and Components. Below there are general, Jellyfish environment variables. If you are running Jellyfish in development, you don't need to set any of them. Required in production:​ JF_SERVER_API_TOKEN - token for authorizing HTTP requests. Defaults to development for development builds.JF_HOST - defines how Jellyfish should be seen from the outside. Defaults to JF_IP:JF_PORT. It can be in the form of ip:port, domain:port or simply domain. Useful when hosting Jellyfish behind proxy. It is returned e.g. when creating a new room. When running with Docker, JF_IP is set to 0.0.0.0making the default value of JF_HOST incorrect. Therefore, for Docker, you have to set JF_HOST manually. For running Docker locally, it can simply be localhost:8080. Optional:​ JF_IP - an ip address to run the HTTP server on. Defaults to 127.0.0.1 when running from source or using mix release, or 0.0.0.0 for Docker.JF_PORT - port to run the HTTP server on. Defaults to 5002 for development builds and 8080 for production builds (mix release or Docker).JF_SECRET_KEY_BASE - used to sign/encrypt tokens generated for Peers. Generated if not provided.JF_CHECK_ORIGIN - defines if Jellyfish will check the origin of incoming requests and socket connection. Defaults to true. Possible values are true, false or a space-separated list of allowed origins (wildcards are allowed). Example: JF_CHECK_ORIGIN=&quot;https://example.com //another.com:888 //*.other.com&quot;JF_OUTPUT_BASE_PATH - a base path where Jellyfish will save its artifacts. Defaults to ./jellyfish_output/. When running via docker, the directory can be mounted as -v $(pwd)/host_directory:/app/jellyfish_output.JF_METRICS_IP - an IP address to run metrics endpoint on. Defaults to 127.0.0.1 when running from source or using mix release, or 0.0.0.0 for Docker.JF_METRICS_PORT - a port to run metrics endpoint on. Defaults to 9568.MIX_ENV - defines compilation environment. This variable takes effect only when running from the source. Docker images are always built with MIX_ENV=prod. Possible values are: dev - uses default values for environment variables (default option when running with mix phx.server)prod - requires that you provide values for environment variablestest - used in tests Distribution:​ JF_DIST_ENABLED - whether to run Jellyfish in a cluster. Defaults to false.JF_DIST_NODE_NAME - Node name used in a cluster. It consists of two parts - nodename@hostname. The first part identifies a node on a single machine and can be any string. The second part identifies the host machine and has to be an ip address or FQDN of a machine Jellyfish runs on. If you run a cluster on a single machine or in the same docker network and you don't want to use IP addresses or FQDN as hostnames, you can use short names (see JF_DIST_MODE).JF_DIST_MODE - distribution mode - can be name or sname. Defaults to name. When using name, your hostname has to be an IP address or FQDN of a machine Jellyfish runs on. When using sname, your hostname can be any string. See our docker-compose.yaml, which we use in our integration tests for an example.JF_DIST_COOKIE - used to group Jellyfishes in a cluster. Defaults to jellyfish_cookie. Use different cookies to create multiple clusters on the same machine. Important: cookie does not provide any cryptographic security. Its only purpose is to prevent a node from connecting to a cluster with which it is not intended to communicate.JF_DIST_NODES - space-separated list of other Jellyfishes to connect to. Defaults to &quot;&quot;. Example: JF_DIST_NODES=&quot;jellyfish1@127.0.0.1 jellyfish2@127.0.0.1&quot;. This list can also include ourselves so that you can pass the same value to every Jellyfish. Note: Jellyfish connection to other Jellyfish is transitive meaning that when you connect to one Jellyfish you also connect to all other Jellyfishes this one was connected to.JF_DIST_MIN_PORT- minimal port used by Jellyfish when forming a cluster (connecting to other Jellyfishes). Defaults to 9000 when running with Docker. Only available when running with Docker or mix release.JF_DIST_MAX_PORT- maximal port used by Jellyfish when forming a cluster (connecting to other Jellyfishes). Defaults to 9000 when running with Docker. Only available when running with Docker or mix release. tip You can use a single port to form a cluster, even if a cluster consists of more than two Jellyfishes. caution Besides ports specified using JF_DIST_MIN_PORT and JF_DIST_MAX_PORT, Jellyfish also uses one more service called EPMD that runs on port 4369. This port has to be explicitly exported when running with Docker. Read more in the Cluster section. "},{"title":"Rest API","type":0,"sectionRef":"#","url":"/jellyfish-docs/for_developers/api_reference/rest_api","content":"Rest API hls getSend file recording getShows information about the roomdelDelete the recordinggetSend file room getShow information about all roomspostCreates a roomdelDelete the roomgetShows information about the roompostCreates the component and adds it to the roomdelDelete the component from the roompostCreate peerdelDelete peer API docs by Redocly Jellyfish Media Server (0.2.0) Download OpenAPI specification:Download License: Apache 2.0 hls Send file Authorizations: authorization path Parameters room_id required string Room id filename required string Name of the file query Parameters _HLS_msn integer or null (HlsMsn) &gt;= 0 Example: _HLS_msn=10 Segment sequence number _HLS_part integer or null (HlsPart) &gt;= 0 Example: _HLS_part=10 Partial segment sequence number _HLS_skip string or null (HlsSkip) Value: &quot;YES&quot; Example: _HLS_skip=YES Is delta manifest requested header Parameters range string Byte range of partial segment Responses 200 File was found 404 File not found get/hls/{room_id}/{filename} https://raw.githubusercontent.com/hls/{room_id}/{filename} Response samples 200404 Content type application/json Copy &quot;string&quot; recording Shows information about the room Authorizations: authorization Responses 200 Success 404 Unable to obtain recordings get/recording https://raw.githubusercontent.com/recording Response samples 200404 Content type application/json Copy Expand all Collapse all { &quot;data&quot;: [ &quot;string&quot; ] } Delete the recording Authorizations: authorization path Parameters recording_id required string Recording id Responses 204 Successfully deleted recording 404 Recording doesn't exist delete/recording/{recording_id} https://raw.githubusercontent.com/recording/{recording_id} Response samples 404 Content type application/json Copy { &quot;errors&quot;: &quot;Token has expired&quot; } Send file Authorizations: authorization path Parameters recording_id required string Recording id filename required string Name of the file Responses 200 File was found 404 File not found get/recording/{recording_id}/{filename} https://raw.githubusercontent.com/recording/{recording_id}/{filename} Response samples 200404 Content type application/json Copy &quot;string&quot; room Show information about all rooms Authorizations: authorization Responses 200 Success 401 Unauthorized get/room https://raw.githubusercontent.com/room Response samples 200401 Content type application/json Copy Expand all Collapse all { &quot;data&quot;: [ { &quot;components&quot;: [ { &quot;id&quot;: &quot;component-1&quot;, &quot;metadata&quot;: { &quot;lowLatency&quot;: true, &quot;persistent&quot;: true, &quot;playable&quot;: true, &quot;targetWindowDuration&quot;: 0 }, &quot;type&quot;: &quot;hls&quot; } ], &quot;config&quot;: { &quot;maxPeers&quot;: 10, &quot;videoCodec&quot;: &quot;h264&quot;, &quot;webhookUrl&quot;: &quot;https://backend.address.com/jellyfish-notifications-endpoint&quot; }, &quot;id&quot;: &quot;room-1&quot;, &quot;peers&quot;: [ { &quot;id&quot;: &quot;peer-1&quot;, &quot;status&quot;: &quot;disconnected&quot;, &quot;type&quot;: &quot;webrtc&quot; } ] } ] } Creates a room Authorizations: authorization Request Body schema: application/json Room configuration maxPeers integer or null &gt;= 1 Maximum amount of peers allowed into the room videoCodec string or null Enum: &quot;h264&quot; &quot;vp8&quot; Enforces video codec for each peer in the room webhookUrl string or null URL where Jellyfish notifications will be sent Responses 201 Room successfully created 400 Invalid request structure 401 Unauthorized post/room https://raw.githubusercontent.com/room Request samples Payload Content type application/json Copy { &quot;maxPeers&quot;: 10, &quot;videoCodec&quot;: &quot;h264&quot;, &quot;webhookUrl&quot;: &quot;https://backend.address.com/jellyfish-notifications-endpoint&quot; } Response samples 201400401 Content type application/json Copy Expand all Collapse all { &quot;data&quot;: { &quot;jellyfish_address&quot;: &quot;jellyfish1:5003&quot;, &quot;room&quot;: { &quot;components&quot;: [ { &quot;id&quot;: &quot;component-1&quot;, &quot;metadata&quot;: { &quot;lowLatency&quot;: true, &quot;persistent&quot;: true, &quot;playable&quot;: true, &quot;targetWindowDuration&quot;: 0 }, &quot;type&quot;: &quot;hls&quot; } ], &quot;config&quot;: { &quot;maxPeers&quot;: 10, &quot;videoCodec&quot;: &quot;h264&quot;, &quot;webhookUrl&quot;: &quot;https://backend.address.com/jellyfish-notifications-endpoint&quot; }, &quot;id&quot;: &quot;room-1&quot;, &quot;peers&quot;: [ { &quot;id&quot;: &quot;peer-1&quot;, &quot;status&quot;: &quot;disconnected&quot;, &quot;type&quot;: &quot;webrtc&quot; } ] } } } Delete the room Authorizations: authorization path Parameters room_id required string Room id Responses 204 Successfully deleted room 401 Unauthorized 404 Room doesn't exist delete/room/{room_id} https://raw.githubusercontent.com/room/{room_id} Response samples 401404 Content type application/json Copy { &quot;errors&quot;: &quot;Token has expired&quot; } Shows information about the room Authorizations: authorization path Parameters room_id required string Room ID Responses 200 Success 401 Unauthorized 404 Room doesn't exist get/room/{room_id} https://raw.githubusercontent.com/room/{room_id} Response samples 200401404 Content type application/json Copy Expand all Collapse all { &quot;data&quot;: { &quot;components&quot;: [ { &quot;id&quot;: &quot;component-1&quot;, &quot;metadata&quot;: { &quot;lowLatency&quot;: true, &quot;persistent&quot;: true, &quot;playable&quot;: true, &quot;targetWindowDuration&quot;: 0 }, &quot;type&quot;: &quot;hls&quot; } ], &quot;config&quot;: { &quot;maxPeers&quot;: 10, &quot;videoCodec&quot;: &quot;h264&quot;, &quot;webhookUrl&quot;: &quot;https://backend.address.com/jellyfish-notifications-endpoint&quot; }, &quot;id&quot;: &quot;room-1&quot;, &quot;peers&quot;: [ { &quot;id&quot;: &quot;peer-1&quot;, &quot;status&quot;: &quot;disconnected&quot;, &quot;type&quot;: &quot;webrtc&quot; } ] } } Creates the component and adds it to the room Authorizations: authorization path Parameters room_id required string Room ID Request Body schema: application/json Component config options ComponentOptionsHLS (object) or ComponentOptionsRTSP (object) (ComponentOptions) Component-specific options type required string (ComponentType) Component type Responses 201 Successfully added component 400 Invalid request 401 Unauthorized 404 Room doesn't exist post/room/{room_id}/component https://raw.githubusercontent.com/room/{room_id}/component Request samples Payload Content type application/json Copy Expand all Collapse all { &quot;options&quot;: { &quot;lowLatency&quot;: false, &quot;persistent&quot;: false, &quot;targetWindowDuration&quot;: 0 }, &quot;type&quot;: &quot;hls&quot; } Response samples 201400401404 Content type application/json Copy Expand all Collapse all { &quot;data&quot;: { &quot;id&quot;: &quot;component-1&quot;, &quot;metadata&quot;: { &quot;lowLatency&quot;: true, &quot;persistent&quot;: true, &quot;playable&quot;: true, &quot;targetWindowDuration&quot;: 0 }, &quot;type&quot;: &quot;hls&quot; } } Delete the component from the room Authorizations: authorization path Parameters room_id required string Room ID id required string Component ID Responses 204 Successfully deleted 401 Unauthorized 404 Either component or the room doesn't exist delete/room/{room_id}/component/{id} https://raw.githubusercontent.com/room/{room_id}/component/{id} Response samples 401404 Content type application/json Copy { &quot;errors&quot;: &quot;Token has expired&quot; } Create peer Authorizations: authorization path Parameters room_id required string Room id Request Body schema: application/json Peer specification options required PeerOptionsWebRTC (object) (PeerOptions) Peer-specific options type required string (PeerType) Peer type Responses 201 Peer successfully created 400 Invalid request body structure 401 Unauthorized 404 Room doesn't exist 503 Peer limit has been reached post/room/{room_id}/peer https://raw.githubusercontent.com/room/{room_id}/peer Request samples Payload Content type application/json Copy Expand all Collapse all { &quot;options&quot;: { &quot;enableSimulcast&quot;: true }, &quot;type&quot;: &quot;webrtc&quot; } Response samples 201400401404503 Content type application/json Copy Expand all Collapse all { &quot;data&quot;: { &quot;peer&quot;: { &quot;id&quot;: &quot;peer-1&quot;, &quot;status&quot;: &quot;disconnected&quot;, &quot;type&quot;: &quot;webrtc&quot; }, &quot;token&quot;: &quot;5cdac726-57a3-4ecb-b1d5-72a3d62ec242&quot; } } Delete peer Authorizations: authorization path Parameters room_id required string Room ID id required string Peer id Responses 204 Peer successfully deleted 401 Unauthorized 404 Room ID or Peer ID references a resource that doesn't exist delete/room/{room_id}/peer/{id} https://raw.githubusercontent.com/room/{room_id}/peer/{id} Response samples 401404 Content type application/json Copy { &quot;errors&quot;: &quot;Token has expired&quot; }","keywords":""},{"title":"Metrics","type":0,"sectionRef":"#","url":"/jellyfish-docs/getting_started/metrics","content":"Metrics Jellyfish exports several metrics in the Prometheus format. By default, they are available on port 9568 at /metrics. See JF_METRICS_IP and JF_METRICS_PORT for configuration options. Name\tLabels\tDescriptionjellyfish_traffic_ingress_total_bytes Total traffic received jellyfish_traffic_ingress_throughput_bytes_per_second Current throughput for received traffic jellyfish_traffic_egress_total_bytes Total traffic sent jellyfish_traffic_egress_throughput_bytes_per_second Current throughput for sent traffic jellyfish_rooms Amount of rooms currently present in Jellyfish jellyfish_room_peers\troom_id\tAmount of peers currently present in a given room jellyfish_room_peer_time_total_seconds\troom_id\tTotal peer time accumulated for a given room vm_memory_total_bytes Total memory used by Erlang Virtual Machine vm_total_run_queue_lengths_total Number of Erlang processes waiting to be executed vm_total_run_queue_lengths_cpu Number of Erlang processes waiting to be executed on CPU schedulers vm_total_run_queue_lengths_io Number of Erlang processes waiting to be executed on IO schedulers","keywords":""},{"title":"Notifications","type":0,"sectionRef":"#","url":"/jellyfish-docs/getting_started/notifications","content":"Notifications Jellyfish sends server side notifications whenever some important event occurs, e.g.: a room has been createdsome peer has connectedcomponent has crashedetc. A full list of available notifications is always present in specific server SDK documentation. Here, we present how you can subscribe for server side notifications using Elixir Server SDK: server_address = &quot;localhost:5002&quot; server_api_token = &quot;development&quot; {:ok, notifier} = Jellyfish.Notifier.start(server_address: server_address, server_api_token: server_api_token) :ok = Jellyfish.Notifier.subscribe_server_notifications(notifier) :ok = Jellyfish.Notifier.subscribe_metrics(notifier) As a result, you should see the following logs on the server side 07:45:02.684 [info] New incoming server WebSocket connection, accepting 07:45:02.688 [info] Server WS authenticated. ","keywords":""},{"title":"WebRTC","type":0,"sectionRef":"#","url":"/jellyfish-docs/getting_started/peers/webrtc","content":"","keywords":""},{"title":"Compatibility​","type":1,"pageTitle":"WebRTC","url":"/jellyfish-docs/getting_started/peers/webrtc#compatibility","content":"HLSRTSP "},{"title":"Configuration options​","type":1,"pageTitle":"WebRTC","url":"/jellyfish-docs/getting_started/peers/webrtc#configuration-options","content":"Optional enableSimulcast (boolean, default: true) - Enables the peer to use simulcast "},{"title":"Env variables​","type":1,"pageTitle":"WebRTC","url":"/jellyfish-docs/getting_started/peers/webrtc#env-variables","content":"JF_WEBRTC_USED - has to be true if WebRTC peers will be usedJF_WEBRTC_TURN_LISTEN_IP - the IP address on which TURN servers will listen. By default set to 127.0.0.1. When running Jellyfish via Docker, this MUST be set to 0.0.0.0, even for local tests.JF_WEBRTC_TURN_IP - the IP address, under which TURN will present itself to the clients. By default set to 127.0.0.1. When running Jellyfish via Docker, this MUST be set to real (non-loopback) address, even for local tests.JF_WEBRTC_TURN_PORT_RANGE - port range, where UDP TURN will try to open ports. By default set to 50000-59999. The bigger the range is, the more users server will be able to handle. Useful when not using the --network=host option to limit the UDP ports used only to ones published from a Docker container.JF_WEBRTC_TURN_TCP_PORT - port number of TCP TURN "},{"title":"Example Docker commands​","type":1,"pageTitle":"WebRTC","url":"/jellyfish-docs/getting_started/peers/webrtc#example-docker-commands","content":"Explicit port exposure (macOS compatible) docker run -p 50000-50050:50000-50050/udp \\ -p 8080:8080/tcp \\ -e JF_SERVER_API_TOKEN=token \\ -e JF_HOST=localhost:8080 \\ -e JF_WEBRTC_USED=true \\ -e JF_WEBRTC_TURN_PORT_RANGE=50000-50050 \\ -e JF_WEBRTC_TURN_IP=192.168.0.1 \\ -e JF_WEBRTC_TURN_LISTEN_IP=0.0.0.0 \\ ghcr.io/jellyfish-dev/jellyfish:0.2.0  caution Make sure that the exposed UDP ports match JF_WEBRTC_TURN_PORT_RANGE. The range of the ports shouldn't be too wide as it might cause problems with container startup. Using host network (Linux only) docker run --network=host \\ -e JF_SERVER_API_TOKEN=token \\ -e JF_HOST=localhost:8080 \\ -e JF_WEBRTC_USED=true \\ -e JF_WEBRTC_TURN_IP=192.168.0.1 \\ -e JF_WEBRTC_TURN_LISTEN_IP=0.0.0.0 \\ ghcr.io/jellyfish-dev/jellyfish:0.2.0  "},{"title":"SDKs","type":0,"sectionRef":"#","url":"/jellyfish-docs/getting_started/sdks","content":"","keywords":""},{"title":"Server SDKs​","type":1,"pageTitle":"SDKs","url":"/jellyfish-docs/getting_started/sdks#server-sdks","content":"SDK\tResourcesElixir\tCode examples RTSP to HLS conversion Python\t "},{"title":"Client SDKs​","type":1,"pageTitle":"SDKs","url":"/jellyfish-docs/getting_started/sdks#client-sdks","content":"SDK\tResourcesReact\tReact Minimal Working Example Guide Jellyfish Videoroom Code examples TypeScript\tCode examples IOS\tCode example Android\tCode example React Native\tCode example "},{"title":"Basic Concepts","type":0,"sectionRef":"#","url":"/jellyfish-docs/introduction/basic_concepts","content":"","keywords":""},{"title":"Room​","type":1,"pageTitle":"Basic Concepts","url":"/jellyfish-docs/introduction/basic_concepts#room","content":"In Jellyfish, a room serves as a holder for peers and components, its function varying based on application. For instance, within a video conferencing system, a Jellyfish room represents a single online meeting or a channel accommodating multiple users for conversation. On the other hand, in a broadcasting system setting, one room will be a container for two components - one responsible for receiving stream from a streaming host (e.g. via RTMP) and the other one responsible for converting this stream into an HLS playlist ready to be broadcasted via CDN. "},{"title":"Component​","type":1,"pageTitle":"Basic Concepts","url":"/jellyfish-docs/introduction/basic_concepts#component","content":"A component is a server-side process that publishes or subscribes to tracks. Example components are: HLS component - subscribes to all other tracks and creates from them an HLS playlist ready to be broadcasted via CDNRTSP component - connects to the remote media source (e.g. an IP camera) and publishes its media to be consumed by other components or peers "},{"title":"Peer​","type":1,"pageTitle":"Basic Concepts","url":"/jellyfish-docs/introduction/basic_concepts#peer","content":"A peer is a client-side entity that connects to the server to publish, subscribe or publish and subscribe to tracks published by components or other peers. The peer's process is spawned after the peer connects to the server. At the moment, there is only one type of peer - WebRTC. "},{"title":"Difference between Component and Peer​","type":1,"pageTitle":"Basic Concepts","url":"/jellyfish-docs/introduction/basic_concepts#difference-between-component-and-peer","content":"The most important difference between a component and a peer is that component is a purely server-side thing. It starts its work right after adding it to the server. On the other hand, a peer is something that has to connect to the server. Therefore, peers are allowed to open so-called signaling channels to the server. See also Example Scenarios. "},{"title":"Example Scenarios","type":0,"sectionRef":"#","url":"/jellyfish-docs/introduction/example_scenarios","content":"","keywords":""},{"title":"Real-time video conferencing system​","type":1,"pageTitle":"Example Scenarios","url":"/jellyfish-docs/introduction/example_scenarios#real-time-video-conferencing-system","content":"In this scenario, we want to create a simple video conferencing system where people can talk to each other in the real-time. Because of interactive and real-time requirements, the natural choice is to use the WebRTC standard. The final architecture would look like this:   "},{"title":"Broadcasting system with the real-time mixin​","type":1,"pageTitle":"Example Scenarios","url":"/jellyfish-docs/introduction/example_scenarios#broadcasting-system-with-the-real-time-mixin","content":"In this scenario, we want to create a broadcasting solution where the conversation between multiple people is broadcasted to the broader audience. Here, we choose WebRTC as a standard used for connecting people talking to each other in real-time and HLS for creating a playlist that can be then uploaded to CDN and broadcasted to the broader audience. As you can see, the whole system will automatically adapt to the number of participants talking in real-time. In particular, Jellyfish will handle a scenario with only one streamer out of the box.   "},{"title":"Displaying IP camera streams in a web browser​","type":1,"pageTitle":"Example Scenarios","url":"/jellyfish-docs/introduction/example_scenarios#displaying-ip-camera-streams-in-a-web-browser","content":"In this scenario, we have a set of IP cameras and we want to display their streams in a web browser. IP cameras very often use RTSP for streaming media but browsers don't ship with support for this protocol. Therefore, to display audio and video in a web browser, we have to use either WebRTC or HLS. Because, in this scenario, the delay is not the most crucial thing, we choose HLS. The most important thing here is that the RTSP component connects to the IP camera and then the camera starts streaming. It's not the camera that initializes the connection to the server. Therefore, the RTSP component is a purely server-side thing - once you add it, it should be able to work on its own.   "},{"title":"The Whats and Hows of Jellyfish Dashboard","type":0,"sectionRef":"#","url":"/jellyfish-docs/tutorials/dashboard","content":"","keywords":""},{"title":"What is Jellyfish Dashboard?​","type":1,"pageTitle":"The Whats and Hows of Jellyfish Dashboard","url":"/jellyfish-docs/tutorials/dashboard#what-is-jellyfish-dashboard","content":"Jellyfish Dashboard is a web application that allows you to manage your Jellyfish Media Server instance. It is a React application that uses the Jellyfish React Client APIfor adding and receiving tracks and Jellyfish Server APIfor adding peers, creating rooms etc. It was created to help Jellyfish developers in testing but was later extended and adapted as a tool for tutorials and demos. Here, we present a short introduction to the dashboard and its features. "},{"title":"How to start Jellyfish Dashboard?​","type":1,"pageTitle":"The Whats and Hows of Jellyfish Dashboard","url":"/jellyfish-docs/tutorials/dashboard#how-to-start-jellyfish-dashboard","content":"There are a couple of ways to start the dashboard: Up-to-date versionDocker containerOfficial repository The current version of the dashboard is ready to use and availablehere. Ensure that it is compatible with your Jellyfish server! Please note that this dashboard only supports secure connections (https/wss) or connections to localhost. Any insecure requests (http/ws) will be automatically blocked by the browser. "},{"title":"How to start Jellyfish Media Server?​","type":1,"pageTitle":"The Whats and Hows of Jellyfish Dashboard","url":"/jellyfish-docs/tutorials/dashboard#how-to-start-jellyfish-media-server","content":"For testing, we'll run the Jellyfish Media Server locally using Docker image: docker run -p 50000-50050:50000-50050/udp \\ -p 5002:5002/tcp \\ -e JF_CHECK_ORIGIN=false \\ -e JF_HOST=&lt;your ip address&gt;:5002 \\ -e JF_PORT=&quot;5002&quot; \\ -e JF_WEBRTC_USED=true \\ -e JF_WEBRTC_TURN_PORT_RANGE=50000-50050 \\ -e JF_WEBRTC_TURN_IP=&lt;your ip address&gt; \\ -e JF_WEBRTC_TURN_LISTEN_IP=0.0.0.0 \\ -e JF_SERVER_API_TOKEN=development \\ ghcr.io/jellyfish-dev/jellyfish:0.2.0  Make sure to set JF_WEBRTC_TURN_IP and JF_HOST to your local IP address. Without it, the mobile device won't be able to connect to the Jellyfish. tip To check your local IP you can use this handy command (Linux/macOS): ifconfig | grep &quot;inet &quot; | grep -Fv 127.0.0.1 | awk '{print $2}'  "},{"title":"How to use Jellyfish Dashboard?​","type":1,"pageTitle":"The Whats and Hows of Jellyfish Dashboard","url":"/jellyfish-docs/tutorials/dashboard#how-to-use-jellyfish-dashboard","content":"Since we have Dashboard and Jellyfish Media Server up and running, we can dive into the features. "},{"title":"Connecting to the server​","type":1,"pageTitle":"The Whats and Hows of Jellyfish Dashboard","url":"/jellyfish-docs/tutorials/dashboard#connecting-to-the-server","content":"We started the dashboard and the Jellyfish Media Server separately, so we need to connect them. Open the dashboard in your browser. Open the side menu and fill in the parameters:  Server token - a token necessary to authenticate the dashboard with the Jellyfish. For now, it's simply development, but it is meant to authenticate the dashboard to the Jellyfish, so the good practice is to use a token that is hard to guess.WS/WSS - whether to use a secure or insecure connection. , it's ws, but if the Jellyfish uses secure WebSocket, use wss.HTTP/HTTPS - whether to use a secure or insecure connection. By default, it's http, but if the Jellyfish uses secure HTTP, use https.Server URL - URL of the Jellyfish server. Here, localhost:5002 would be a local build, but it can be any URL that points to the Jellyfish.Socket Path - path to the WebSocket endpoint. The default value is /socket/peer/websocket. Click Connect to server. If everything is correct, a server will appear in the list of connected servers:  "},{"title":"Creating a room​","type":1,"pageTitle":"The Whats and Hows of Jellyfish Dashboard","url":"/jellyfish-docs/tutorials/dashboard#creating-a-room","content":"There are plenty of settings that You can adjust in a room:  h264 or vp8 - video codec used in the room. If you want to use HLS streaming, you need to use h264.Max Peers - maximum number of peers that can join to the room. When you select the settings, click the Add room button. If everything is correct, a room will appear in the list of rooms:  "},{"title":"Adding and connecting peers to the room​","type":1,"pageTitle":"The Whats and Hows of Jellyfish Dashboard","url":"/jellyfish-docs/tutorials/dashboard#adding-and-connecting-peers-to-the-room","content":"Using the Create peer button, you can create a peer that will be ready to connect to the room.  The peer has its ID and Token. The ID is used to identify the peer in the Jellyfish Server, and the Token is used to authenticate the peer with the Jellyfish Server. Dashboard has an option to copy both of those values to the clipboard. You can also create a QR code with the peer's Token to make connecting to Jellyfish with a mobile device easier.  To connect the peer to the room, you can either press the Connect button in the peer's row, or scan the QR code with your mobile app, and connect there. "},{"title":"Sending tracks​","type":1,"pageTitle":"The Whats and Hows of Jellyfish Dashboard","url":"/jellyfish-docs/tutorials/dashboard#sending-tracks","content":"When the peer connects to the room, you will see the track menu. It allows you to send tracks to the room.  You can select the audio or video track you want to create. Created tracks will be visible in the list below. You can select any track from the list and send it to the room. Apart from your camera/microphone, you can easily share your screen with its audio or pick one from a list of mock tracks that we prepared. You can also select the resolution of the video track or if you want, send the video as a simulcast stream. There is also an option to add custom metadata (in JSON format) to the track. The peer will send metadata with the track to the room. Each recipient will be able to see it. When you select the track, click the Add track button. If everything is correct, client will send the track to the room and other peers will be able to see and hear you. "},{"title":"Receiving tracks​","type":1,"pageTitle":"The Whats and Hows of Jellyfish Dashboard","url":"/jellyfish-docs/tutorials/dashboard#receiving-tracks","content":"When the peer connects to the room, it will automatically receive tracks from other peers. Congrats! The basic utils of the dashboard are now covered. Next, we will dive into useful features that will help you with testing. "},{"title":"A ton of information that the dashboard provides​","type":1,"pageTitle":"The Whats and Hows of Jellyfish Dashboard","url":"/jellyfish-docs/tutorials/dashboard#a-ton-of-information-that-the-dashboard-provides","content":""},{"title":"Server logs in console​","type":1,"pageTitle":"The Whats and Hows of Jellyfish Dashboard","url":"/jellyfish-docs/tutorials/dashboard#server-logs-in-console","content":"On the side menu, you can set up the dashboard to display React Client logs in the console. Logs are great for debugging purposes and provide insight into the various communications that occur between the dashboard and the Jellyfish Server. You can also register your event handlers in your Jellyfish-based projects, both in theReact Client SDK and theTS Client SDK. These logs can show you when particular events occur and provide data that you can use in your own handlers  "},{"title":"Server/Room/Client state​","type":1,"pageTitle":"The Whats and Hows of Jellyfish Dashboard","url":"/jellyfish-docs/tutorials/dashboard#serverroomclient-state","content":"Each server, room, and client has its state. You can see the state of each of them in the dashboard by clicking appropriate buttons.  "},{"title":"Server events​","type":1,"pageTitle":"The Whats and Hows of Jellyfish Dashboard","url":"/jellyfish-docs/tutorials/dashboard#server-events","content":"Apart from the state, you can also see the events that occur on the server. You can see them after clicking the Show Server Events button.  "},{"title":"HLS and RTSP streaming​","type":1,"pageTitle":"The Whats and Hows of Jellyfish Dashboard","url":"/jellyfish-docs/tutorials/dashboard#hls-and-rtsp-streaming","content":"The dashboard allows adding HLS and RTSP streams in the room. You can set up the streams and see them in the room. It will look like this:  "},{"title":"Loadbalancing in Dashboard​","type":1,"pageTitle":"The Whats and Hows of Jellyfish Dashboard","url":"/jellyfish-docs/tutorials/dashboard#loadbalancing-in-dashboard","content":"Jellyfish Server supports load balancing. This means you can run multiple instances of the server and use them simultaneously to distribute the load evenly among them. The dashboard reflects this feature. If you run multiple Jellyfish instances (which Docker Compose does by default), connect one server to the dashboard. When a server opens a room on a different instance, the Dashboard will automatically connect to it and display the room. When Jellyfish runs in a cluster, and the Dashboard requests a new room, it's created on the Jellyfish instance with the lowest load. Information about the specific Jellyfish instance that hosts the newly created room is returned in the HTTP response body. "},{"title":"Data collected by Jellyfish​","type":1,"pageTitle":"The Whats and Hows of Jellyfish Dashboard","url":"/jellyfish-docs/tutorials/dashboard#data-collected-by-jellyfish","content":"For each server, Jellyfish collects WebRTC statistics about the rooms, clients and streamed tracks. You can see them in the dashboard using the Internals button.  The button opens a new tab with the panel to connect to the WebSocket of the Jellyfish of choice. You can observe the data with the dynamically generated charts showing what flows through the Jellyfish.  "},{"title":"Summary​","type":1,"pageTitle":"The Whats and Hows of Jellyfish Dashboard","url":"/jellyfish-docs/tutorials/dashboard#summary","content":"Congrats on finishing the tutorial! You should now be able to use the dashboard to its full potential. But this was just the beginning. Jellyfish Client API is a powerful tool that allows you to create your own web or mobile multimedia application. Check out the other tutorials to learn more about the Jellyfish Client API and how to use it in your projects. You can also take a look at our fully featured Videoroom Demo example:  It's written in React Native, but it uses the same Jellyfish Client API as the dashboard, so you can learn a lot from it. "},{"title":"React Native Minimal Working Example","type":0,"sectionRef":"#","url":"/jellyfish-docs/tutorials/react-native","content":"","keywords":""},{"title":"What you'll learn​","type":1,"pageTitle":"React Native Minimal Working Example","url":"/jellyfish-docs/tutorials/react-native#what-youll-learn","content":"This tutorial will guide you through creating your first React Native / Expo project which uses Jellyfish client. By the end of the tutorial, you'll have a working application that connects to an instance of Jellyfish Server using WebRTC and streams and receives camera tracks.  You can check out the finished project here. "},{"title":"What do you need​","type":1,"pageTitle":"React Native Minimal Working Example","url":"/jellyfish-docs/tutorials/react-native#what-do-you-need","content":"a little bit of experience in creating apps with React Native and/or Expo - refer to the React Native Guide or Expo Guide to learn more "},{"title":"Jellyfish architecture​","type":1,"pageTitle":"React Native Minimal Working Example","url":"/jellyfish-docs/tutorials/react-native#jellyfish-architecture","content":"info You can learn more about Jellyfish architecture in Jellyfish docs. This section provides a brief description aimed at front-end developers Let's introduce some concepts first: Peer - A peer is a client-side entity that connects to the server to publish, subscribe or publish and subscribe to tracks published by components or other peers. You can think of it as a participant in a room. At the moment, there is only one type of peer - WebRTC.Track - An object that represents an audio or video stream. A track can be associated with a local media source, such as a camera or microphone, or a remote media source received from another user. Tracks are used to capture, transmit, and receive audio and video data in WebRTC applications.Room - In Jellyfish, a room serves as a holder for peers and components, its function varying based on application. From a front-end perspective, this will be probably one meeting or a broadcast. For a better understanding of these concepts here is an example of a room that holds a standard WebRTC conference from a perspective of the User:  In this example, peers stream multiple video and audio tracks. Peer #1 streams even two video tracks (camera and screencast track). You can differentiate between them by using track metadata. The user gets info about peers and their tracks from the server using Jellyfish Client. The user is also informed in real time about peers joining/leaving and tracks being added/removed. To keep this tutorial short we'll simplify things a little. Every peer will stream just one video track. "},{"title":"Connecting and joining the room​","type":1,"pageTitle":"React Native Minimal Working Example","url":"/jellyfish-docs/tutorials/react-native#connecting-and-joining-the-room","content":"The general flow of connecting to the server and joining the room in a standard WebRTC conference setup looks like this:  The parts that you need to implement are marked in blue and things handled by Jellyfish are marked in red. Firstly, the user logs in. Then your backend authenticates the user and obtains a peer token. It allows the user to authenticate and join the room in Jellyfish Server. The backend passes the token to your front-end, and your front-end passes it to Jellyfish Client. The client establishes the connection with Jellyfish Server. Then Jellyfish Client sets up tracks (camera, microphone) to stream and joins the room on Jellyfish Server. Finally, your front-end can display the room for the user. For this tutorial we simplified this process a bit - you don't have to implement a backend or authentication. Jellyfish Dashboard will do this for you. It's also a nice tool to test and play around with Jellyfish. The flow with Jellyfish The dashboard looks like this:  You can see that the only things you need to implement are interactions with the user and Jellyfish Client. This tutorial will show you how to do it. "},{"title":"Setup​","type":1,"pageTitle":"React Native Minimal Working Example","url":"/jellyfish-docs/tutorials/react-native#setup","content":""},{"title":"Start the Jellyfish Dashboard​","type":1,"pageTitle":"React Native Minimal Working Example","url":"/jellyfish-docs/tutorials/react-native#start-the-jellyfish-dashboard","content":"For testing, we'll run the Jellyfish Media Server locally using Docker image: docker run -p 50000-50050:50000-50050/udp \\ -p 5002:5002/tcp \\ -e JF_CHECK_ORIGIN=false \\ -e JF_HOST=&lt;your ip address&gt;:5002 \\ -e JF_PORT=&quot;5002&quot; \\ -e JF_WEBRTC_USED=true \\ -e JF_WEBRTC_TURN_PORT_RANGE=50000-50050 \\ -e JF_WEBRTC_TURN_IP=&lt;your ip address&gt; \\ -e JF_WEBRTC_TURN_LISTEN_IP=0.0.0.0 \\ -e JF_SERVER_API_TOKEN=development \\ ghcr.io/jellyfish-dev/jellyfish:0.2.0  Make sure to set JF_WEBRTC_TURN_IP and JF_HOST to your local IP address. Without it, the mobile device won't be able to connect to the Jellyfish. tip To check your local IP you can use this handy command (Linux/macOS): ifconfig | grep &quot;inet &quot; | grep -Fv 127.0.0.1 | awk '{print $2}'  "},{"title":"Start the dashboard web front-end​","type":1,"pageTitle":"React Native Minimal Working Example","url":"/jellyfish-docs/tutorials/react-native#start-the-dashboard-web-front-end","content":"There are a couple of ways to start the dashboard: Up-to-date versionDocker containerOfficial repository The current version of the dashboard is ready to use and availablehere. Ensure that it is compatible with your Jellyfish server! Please note that this dashboard only supports secure connections (https/wss) or connections to localhost. Any insecure requests (http/ws) will be automatically blocked by the browser. "},{"title":"Create React Native / Expo project​","type":1,"pageTitle":"React Native Minimal Working Example","url":"/jellyfish-docs/tutorials/react-native#create-react-native--expo-project","content":"Firstly create a brand new project. React NativeExpo Bare workflow npx react-native@latest init JellyfishDashboard  "},{"title":"Add dependencies​","type":1,"pageTitle":"React Native Minimal Working Example","url":"/jellyfish-docs/tutorials/react-native#add-dependencies","content":"note Please make sure to install or update expo to version ^49.0.0 You have two options here. You can follow configuration instructions for React Native (Expo Bare workflow is a React Native project after all) or if you're using expo prebuild command to set up native code you can add our Expo plugin. Just add it to app.json: { &quot;expo&quot;: { &quot;name&quot;: &quot;example&quot;, //... &quot;plugins&quot;: [&quot;@jellyfish-dev/react-native-membrane-webrtc&quot;] } }  React NativeExpo Bare workflow In order for this module to work you'll need to also add `expo` package. The expo package has a small footprint and it's necessary as Jellyfish Client package is built as Expo module. npx install-expo-modules@latest npm install @jellyfish-dev/react-native-client-sdk  tip Run pod install in the /ios directory to install the new pods "},{"title":"Native permissions configuration​","type":1,"pageTitle":"React Native Minimal Working Example","url":"/jellyfish-docs/tutorials/react-native#native-permissions-configuration","content":"In order for camera and audio to work you'll need to add some native configuration: You need to at least set up camera permissions. On Android add to your AndroidManifest.xml: AndroidManifest.xml &lt;uses-permission android:name=&quot;android.permission.CAMERA&quot;/&gt;  For audio you'll need the RECORD_AUDIO permission: AndroidManifest.xml &lt;uses-permission android:name=&quot;android.permission.RECORD_AUDIO&quot;/&gt;  On iOS you must set NSCameraUsageDescription in Info.plist file. You can edit this file in Xcode. This value is a description that is shown when iOS asks user for camera permission. ios/jellyfish-dashboard/Info.plist &lt;key&gt;NSCameraUsageDescription&lt;/key&gt; &lt;string&gt; 🙏 🎥 &lt;/string&gt;  Similarly, for audio there is NSMicrophoneUsageDescription. ios/jellyfish-dashboard/Info.plist &lt;key&gt;NSMicrophoneUsageDescription&lt;/key&gt; &lt;string&gt; 🙏 🎤 &lt;/string&gt;  For screencast there is more configuration needed, it's described here. We also suggest setting background mode to audio so that the app doesn't disconnect when it's in the background: ios/jellyfish-dashboard/Info.plist &lt;key&gt;UIBackgroundModes&lt;/key&gt; &lt;array&gt; &lt;string&gt;audio&lt;/string&gt; &lt;/array&gt;  "},{"title":"Add components library​","type":1,"pageTitle":"React Native Minimal Working Example","url":"/jellyfish-docs/tutorials/react-native#add-components-library","content":"For your convenience, we've prepared a library with nice-looking components useful for following this tutorial. Feel free to use standard React Native components or your own components though! npx expo install @expo/vector-icons expo-barcode-scanner expo-font @expo-google-fonts/noto-sans @jellyfish-dev/react-native-jellyfish-components @react-navigation/native-stack  You'll also need to install Reanimated library (3.3.0) and React Navigation (6.1.7) tip Run pod install in the /ios directory to install the new pods "},{"title":"Screens​","type":1,"pageTitle":"React Native Minimal Working Example","url":"/jellyfish-docs/tutorials/react-native#screens","content":"For managing screens we will use React Navigation library, but feel free to pick whatever suits you. Our app will consist of two screens. The first one ConnectScreen will allow a user to type, paste or scan a peer token and connect to the room. The second one RoomScreen will show room participants with their video tracks. /App.tsx import React from &quot;react&quot;; import { NavigationContainer } from &quot;@react-navigation/native&quot;; import { createNativeStackNavigator } from &quot;@react-navigation/native-stack&quot;; import ConnectScreen from &quot;./screens/Connect&quot;; import RoomScreen from &quot;./screens/Room&quot;; const Stack = createNativeStackNavigator(); function App(): JSX.Element { return ( &lt;NavigationContainer&gt; &lt;Stack.Navigator&gt; &lt;Stack.Screen name=&quot;Connect&quot; component={ConnectScreen} /&gt; &lt;Stack.Screen name=&quot;Room&quot; component={RoomScreen} /&gt; &lt;/Stack.Navigator&gt; &lt;/NavigationContainer&gt; ); } export default App;  "},{"title":"ConnectScreen​","type":1,"pageTitle":"React Native Minimal Working Example","url":"/jellyfish-docs/tutorials/react-native#connectscreen","content":"The UI of the ConnectScreen consists of a simple text input and a few buttons. The flow for this screen is simple: the user either copies the peer token from the dashboard or scans it with a QR code scanner and presses Connect button. The QR code scanner is provided by our components library and it's completely optional, just for convenience. The code for the UI looks like this: /screens/Connect.tsx import React, { useState } from &quot;react&quot;; import { View, StyleSheet } from &quot;react-native&quot;; import { Button, TextInput, QRCodeScanner, } from &quot;@jellyfish-dev/react-native-jellyfish-components&quot;; import { NavigationProp } from &quot;@react-navigation/native&quot;; interface ConnectScreenProps { navigation: NavigationProp&lt;any&gt;; } function ConnectScreen({ navigation }: ConnectScreenProps): JSX.Element { const [peerToken, setPeerToken] = useState&lt;string&gt;(&quot;&quot;); return ( &lt;View style={styles.container}&gt; &lt;TextInput placeholder=&quot;Enter peer token&quot; value={peerToken} onChangeText={setPeerToken} /&gt; &lt;Button onPress={() =&gt; { /* to be filled */ }} title=&quot;Connect&quot; disabled={!peerToken} /&gt; &lt;QRCodeScanner onCodeScanned={setPeerToken} /&gt; &lt;/View&gt; ); } const styles = StyleSheet.create({ container: { flex: 1, justifyContent: &quot;center&quot;, backgroundColor: &quot;#BFE7F8&quot;, padding: 24, rowGap: 24, }, }); export default ConnectScreen;  "},{"title":"Connecting to the server​","type":1,"pageTitle":"React Native Minimal Working Example","url":"/jellyfish-docs/tutorials/react-native#connecting-to-the-server","content":"Once the UI is ready, let's implement the logic responsible for connecting to the server. Firstly wrap your app with JelyfishContextProvider: /App.tsx import React from &quot;react&quot;; import { JellyfishContextProvider } from &quot;@jellyfish-dev/react-native-client-sdk&quot;; import { NavigationContainer } from &quot;@react-navigation/native&quot;; import { createNativeStackNavigator } from &quot;@react-navigation/native-stack&quot;; import ConnectScreen from &quot;./screens/Connect&quot;; import RoomScreen from &quot;./screens/Room&quot;; const Stack = createNativeStackNavigator(); function App(): JSX.Element { return ( &lt;JellyfishContextProvider&gt; &lt;NavigationContainer&gt; &lt;Stack.Navigator&gt; &lt;Stack.Screen name=&quot;Connect&quot; component={ConnectScreen} /&gt; &lt;Stack.Screen name=&quot;Room&quot; component={RoomScreen} /&gt; &lt;/Stack.Navigator&gt; &lt;/NavigationContainer&gt; &lt;/JellyfishContextProvider&gt; ); } export default App;  Then in the ConnectScreen use the useJellyfishClient hook to connect to the server. Simply call the connect method with your Jellyfish server URL and the peer token. The connect function establishes a connection with the Jellyfish server via web socket and authenticates the peer. /screens/Connect.tsx import { useJellyfishClient } from &quot;@jellyfish-dev/react-native-client-sdk&quot;; import { NavigationProp } from &quot;@react-navigation/native&quot;; interface ConnectScreenProps { navigation: NavigationProp&lt;any&gt;; } // This is the address of the Jellyfish backend. Change the local IP to yours. We // strongly recommend setting this as an environment variable, we hardcoded it here // for simplicity. const JELLYFISH_URL = &quot;ws://X.X.X.X:4000/socket/peer/websocket&quot;; function ConnectScreen({ navigation }: ConnectScreenProps): JSX.Element { const [peerToken, setPeerToken] = useState&lt;string&gt;(&quot;&quot;); const { connect } = useJellyfishClient(); const connectToRoom = async () =&gt; { try { await connect(JELLYFISH_URL, peerToken.trim()); } catch (e) { console.log(&quot;Error while connecting&quot;, e); } }; return ( &lt;View style={styles.container}&gt; &lt;TextInput placeholder=&quot;Enter peer token&quot; value={peerToken} onChangeText={setPeerToken} /&gt; &lt;Button onPress={connectToRoom} title=&quot;Connect&quot; disabled={!peerToken} /&gt; &lt;QRCodeScanner onCodeScanned={setPeerToken} /&gt; &lt;/View&gt; ); } // ...  "},{"title":"Camera permissions (Android only)​","type":1,"pageTitle":"React Native Minimal Working Example","url":"/jellyfish-docs/tutorials/react-native#camera-permissions-android-only","content":"To start the camera we need to ask the user for permission first. We'll use a standard React Native module for this: /screens/Connect.tsx import { View, StyleSheet, type Permission, PermissionsAndroid, Platform, } from &quot;react-native&quot;; // ... function ConnectScreen({ navigation }: ConnectScreenProps): JSX.Element { // ... const grantedCameraPermissions = async () =&gt; { if (Platform.OS === &quot;ios&quot;) return true; const granted = await PermissionsAndroid.request( PermissionsAndroid.PERMISSIONS.CAMERA as Permission ); if (granted !== PermissionsAndroid.RESULTS.GRANTED) { console.error(&quot;Camera permission denied&quot;); return false; } return true; }; const connectToRoom = async () =&gt; { try { await connect(JELLYFISH_URL, peerToken.trim()); if (!(await grantedCameraPermissions())) { return; } } catch (e) { console.log(&quot;Error while connecting&quot;, e); } }; // ... } // ...  "},{"title":"Starting the camera​","type":1,"pageTitle":"React Native Minimal Working Example","url":"/jellyfish-docs/tutorials/react-native#starting-the-camera","content":"Jellyfish Client provides a handy hook for managing the camera: useCamera. Not only it can start a camera but also toggle it, manage its state, simulcast and bandwidth settings, and switch between multiple sources. Also when starting the camera you can provide multiple different settings such as resolution, quality, and metadata. In this example though we'll simply turn it on to stream the camera to the dashboard with default settings /screens/Connect.tsx import { useJellyfishClient, useCamera, } from &quot;@jellyfish-dev/react-native-client-sdk&quot;; // ... function ConnectScreen({ navigation }: ConnectScreenProps): JSX.Element { // ... const { startCamera } = useCamera(); const connectToRoom = async () =&gt; { try { await connect(JELLYFISH_URL, peerToken.trim()); if (!(await grantedCameraPermissions())) { return; } await startCamera(); } catch (e) { console.log(&quot;Error while connecting&quot;, e); } }; // ... } // ...  "},{"title":"Joining the room​","type":1,"pageTitle":"React Native Minimal Working Example","url":"/jellyfish-docs/tutorials/react-native#joining-the-room","content":"The last step of connecting to the room would be actually joining it so that your camera track is visible to the other users. To do this simply use the join function from the useJellyfishClient hook. You can also provide some user metadata when joining. Metadata can be anything and is forwarded to the other participants as is. In our case, we pass a username. After joining the room we navigate to the next screen: Room screen. /screens/Connect.tsx // ... function ConnectScreen({ navigation }: ConnectScreenProps): JSX.Element { const { connect, join } = useJellyfishClient(); const connectToRoom = async () =&gt; { try { await connect(JELLYFISH_URL, peerToken.trim()); if (!(await grantedCameraPermissions())) { return; } await startCamera(); await join({ name: &quot;Mobile RN Client&quot; }); navigation.navigate(&quot;Room&quot;); } catch (e) { console.log(&quot;Error while connecting&quot;, e); } }; // ... } // ...  Now the app is ready for the first test. If everything went well you should see a video from your camera in the front-end dashboard. Now onto the second part: displaying the streams from other participants. "},{"title":"RoomScreen​","type":1,"pageTitle":"React Native Minimal Working Example","url":"/jellyfish-docs/tutorials/react-native#roomscreen","content":""},{"title":"Displaying video tracks​","type":1,"pageTitle":"React Native Minimal Working Example","url":"/jellyfish-docs/tutorials/react-native#displaying-video-tracks","content":"The Room screen has a couple of responsibilities: it displays your own video. Note that it's taken directly from your camera i.e. we don't send it to the JF and get it back so other participants might see you a little bit differentlyit presents current room state so participants list, their video tiles, etc.it allows you to leave a meeting To get information about all participants (also the local one) in the room useusePeers() hook from Jellyfish Client. The hook returns all the participants with their ids, tracks and metadata. When a new participant joins or any participant leaves or anything else changes, the hook updates with the new information. To display video tracks Jellyfish Client comes with a dedicated component for displaying a video track: &lt;VideoRenderer&gt;. It takes a track id as a prop (it may be a local or remote track) and, as any other &lt;View&gt; in react, a style. style property gives a lot of possibilities. You can even animate your track! So, let's display all the participants in the simplest way possible: /screens/Room.tsx import React from &quot;react&quot;; import { View, StyleSheet } from &quot;react-native&quot;; import { NavigationProp, RouteProp } from &quot;@react-navigation/native&quot;; import { usePeers, VideoRendererView, } from &quot;@jellyfish-dev/react-native-client-sdk&quot;; interface RoomScreenProps { navigation: NavigationProp&lt;YourNavigatorParamList&gt;; } function RoomScreen({ navigation }: RoomScreenProps): JSX.Element { const peers = usePeers(); return ( &lt;View style={styles.container}&gt; &lt;View style={styles.videoContainer}&gt; {peers.map((peer) =&gt; peer.tracks[0] ? ( &lt;VideoRendererView trackId={peer.tracks[0].id} style={styles.video} /&gt; ) : null )} &lt;/View&gt; &lt;/View&gt; ); } const styles = StyleSheet.create({ container: { flex: 1, alignItems: &quot;center&quot;, justifyContent: &quot;space-between&quot;, backgroundColor: &quot;#F1FAFE&quot;, padding: 24, }, videoContainer: { flexDirection: &quot;row&quot;, gap: 8, flexWrap: &quot;wrap&quot;, }, video: { width: 200, height: 200 }, }); export default RoomScreen;  You should now see your own camera on your mobile device. You can add another participant and their new track (displaying for example rotating frog) in the dashboard like this:  It should show up in the Room screen automatically:  For your convenience in our components library we provided a component to layout videos in a nice grid: /screens/Room.tsx import { VideosGrid } from &quot;@jellyfish-dev/react-native-jellyfish-components&quot;; // ... function RoomScreen({ navigation }: RoomScreenProps): JSX.Element { const peers = usePeers(); return ( &lt;View style={styles.container}&gt; &lt;VideosGrid tracks={peers.map((peer) =&gt; peer.tracks[0]?.id).filter((t) =&gt; t)} /&gt; &lt;/View&gt; ); }  "},{"title":"Gracefully leaving the room​","type":1,"pageTitle":"React Native Minimal Working Example","url":"/jellyfish-docs/tutorials/react-native#gracefully-leaving-the-room","content":"To leave a room we'll add a button for the user. When the user clicks it, we gracefully leave the room, close the server connection and go back to theConnectscreen. For leaving the room and closing the server connection you can use the cleanUp method from the useJellyfishClient() hook. /screens/Room.tsx // ... import { usePeers, VideoRendererView, useJellyfishClient, } from &quot;@jellyfish-dev/react-native-client-sdk&quot;; import { InCallButton } from &quot;@jellyfish-dev/react-native-jellyfish-components&quot;; // ... function RoomScreen({ navigation }: RoomScreenProps): JSX.Element { const peers = usePeers(); const { cleanUp } = useJellyfishClient(); const onDisconnectPress = () =&gt; { cleanUp(); navigation.goBack(); }; return ( &lt;View style={styles.container}&gt; &lt;VideosGrid tracks={peers.map((peer) =&gt; peer.tracks[0]?.id).filter((t) =&gt; t)} /&gt; &lt;InCallButton type=&quot;disconnect&quot; iconName=&quot;phone-hangup&quot; onPress={onDisconnectPress} /&gt; &lt;/View&gt; ); } // ...  To launch your app, you can use the following command: iosandroid npm run ios  "},{"title":"Summary​","type":1,"pageTitle":"React Native Minimal Working Example","url":"/jellyfish-docs/tutorials/react-native#summary","content":"Congrats on finishing your first Jellyfish mobile application! In this tutorial, you've learned how to make a basic Jellyfish client application that streams and receives video tracks with WebRTC technology. But this was just the beginning. Jellyfish Client supports much more than just streaming camera: it can also stream audio, screencast your device's screen, configure your camera and audio devices, detect voice activity, control simulcast, bandwidth and encoding settings, show camera preview, display WebRTC stats and more to come. Check out our other tutorials to learn about those features. You can also take a look at our fully featured Videoroom Demo example:  "},{"title":"Simple React App","type":0,"sectionRef":"#","url":"/jellyfish-docs/tutorials/simple-react-app","content":"","keywords":""},{"title":"What you'll learn​","type":1,"pageTitle":"Simple React App","url":"/jellyfish-docs/tutorials/simple-react-app#what-youll-learn","content":"This tutorial will guide you through creating your first React project that uses the Jellyfish Client. By the end of the tutorial, you'll have a working web application that connects toJellyfish Media Server using WebRTC technology.  You can check out the finished project here "},{"title":"What do you need​","type":1,"pageTitle":"Simple React App","url":"/jellyfish-docs/tutorials/simple-react-app#what-do-you-need","content":"a little bit of experience in creating React appsIDE of your choice (for example Visual Studio Code)Node.js installed on your machine "},{"title":"Jellyfish architecture​","type":1,"pageTitle":"Simple React App","url":"/jellyfish-docs/tutorials/simple-react-app#jellyfish-architecture","content":"info You can learn more about Jellyfish architecture in Jellyfish docs. This section provides a brief description aimed at front-end developers Let's introduce some concepts first: Peer - A peer is a client-side entity that connects to the server to publish, subscribe or publish and subscribe to tracks published by components or other peers. You can think of it as a participant in a room. At the moment, there is only one type of peer - WebRTC.Track - An object that represents an audio or video stream. A track can be associated with a local media source, such as a camera or microphone, or a remote media source received from another user. Tracks are used to capture, transmit, and receive audio and video data in WebRTC applications.Room - In Jellyfish, a room serves as a holder for peers and components, its function varying based on application. From a front-end perspective, this will be probably one meeting or a broadcast. For a better understanding of these concepts here is an example of a room that holds a standard WebRTC conference from a perspective of the User:  In this example, peers stream multiple video and audio tracks. Peer #1 streams even two video tracks (camera and screencast track). You can differentiate between them by using track metadata. The user gets info about peers and their tracks from the server using Jellyfish Client. The user is also informed in real time about peers joining/leaving and tracks being added/removed. To keep this tutorial short we'll simplify things a little. Every peer will stream just one video track. "},{"title":"Connecting and joining the room​","type":1,"pageTitle":"Simple React App","url":"/jellyfish-docs/tutorials/simple-react-app#connecting-and-joining-the-room","content":"The general flow of connecting to the server and joining the room in a standard WebRTC conference setup looks like this:  The parts that you need to implement are marked in blue and things handled by Jellyfish are marked in red. Firstly, the user logs in. Then your backend authenticates the user and obtains a peer token. It allows the user to authenticate and join the room in Jellyfish Server. The backend passes the token to your front-end, and your front-end passes it to Jellyfish Client. The client establishes the connection with Jellyfish Server. Then Jellyfish Client sets up tracks (camera, microphone) to stream and joins the room on Jellyfish Server. Finally, your front-end can display the room for the user. For this tutorial we simplified this process a bit - you don't have to implement a backend or authentication. Jellyfish Dashboard will do this for you. It's also a nice tool to test and play around with Jellyfish. The flow with Jellyfish The dashboard looks like this:  You can see that the only things you need to implement are interactions with the user and Jellyfish Client. This tutorial will show you how to do it. "},{"title":"Setup​","type":1,"pageTitle":"Simple React App","url":"/jellyfish-docs/tutorials/simple-react-app#setup","content":""},{"title":"Create React + Vite project​","type":1,"pageTitle":"Simple React App","url":"/jellyfish-docs/tutorials/simple-react-app#create-react--vite-project","content":"Firstly create a brand new project. npm create vite@latest my-react-app -- --template react-ts  "},{"title":"Add dependencies​","type":1,"pageTitle":"Simple React App","url":"/jellyfish-docs/tutorials/simple-react-app#add-dependencies","content":"For this module to work you'll need to add our `react-client-sdk` package. This is necessary to create and connect Jellyfish Client. npm install https://github.com/jellyfish-dev/react-client-sdk#0.1.2  "},{"title":"Start the Jellyfish backend​","type":1,"pageTitle":"Simple React App","url":"/jellyfish-docs/tutorials/simple-react-app#start-the-jellyfish-backend","content":"For testing, we'll run the Jellyfish Media Server locally using Docker image: docker run -p 50000-50050:50000-50050/udp \\ -p 5002:5002/tcp \\ -e JF_CHECK_ORIGIN=false \\ -e JF_HOST=&lt;your ip address&gt;:5002 \\ -e JF_PORT=&quot;5002&quot; \\ -e JF_WEBRTC_USED=true \\ -e JF_WEBRTC_TURN_PORT_RANGE=50000-50050 \\ -e JF_WEBRTC_TURN_IP=&lt;your ip address&gt; \\ -e JF_WEBRTC_TURN_LISTEN_IP=0.0.0.0 \\ -e JF_SERVER_API_TOKEN=development \\ ghcr.io/jellyfish-dev/jellyfish:0.2.0  Make sure to set JF_WEBRTC_TURN_IP and JF_HOST to your local IP address. Without it, the mobile device won't be able to connect to the Jellyfish. tip To check your local IP you can use this handy command (Linux/macOS): ifconfig | grep &quot;inet &quot; | grep -Fv 127.0.0.1 | awk '{print $2}'  "},{"title":"Start the dashboard web front-end​","type":1,"pageTitle":"Simple React App","url":"/jellyfish-docs/tutorials/simple-react-app#start-the-dashboard-web-front-end","content":"There are a couple of ways to start the dashboard: Up-to-date versionDocker containerOfficial repository The current version of the dashboard is ready to use and availablehere. Ensure that it is compatible with your Jellyfish server! Please note that this dashboard only supports secure connections (https/wss) or connections to localhost. Any insecure requests (http/ws) will be automatically blocked by the browser. "},{"title":"(Optional) Add a bit of CSS styling​","type":1,"pageTitle":"Simple React App","url":"/jellyfish-docs/tutorials/simple-react-app#optional-add-a-bit-of-css-styling","content":"For this project, we prepared simple CSS classes, You are free to use it or create your own. "},{"title":"General project structure​","type":1,"pageTitle":"Simple React App","url":"/jellyfish-docs/tutorials/simple-react-app#general-project-structure","content":"Our app will consist of two parts: a component that will connect to the server and join the room a component that will display the video tracks from other participants "},{"title":"First step - prepare all the hooks and the context​","type":1,"pageTitle":"Simple React App","url":"/jellyfish-docs/tutorials/simple-react-app#first-step---prepare-all-the-hooks-and-the-context","content":"To connect to the Jellyfish backend, we need to create a Membrane Client instance. We can do it by using the create function from the@jellyfish-dev/react-client-sdk package. It needs two generic parameters: PeerMetadata - the type of metadata that will be sent to the server when connecting to the room (for example, user name) it has to be serializable TrackMetadata - the type of the metadata that will be sent to the server when sending a track (for example, track name) it has to be serializable as well App.tsx import React from &quot;react&quot;; import { create } from &quot;@jellyfish-dev/react-client-sdk&quot;; // Example metadata types for peer and track // You can define your metadata types just make sure they are serializable type PeerMetadata = { name: string; }; type TrackMetadata = { type: &quot;camera&quot; | &quot;screen&quot;; }; // Create a Jellyfish client instance // Since we will use this context outside of the component we need to export it export const { JellyfishContextProvider, // Context provider } = create&lt;PeerMetadata, TrackMetadata&gt;(); export const App = () =&gt; {};  "},{"title":"Now we need to wrap our app with the context provider​","type":1,"pageTitle":"Simple React App","url":"/jellyfish-docs/tutorials/simple-react-app#now-we-need-to-wrap-our-app-with-the-context-provider","content":"That's all we will need to do in this file. Simply import the JellyfishContextProvider along with the Appcomponent and wrap the App component with the JellyfishContextProvider: main.tsx import React from &quot;react&quot;; import ReactDOM from &quot;react-dom/client&quot;; import { App, JellyfishContextProvider } from &quot;./components/App&quot;; ReactDOM.createRoot(document.getElementById(&quot;root&quot;) as HTMLElement).render( &lt;React.StrictMode&gt; &lt;JellyfishContextProvider&gt; &lt;App /&gt; &lt;/JellyfishContextProvider&gt; &lt;/React.StrictMode&gt; );  "},{"title":"UI component that will connect to the server and join the room​","type":1,"pageTitle":"Simple React App","url":"/jellyfish-docs/tutorials/simple-react-app#ui-component-that-will-connect-to-the-server-and-join-the-room","content":"The UI of the component will be quite simple. It will consist of a simple text input field that will allow us to enter the peer token and a button that will connect to the server and join the room. We can also display the status of the connection. App.tsx import React, { useState } from &quot;react&quot;; //... export const App = () =&gt; { // Create a state to store the peer token const [token, setToken] = useState(&quot;&quot;); return ( &lt;div style={{ display: &quot;flex&quot;, flexDirection: &quot;column&quot;, gap: &quot;8px&quot; }}&gt; &lt;input value={token} onChange={(e) =&gt; setToken(() =&gt; e?.target?.value)} placeholder=&quot;token&quot; /&gt; &lt;div style={{ display: &quot;flex&quot;, flexDirection: &quot;row&quot;, gap: &quot;8px&quot; }}&gt; &lt;button disabled={} onClick={() =&gt; {}}; &gt; Connect &lt;/button&gt; &lt;button disabled={} onClick={() =&gt; {}}; &gt; Disconnect &lt;/button&gt; &lt;span&gt;Status: {}&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; ); };  "},{"title":"Once the UI is ready, we need to implement the logic​","type":1,"pageTitle":"Simple React App","url":"/jellyfish-docs/tutorials/simple-react-app#once-the-ui-is-ready-we-need-to-implement-the-logic","content":"App.tsx import { SignalingUrl } from &quot;@jellyfish-dev/react-client-sdk/.&quot;; //... export const { useStatus, // Hook to check the status of the connection useConnect, // Hook to connect to the server useDisconnect, // Hook to disconnect from the server JellyfishContextProvider, // Context provider }; export const App = () =&gt; { // Create a state to store the peer token const [token, setToken] = useState(&quot;&quot;); // Use the built-in hook to check the status of the connection const status = useStatus(); const connect = useConnect(); const disconnect = useDisconnect(); return ( &lt;div style={{ display: &quot;flex&quot;, flexDirection: &quot;column&quot;, gap: &quot;8px&quot; }}&gt; &lt;input className=&quot;input-field&quot; value={token} onChange={(e) =&gt; setToken(() =&gt; e?.target?.value)} placeholder=&quot;token&quot; /&gt; &lt;div style={{ display: &quot;flex&quot;, flexDirection: &quot;row&quot;, gap: &quot;8px&quot; }}&gt; &lt;button className=&quot;button&quot; disabled={token === &quot;&quot; || status === &quot;joined&quot;} // simple check to avoid errors onClick={() =&gt; { connect({ peerMetadata: { name: &quot;John Doe&quot; }, // example metadata token: token, }); }} &gt; Connect &lt;/button&gt; &lt;button className=&quot;button&quot; disabled={status !== &quot;joined&quot;} onClick={() =&gt; { disconnect(); }} &gt; Disconnect &lt;/button&gt; &lt;span className=&quot;span-status&quot;&gt;Status: {status}&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; ); };  Great! Now we can connect to the server and join the room. But we still need to add some logic to send our tracks to the server and receive tracks from others. "},{"title":"Let's send our screen to the server​","type":1,"pageTitle":"Simple React App","url":"/jellyfish-docs/tutorials/simple-react-app#lets-send-our-screen-to-the-server","content":"This hook uses Navigator.mediaDevices take a look how it works App.tsx import React, { useEffect, useState } from &quot;react&quot;; import { create, SCREEN_SHARING_MEDIA_CONSTRAINTS } from &quot;@jellyfish-dev/react-client-sdk&quot;; import { SignalingUrl, Peer } from &quot;@jellyfish-dev/react-client-sdk/.&quot;; //... export const { useStatus, // Hook to check the status of the connection useApi, // Hook to get the webrtcApi reference useConnect, // Hook to connect to the server useDisconnect, // Hook to disconnect from the server JellyfishContextProvider, // Context provider } = create&lt;PeerMetadata, TrackMetadata&gt;(); export const App = () =&gt; { //... // Get the webrtcApi reference const webrtcApi = useApi(); function startScreenSharing() { // Get screen sharing MediaStream navigator.mediaDevices.getDisplayMedia(SCREEN_SHARING_MEDIA_CONSTRAINTS).then((screenStream) =&gt; { // Add local MediaStream to webrtc screenStream.getTracks().forEach((track) =&gt; webrtcApi.addTrack(track, screenStream, { type: &quot;screen&quot; })); }; }; return ( //... &lt;button className=&quot;button&quot; disabled={status !== &quot;joined&quot;} onClick={() =&gt; { startScreenSharing(); }} &gt; Start screen share &lt;/button&gt; &lt;span&gt;Status: {status}&lt;/span&gt; //... ) };  You should now see your screen received for each connected client on the dashboard. You can add another participant to check this out! The streaming part of the app is ready! "},{"title":"What about the receiving part?​","type":1,"pageTitle":"Simple React App","url":"/jellyfish-docs/tutorials/simple-react-app#what-about-the-receiving-part","content":""},{"title":"This is where the second component comes in handy​","type":1,"pageTitle":"Simple React App","url":"/jellyfish-docs/tutorials/simple-react-app#this-is-where-the-second-component-comes-in-handy","content":"For each track received, we will create a new video element and display it on the screen. For clarity, we will separate this component into another file: Create in your directory file VideoPlayer.tsx VideoPlayer.tsx type Props = { stream: MediaStream | null | undefined; }; const VideoPlayer = ({ stream }: Props) =&gt; { return ( &lt;div className=&quot;video-container&quot;&gt; &lt;video autoPlay playsInline muted ref={/* place for track ref*/} /&gt; &lt;/div&gt; ); }; export default VideoPlayer;  "},{"title":"Now the logic for the component​","type":1,"pageTitle":"Simple React App","url":"/jellyfish-docs/tutorials/simple-react-app#now-the-logic-for-the-component","content":"VideoPlayer.tsx type Props = { stream: MediaStream | null | undefined; }; const VideoPlayer = ({ stream }: Props) =&gt; { const videoRef: RefObject&lt;HTMLVideoElement&gt; = useRef&lt;HTMLVideoElement&gt;(null); useEffect(() =&gt; { if (!videoRef.current) return; videoRef.current.srcObject = stream || null; }, [stream]); return ( &lt;div&gt; &lt;video autoPlay playsInline muted ref={videoRef} /&gt; &lt;/div&gt; ); }; export default VideoPlayer;  "},{"title":"Now we can use it in our main component​","type":1,"pageTitle":"Simple React App","url":"/jellyfish-docs/tutorials/simple-react-app#now-we-can-use-it-in-our-main-component","content":"App.tsx import React, { useEffect, useState } from &quot;react&quot;; import { create, SCREEN_SHARING_MEDIA_CONSTRAINTS } from &quot;@jellyfish-dev/react-client-sdk&quot;; import { SignalingUrl, Peer } from &quot;@jellyfish-dev/react-client-sdk/.&quot;; import VideoPlayer from &quot;./VideoPlayer&quot;; //... export const { useStatus, // Hook to check the status of the connection useTracks, // Hook to get the tracks from the server useApi, // Hook to get the webrtcApi reference useConnect, // Hook to connect to the server useDisconnect, // Hook to disconnect from the server JellyfishContextProvider, // Context provider } = create&lt;PeerMetadata, TrackMetadata&gt;(); export const App = () =&gt; { const tracks = useTracks(); //... &lt;div style={{ display: &quot;flex&quot;, flexWrap: &quot;wrap&quot;, justifyContent: &quot;center&quot;, // To align items in the center gap: &quot;20px&quot;, }} &gt; {Object.values(tracks).map(({ stream, trackId }) =&gt; ( &lt;VideoPlayer key={trackId} stream={stream} /&gt; // pass the stream to the component ))} &lt;/div&gt; //... )  You should see all the tracks sent from the dashboard directly on your page, to test them, add a new client, and add a track (for example a rotating frog). It will show up in your app automatically: "},{"title":"Summary​","type":1,"pageTitle":"Simple React App","url":"/jellyfish-docs/tutorials/simple-react-app#summary","content":"Congrats on finishing your first Jellyfish web application! In this tutorial, You've learned how to make a basic Jellyfish client application that streams your screen and receives video tracks with WebRTC technology. But this was just the beginning. Jellyfish Client supports much more than just streaming camera: It can also stream audio or your device's camera, configure your camera and audio devices, detect voice activity, control simulcast, bandwidth and encoding settings, show camera preview, display WebRTC stats and more to come. Check out our other tutorials to learn about those features. You can also take a look at our fully featured Videoroom Demo example:  "}]