[{"title":"Fly.io (experimental)","type":0,"sectionRef":"#","url":"/jellyfish-docs/deploying/fly_io","content":"","keywords":""},{"title":"Creating new app​","type":1,"pageTitle":"Fly.io (experimental)","url":"/jellyfish-docs/deploying/fly_io#creating-new-app","content":"Launch fly launch. When prompted, copy the configuration from the existing fly.toml file. Select appropriate app name and region, don't create any databases. Don't deploy the app just yet. Running fly launch may modify the Dockerfile. Make sure to remove the lines appended by flyctl. "},{"title":"Configuring the App​","type":1,"pageTitle":"Fly.io (experimental)","url":"/jellyfish-docs/deploying/fly_io#configuring-the-app","content":"Before deploying your app, make sure it is correctly configured. "},{"title":"Dedicated IPv4​","type":1,"pageTitle":"Fly.io (experimental)","url":"/jellyfish-docs/deploying/fly_io#dedicated-ipv4","content":"In order to transmit multimedia via UDP, the app has to be publicly available with an IPv4 address. By default Fly.io uses shared IP. To enable dedicated IPv4 address run fly ips allocate-v4  Note, that dedicated IP address is a paid feature on Fly.io. You can learn more about dedicated IPv4 address here. "},{"title":"fly.toml​","type":1,"pageTitle":"Fly.io (experimental)","url":"/jellyfish-docs/deploying/fly_io#flytoml","content":"Make sure you don't have the following lines in the fly.toml, which are automatically generated by fly launch. You don't need to run migrations, since you don't have a database. [deploy] release_command = &quot;/app/bin/migrate&quot;  Jellyfish uses VIRTUAL_HOST variable instead of the default PHX_HOST. VIRTUAL_HOST = &quot;&lt;YOUR APP HOSTNAME&gt;&quot;  Also, make sure you have set the correct port. The enviroment variable PORT has to match the tcp internal_port defined under services section. The default for Jellyfish is 4000. To be able to receive and send UDP traffic, Jellyfish has to open its UDP ports on a special fly-global-services address, not 0.0.0.0. This must be set using the INTEGRATED_TURN_LISTEN_IP enviroment variable. You also need to specify the Jellyfish IP address for UDP, it is the IP address which you generated in the previous step. INTEGRATED_TURN_LISTEN_IP = &quot;fly-global-services&quot; INTEGRATED_TURN_IP=&quot;&lt;YOUR APP IP ADDRESS&gt;&quot;  You can also read tutorial for running Fly.io apps which use UDP. "},{"title":"Fly.io secrets​","type":1,"pageTitle":"Fly.io (experimental)","url":"/jellyfish-docs/deploying/fly_io#flyio-secrets","content":"There are enviroment variables, which you may not want to keep in the fly.toml config. Fly.io provides a way to store such values securely. For Jellyfish you need to configure SECRET_KEY_BASE and TOKEN secrets. flyctl secrets set SECRET_KEY_BASE=super-secret-key flyctl secrets set TOKEN=development  "},{"title":"Deploying​","type":1,"pageTitle":"Fly.io (experimental)","url":"/jellyfish-docs/deploying/fly_io#deploying","content":"With everything configured you can deploy the app fly deploy  Note that it may take a moment for the UDP traffic to be forwarded to the application. This means for example, that WebRTC may not be working yet. This is the tricky part of the deployment, which we weren't able to entirely figure out. Sometimes the UDP just works, others it takes ages for it to start flowing.This topic describes the exact issue we had with Fly.io. In general, it is unclear when the UDP traffic starts to be forwarded, sometimes it happens relatively quickly after deployment, sometimes you need to wait for some time. Also, the Fly.io documentation isn't clear in regard to opening UDP sockets. Some information was gathered experimentally, or based on Fly.io community questions, such as this one. "},{"title":"API Reference","type":0,"sectionRef":"#","url":"/jellyfish-docs/api_reference","content":"API Reference Jellyfish API is composed of three layers a REST API for managing Jellyfish statea WS connection for client SDK communication (socket path /socket/peer) a WS connection for server notifications (socket path /socket/server) You can find them here: OpenAPI REST descriptionProtobufs used by peer WSProtobufs used by server WS The communication via WebSockets is done with use of Protobuf format. The very first message that has to be sent on either of WebSocket connections (peer to Jellyfish oryour_backend_server to Jellyfish) is AuthRequest. All supported messages are listed in the Jellyfish protos repo. If you want to create your own Jellyfish SDK, the easiest way to reference to defined protobuf messages will be by adding protos to your git repository as a git submodule. You can do it with this command: git submodule add https://github.com/jellyfish-dev/protos You could also consider creating a script that will pull newest changes from the git submodule and compile.proto files to your chosen programming language. For reference, see the script used in our Elixir SDK.","keywords":""},{"title":"Examples","type":0,"sectionRef":"#","url":"/jellyfish-docs/examples","content":"Examples Jellyfish usage examples utilising server SDKs can be found in the following locations: Elixir","keywords":""},{"title":"Architecture","type":0,"sectionRef":"#","url":"/jellyfish-docs/getting_started/architecture","content":"","keywords":""},{"title":"Server SDKs​","type":1,"pageTitle":"Architecture","url":"/jellyfish-docs/getting_started/architecture#server-sdks","content":"Server SDKs allow you to manage Jellyfish state. In particular, you can: authenticatecreate/delete roomsadd/remove peersadd/remove components Support for server-side notifications is also planned for the near future. Under the hood, Server SDKs just use Jellyfish REST API. tip As an example, you can use server SDK to introduce a time limit on meeting duration and shut down the room after it passes. "},{"title":"Client SDKs​","type":1,"pageTitle":"Architecture","url":"/jellyfish-docs/getting_started/architecture#client-sdks","content":"Client SDKs allow you to connect to Jellyfish to publish and consume tracks. In particular, you can: authenticatejoin specific roompublish audio and videoreceive audio and video from other peers and components At the moment, Jellyfish supports only one type of client - WebRTC. "},{"title":"Diagram​","type":1,"pageTitle":"Architecture","url":"/jellyfish-docs/getting_started/architecture#diagram","content":"The whole concept is presented in the following diagram.     Your Backend (BE) - serves your application frontend, and manages the database and application-specific logic. Jellyfish (JF) - Jellyfish media server. Manages media. Admin - someone who has special permission in your application - can create/delete rooms, add/remove peers, etc. User - someone who connects to Jellyfish to send and receive media. Everything starts with Admin who sends an HTTP request to BE to create a new room.BE uses jellyfish-server-sdk to communicate with JF and create the room. Under the hood, jellyfish-server-sdk uses REST API exposed by JF. After the room has been created, the Admin invites a user by sending a new HTTP request to BE. Again, BE uses jellyfish-server-sdk to add the new peer to JF. On the user side, they send a request to BE to join the room.BE replies with JF IP address it should connect to. Then, the User uses jellyfish-client-sdk to connect to JF. After the connection has been established, the User can send and receive media. "},{"title":"Authentication","type":0,"sectionRef":"#","url":"/jellyfish-docs/getting_started/authentication","content":"Authentication The Authentication mechanism is based on a bearer token. How does it work? Both Jellyfish and Business Logic are configured with the same secret. This secret is used for authorizing HTTP requests between them (via HTTP authorization request header). When a new client wants to join a room, Business Logic (assuming the client is authorized to join) requests adding a new peer and receives a token generated by Jellyfish. The token must then be passed to the client, that will use it to connect to the room as a new peer. The token encodes both peer and room IDs. The token exchange is handled by our Client SDKs when connecting. Under the hood, Jellyfish expects the token in the first message after opening the Web Socket connection. Token encodes peer id and room id. Run Jellyfish SERVER_API_TOKEN=SERVER_API_TOKEN mix phx.server Create a room and add one peer Business Logic client = Jellyfish.Client.new(&quot;http://address-of-your-server.com&quot;, &quot;SERVER_API_TOKEN&quot;) {:ok, room} = Jellyfish.Room.create(client, max_peers: 10) {:ok, peer, peer_token} = Jellyfish.Room.add_peer(client, room.id, &quot;BobId&quot;) Connect as a peer to Jellyfish Client client.connect({ token: peerToken, peerMetadata: { name: &quot;Bob&quot; }, isSimulcastOn: false }) ","keywords":""},{"title":"Design Docs","type":0,"sectionRef":"#","url":"/jellyfish-docs/design_docs","content":"Design Docs Crucial parts of Jellyfish architecture are always discussed and written down in the form of design documents. Each design document describes, in a nutshell, a few possible solutions or approaches to some problem and states which solution was accepted and why. The list of Jellyfish Design Docs is available here.","keywords":""},{"title":"RTSP","type":0,"sectionRef":"#","url":"/jellyfish-docs/getting_started/components/rtsp","content":"","keywords":""},{"title":"Compatibility​","type":1,"pageTitle":"RTSP","url":"/jellyfish-docs/getting_started/components/rtsp#compatibility","content":"HLS "},{"title":"Configuration options​","type":1,"pageTitle":"RTSP","url":"/jellyfish-docs/getting_started/components/rtsp#configuration-options","content":""},{"title":"Required​","type":1,"pageTitle":"RTSP","url":"/jellyfish-docs/getting_started/components/rtsp#required","content":"sourceUri (string) - URI of RTSP source stream, e.g. &quot;rtsp://mysite.net:554/stream&quot; "},{"title":"Additional​","type":1,"pageTitle":"RTSP","url":"/jellyfish-docs/getting_started/components/rtsp#additional","content":"rtpPort (integer 1..65535, default: 20000) - Local port RTP stream will be received atreconnectDelay (integer 0.., default: 15000) - Delay (in ms) between successive reconnect attemptskeepAliveInterval (integer 0.., default: 15000) - Interval (in ms) in which keep-alive RTSP messages will be sent to the remote stream sourcepierceNat (boolean, default: true) - Whether to attempt to create client-side NAT binding by sending an empty datagram from client to source, after the completion of RTSP setup "},{"title":"Env variables​","type":1,"pageTitle":"RTSP","url":"/jellyfish-docs/getting_started/components/rtsp#env-variables","content":"Currently, there are no environment variables related to this component. "},{"title":"Example Docker commands​","type":1,"pageTitle":"RTSP","url":"/jellyfish-docs/getting_started/components/rtsp#example-docker-commands","content":"caution If the client is behind NAT, the option --network=host is necessary since Docker can change the source port of UDP packets for routing reasons, which breaks the pierceNat functionality. This means that users on macOS will most likely be unable to access any RTSP stream source outside of their network when running Jellyfish using Docker. If you're on macOS and want to receive RTSP streams from behind NAT, right now the only way is to build Jellyfish natively from source. Explicit port exposure (macOS compatible) docker run -p 20000:20000/udp \\ -p 4000:4000/tcp \\ -e SERVER_API_TOKEN=token \\ -e VIRTUAL_HOST=localhost \\ -e SECRET_KEY_BASE=secret \\ ghcr.io/jellyfish-dev/jellyfish:latest  caution Make sure that the exposed UDP port matches the one used by the RTSP component (option rtpPort, default: 20000). If using multiple RTSP components, more ports will need to be exposed. Using host network (Linux only) docker run --network=host \\ -e SERVER_API_TOKEN=token \\ -e VIRTUAL_HOST=localhost \\ -e SECRET_KEY_BASE=secret \\ ghcr.io/jellyfish-dev/jellyfish:latest  "},{"title":"HLS","type":0,"sectionRef":"#","url":"/jellyfish-docs/getting_started/components/hls","content":"","keywords":""},{"title":"Compatibility​","type":1,"pageTitle":"HLS","url":"/jellyfish-docs/getting_started/components/hls#compatibility","content":"WebRTCRTSP "},{"title":"Env variables​","type":1,"pageTitle":"HLS","url":"/jellyfish-docs/getting_started/components/hls#env-variables","content":"Currently, there are no environment variables related to this component. "},{"title":"Example Docker commands​","type":1,"pageTitle":"HLS","url":"/jellyfish-docs/getting_started/components/hls#example-docker-commands","content":"The HLS playlist will be created inside the Docker container. To access it from the host, you need to create a volume, e.g. by adding the option -v $(pwd)/jellyfish_output:/app/jellyfish_outputto your Docker command. Other than that, your Docker commands shouldn't be affected by adding this component. docker run -p 4000:4000/tcp \\ -e SERVER_API_TOKEN=token \\ -e VIRTUAL_HOST=localhost \\ -e SECRET_KEY_BASE=secret \\ -v $(pwd)/jellyfish_output:/app/jellyfish_output ghcr.io/jellyfish-dev/jellyfish:latest  "},{"title":"Installation","type":0,"sectionRef":"#","url":"/jellyfish-docs/getting_started/installation","content":"","keywords":""},{"title":"Building from source​","type":1,"pageTitle":"Installation","url":"/jellyfish-docs/getting_started/installation#building-from-source","content":"Make sure to have Elixir installed. If not, you can do it here. Clone the Jellyfish repo git clone https://github.com/jellyfish-dev/jellyfish.git  Install native dependencies macOS IntelmacOS Apple SiliconUbuntu brew install srtp libnice clang-format ffmpeg opus pkg-config export LDFLAGS=&quot;-L/usr/local/opt/openssl@1.1/lib&quot; export CFLAGS=&quot;-I/usr/local/opt/openssl@1.1/include/&quot; export CPPFLAGS=&quot;-I/usr/local/opt/openssl@1.1/include/&quot; export PKG_CONFIG_PATH=&quot;/usr/local/opt/openssl@1.1/lib/pkgconfig&quot;  Install elixir dependencies mix deps.get  Run the server in development mix phx.server  "},{"title":"Running with Docker​","type":1,"pageTitle":"Installation","url":"/jellyfish-docs/getting_started/installation#running-with-docker","content":"Docker images are built for production which means that you always need to set a couple of environment variables. Environment variables are split into two groups: general ones - see General env variables belowpeer/component-specific - each Peer and Component can expose its own environment variables. They are always listed in a Peer/Component description. See the list of Peers and Components. As docker commands depend on peers/components you are going to use, we don't present them here but rather in each peer/component's documentation. For the full list of Jellyfish Docker images, see this page. tip Instead of passing environmental variables manually, you can use the --env-file ./env-file flag, where the env-file is a file containing the variables that the image expects, see example file .env.sample in the Jellyfish repository. "},{"title":"General env variables​","type":1,"pageTitle":"Installation","url":"/jellyfish-docs/getting_started/installation#general-env-variables","content":"Below there are general, Jellyfish environment variables. If you are running Jellyfish in development, you don't need to set any of them. MIX_ENV - defines compilation mode. This variable takes effect only when running from the source. Docker images are built with MIX_ENV=prod. Possible values are: dev - uses default values for environment variables (default option when running with mix phx.server)prod - requires you to provide values for environment variablestest - used in tests SERVER_API_TOKEN - token for authorizing HTTP requests. Defaults to development for development builds.AUTH_SALT - used to sign/encrypt tokens generated for Peers.SECRET_KEY_BASE - used to sign/encrypt cookies and other secrets.VIRTUAL_HOST - host passed to the endpoint config. Defaults to example.com for production builds.PORT - port to run the HTTP server. Defaults to 4000 both for development and production builds.OUTPUT_BASE_PATH - a base path where Jellyfish will save its artifacts. When running via docker, it's set to jellyfish_output can be mounted as -v $(pwd)/host_directory:/app/jellyfish_output. "},{"title":"WebRTC","type":0,"sectionRef":"#","url":"/jellyfish-docs/getting_started/peers/webrtc","content":"","keywords":""},{"title":"Compatibility​","type":1,"pageTitle":"WebRTC","url":"/jellyfish-docs/getting_started/peers/webrtc#compatibility","content":"HLS "},{"title":"Env variables:​","type":1,"pageTitle":"WebRTC","url":"/jellyfish-docs/getting_started/peers/webrtc#env-variables","content":"WEBRTC_USED - has to be true if WebRTC peers will be usedINTEGRATED_TURN_LISTEN_IP - the IP address on which TURN servers will listen. By default set to 127.0.0.1. When running Jellyfish via Docker, this MUST be set to 0.0.0.0, even for local tests.INTEGRATED_TURN_IP - the IP address, under which TURN will present itself to the clients. By default set to 127.0.0.1. When running Jellyfish via Docker, this MUST be set to real (non-loopback) address, even for local tests.INTEGRATED_TURN_PORT_RANGE - port range, where UDP TURN will try to open ports. By default set to 50000-59999. The bigger the range is, the more users server will be able to handle. Useful when not using the --network=host option to limit the UDP ports used only to ones published from a Docker container.INTEGRATED_TCP_TURN_PORT - port number of TCP TURNINTEGRATED_TLS_TURN_PORT - port number of TLS TURN, used when INTEGRATED_TURN_PKEY and INTEGRATED_TURN_CERT are providedINTEGRATED_TURN_CERT - SSL certificate for TLS TURNINTEGRATED_TURN_PKEY - SSL private key for TLS TURN "},{"title":"Example Docker commands​","type":1,"pageTitle":"WebRTC","url":"/jellyfish-docs/getting_started/peers/webrtc#example-docker-commands","content":"Explicit port exposure (macOS compatible) docker run -p 50000-50050:50000-50050/udp \\ -p 4000:4000/tcp \\ -e WEBRTC_USED=true \\ -e INTEGRATED_TURN_PORT_RANGE=50000-50050 \\ -e INTEGRATED_TURN_IP=192.168.0.1 \\ -e SERVER_API_TOKEN=token \\ -e VIRTUAL_HOST=localhost \\ -e SECRET_KEY_BASE=secret \\ ghcr.io/jellyfish-dev/jellyfish:latest  caution Make sure that the exposed UDP ports match INTEGRATED_TURN_PORT_RANGE. The range of the ports shouldn't be too wide as it might cause problems with container startup. Using host network (Linux only) docker run --network=host \\ -e WEBRTC_USED=true \\ -e INTEGRATED_TURN_IP=192.168.0.1 \\ -e SERVER_API_TOKEN=token \\ -e VIRTUAL_HOST=localhost \\ -e SECRET_KEY_BASE=secret \\ ghcr.io/jellyfish-dev/jellyfish:latest  "},{"title":"SDKs","type":0,"sectionRef":"#","url":"/jellyfish-docs/getting_started/sdks","content":"","keywords":""},{"title":"Server SDKs​","type":1,"pageTitle":"SDKs","url":"/jellyfish-docs/getting_started/sdks#server-sdks","content":"Elixir "},{"title":"Client SDKs​","type":1,"pageTitle":"SDKs","url":"/jellyfish-docs/getting_started/sdks#client-sdks","content":"ReactTypeScript "},{"title":"Basic Concepts","type":0,"sectionRef":"#","url":"/jellyfish-docs/introduction/basic_concepts","content":"","keywords":""},{"title":"Room​","type":1,"pageTitle":"Basic Concepts","url":"/jellyfish-docs/introduction/basic_concepts#room","content":"A room is a container for peers and components. Its meaning depends on how it is used. In the case of a video conferencing system, one Jellyfish room will represent one real room or channel where multiple people can talk to each other. In the case of a broadcasting system, one room will be a container for two components: one responsible for receiving stream from a streaming host (e.g. via RTMP) and the other one responsible for converting this stream into an HLS playlist ready to be broadcasted via CDN. "},{"title":"Component​","type":1,"pageTitle":"Basic Concepts","url":"/jellyfish-docs/introduction/basic_concepts#component","content":"A component is a server-side process that publishes or subscribes to tracks. Example components are: HLS component - subscribes to all other tracks and creates from them an HLS playlist ready to be broadcasted via CDNRTSP component - connects to the remote media source (e.g. an IP camera) and publishes its media to be consumed by other components or peers "},{"title":"Peer​","type":1,"pageTitle":"Basic Concepts","url":"/jellyfish-docs/introduction/basic_concepts#peer","content":"A peer is a client-side entity that connects to the server to publish, subscribe or publish and subscribe to tracks published by components or other peers. The peer's process is spawned after peer connects to the server. At the moment, there is only one type of peer - WebRTC. "},{"title":"Difference between Component and Peer​","type":1,"pageTitle":"Basic Concepts","url":"/jellyfish-docs/introduction/basic_concepts#difference-between-component-and-peer","content":"The most important difference between a component and a peer is that component is a purely server-side thing. It starts its work right after adding it to the server. On the other hand, a peer is something that has to connect to the server. Therefore, peers are allowed to open so-called signalling channels to the server. See also Example Scenarios. "},{"title":"Example Scenarios","type":0,"sectionRef":"#","url":"/jellyfish-docs/introduction/example_scenarios","content":"","keywords":""},{"title":"Real-time video conferencing system​","type":1,"pageTitle":"Example Scenarios","url":"/jellyfish-docs/introduction/example_scenarios#real-time-video-conferencing-system","content":"In this scenario, we want to create a simple video conferencing system where people can talk to each other in the real-time. Because of interactive and real-time requirements, the natural choice is to use the WebRTC standard. The final architecture would look like this:   "},{"title":"Broadcasting system with the real-time mixin​","type":1,"pageTitle":"Example Scenarios","url":"/jellyfish-docs/introduction/example_scenarios#broadcasting-system-with-the-real-time-mixin","content":"In this scenario, we want to create a broadcasting solution where the conversation between multiple people is broadcasted to the broader audience. Here, we choose WebRTC as a standard used for connecting people talking to each other in real-time and HLS for creating a playlist that can be then uploaded to CDN and broadcasted to the broader audience. As you can see, the whole system will automatically adapt to the number of participants talking in real-time. In particular, Jellyfish will handle a scenario with only one streamer out of the box.   "},{"title":"Displaying IP camera streams in a web browser​","type":1,"pageTitle":"Example Scenarios","url":"/jellyfish-docs/introduction/example_scenarios#displaying-ip-camera-streams-in-a-web-browser","content":"In this scenario, we have a set of IP cameras and we want to display their streams in a web browser. IP cameras very often use RTSP for streaming media but browsers don't ship with support for this protocol. Therefore, to display audio and video in a web browser, we have to use either WebRTC or HLS. Because, in this scenario, the delay is not the most crucial thing, we choose HLS. The most important thing here is that the RTSP component connects to the IP camera and then the camera starts streaming. It's not the camera that initializes the connection to the server. Therefore, the RTSP component is a purely server-side thing - once you add it, it should be able to work on its own.   "}]